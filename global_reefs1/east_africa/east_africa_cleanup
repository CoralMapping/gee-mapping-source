/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var global_not_applied = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry({
      "type": "GeometryCollection",
      "geometries": [
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                32.676419764538565,
                -27.549292522760904
              ],
              [
                32.68156960584716,
                -27.558880531080447
              ],
              [
                32.68723443128661,
                -27.557206494716095
              ],
              [
                32.69358590223388,
                -27.540008098027023
              ],
              [
                32.698392420788565,
                -27.513824839845743
              ],
              [
                32.69272759534911,
                -27.502405769433285
              ],
              [
                32.68586114027099,
                -27.49372648339825
              ],
              [
                32.676419764538565,
                -27.489767283557928
              ],
              [
                32.66835167982177,
                -27.50042634338819
              ],
              [
                32.66474679090575,
                -27.52813506764874
              ],
              [
                32.66972497083739,
                -27.543204463961928
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                35.55421830196509,
                -22.518642831879085
              ],
              [
                35.553445825768804,
                -22.52252781698117
              ],
              [
                35.55576325435767,
                -22.52419277715876
              ],
              [
                35.557394037438726,
                -22.52752263732008
              ],
              [
                35.558681497765875,
                -22.52950465883223
              ],
              [
                35.56185723323951,
                -22.530376739287608
              ],
              [
                35.56172845883548,
                -22.534935253136222
              ],
              [
                35.56305886287818,
                -22.53703608118008
              ],
              [
                35.56529046077857,
                -22.536718976943586
              ],
              [
                35.56666377663612,
                -22.539097171426008
              ],
              [
                35.566921243859625,
                -22.540365631691685
              ],
              [
                35.56803704280982,
                -22.54044490572518
              ],
              [
                35.56949616451392,
                -22.53917651572685
              ],
              [
                35.57198525447974,
                -22.533944283809934
              ],
              [
                35.57207108516822,
                -22.529108256805014
              ],
              [
                35.5739593603147,
                -22.522686385481542
              ],
              [
                35.573186884118414,
                -22.517294954385186
              ],
              [
                35.56803704280982,
                -22.518087825091296
              ],
              [
                35.564174661828375,
                -22.520862836740502
              ],
              [
                35.56108475704322,
                -22.521734971749645
              ],
              [
                35.55825234432349,
                -22.520307838868693
              ],
              [
                35.55524827022681,
                -22.517929251313973
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                35.579935250766184,
                -22.757746166644452
              ],
              [
                35.57478540945759,
                -22.76945966537206
              ],
              [
                35.5725538115572,
                -22.781805238176137
              ],
              [
                35.578390298373606,
                -22.784970589740627
              ],
              [
                35.58302515555134,
                -22.78133042910657
              ],
              [
                35.587660012729074,
                -22.76993451574627
              ],
              [
                35.58834665823689,
                -22.76154524930245
              ],
              [
                35.58457010794392,
                -22.756954677789142
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                32.968816617336586,
                -26.350994198253545
              ],
              [
                32.962808469143226,
                -26.361761400896278
              ],
              [
                32.967100003567055,
                -26.37175861985954
              ],
              [
                32.97963128408463,
                -26.366990823281665
              ],
              [
                32.98323617300065,
                -26.355301199610476
              ],
              [
                32.975339749660805,
                -26.346071714607852
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        }
      ],
      "coordinates": []
    }),
    RC_landDist_not_applied = 
    /* color: #98ff00 */
    /* shown: false */
    ee.FeatureCollection([]),
    BRS_SL_to_RS = 
    /* color: #2cc2d6 */
    /* shown: false */
    ee.Geometry({
      "type": "GeometryCollection",
      "geometries": [
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                34.8993740560551,
                -24.451736961766553
              ],
              [
                34.2401943685551,
                -24.681548767522877
              ],
              [
                32.7021084310551,
                -25.353544372384885
              ],
              [
                32.8229580404301,
                -25.745068218961524
              ],
              [
                35.4486904623051,
                -24.536716483785526
              ],
              [
                35.1795254232426,
                -24.32666293644514
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                32.72590652327876,
                -27.053887892871806
              ],
              [
                32.44512910097136,
                -28.233967802908612
              ],
              [
                32.55773896425261,
                -28.275096510680086
              ],
              [
                32.75191382431799,
                -27.597512870538118
              ],
              [
                32.65684018178937,
                -27.53809131785919
              ],
              [
                32.655200495928476,
                -27.495706176830303
              ],
              [
                32.78094756516849,
                -27.501070960371248
              ],
              [
                32.89752740865687,
                -27.07301578239754
              ],
              [
                32.82611627584437,
                -27.055895054925113
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                32.85798580113363,
                -26.89291988346941
              ],
              [
                32.925277060899255,
                -26.902717652954518
              ],
              [
                32.97059566441488,
                -26.523663198621005
              ],
              [
                32.95683395302527,
                -26.297276013372716
              ],
              [
                32.995983238291714,
                -26.031079011192272
              ],
              [
                32.960664423625694,
                -25.99587780469862
              ],
              [
                32.92252920021454,
                -26.253025688326865
              ],
              [
                32.89094478550863,
                -26.51629044903986
              ],
              [
                32.85523921910238,
                -26.818183962200195
              ],
              [
                32.86347896519613,
                -26.87209680191618
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                35.51055505238659,
                -22.849439159900374
              ],
              [
                35.54214074574597,
                -22.836150480207724
              ],
              [
                35.54488732777722,
                -22.573275334316108
              ],
              [
                35.56480004750378,
                -22.331154164037393
              ],
              [
                35.53252770863659,
                -22.32162659875825
              ],
              [
                35.54832055531628,
                -22.286686628861855
              ],
              [
                35.55656030141003,
                -22.15383517187605
              ],
              [
                35.54076745473034,
                -22.15256325870459
              ],
              [
                35.53115441762097,
                -22.20025213084397
              ],
              [
                35.527721190081905,
                -22.23966270691945
              ],
              [
                35.527721190081905,
                -22.27588523407776
              ],
              [
                35.51810815297253,
                -22.320356207566043
              ],
              [
                35.46877409146379,
                -22.566036886338377
              ],
              [
                35.48731352017473,
                -22.80993882501786
              ],
              [
                35.50035978482317,
                -22.846644804241663
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                35.53311473278816,
                -22.997428588164357
              ],
              [
                35.45286602445518,
                -23.13932487173761
              ],
              [
                35.445312923869245,
                -23.276269910579618
              ],
              [
                35.42306806053421,
                -23.44898192646757
              ],
              [
                35.41482831444046,
                -23.61832655426154
              ],
              [
                35.43680097069046,
                -23.612035119326194
              ],
              [
                35.5157652040889,
                -23.305649318817014
              ],
              [
                35.47456647362015,
                -23.295559011347645
              ],
              [
                35.470446600573275,
                -23.204711841215296
              ],
              [
                35.506152166979525,
                -23.200925200149115
              ],
              [
                35.632494940417025,
                -22.9330650680886
              ],
              [
                35.5871763369014,
                -22.93938865564096
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        }
      ],
      "coordinates": []
    }),
    sg_orf = /* color: #01d648 */ee.Geometry({
      "type": "GeometryCollection",
      "geometries": [
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                39.40612676077252,
                -6.121263338289695
              ],
              [
                39.40818669729596,
                -6.207963050258013
              ],
              [
                39.46105840139752,
                -6.217178325841969
              ],
              [
                39.517706655792054,
                -6.192262579916194
              ],
              [
                39.49882390432721,
                -6.131162839597013
              ],
              [
                39.42020299368268,
                -6.090880966060708
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                39.21924044088214,
                -5.791197807237815
              ],
              [
                39.22748018697589,
                -5.811008549104571
              ],
              [
                39.23331623923131,
                -5.8605322341795425
              ],
              [
                39.24687784077622,
                -5.859678529736054
              ],
              [
                39.25494600728839,
                -5.8465295114962
              ],
              [
                39.26129757654849,
                -5.812716345829112
              ],
              [
                39.29417092144071,
                -5.815449099455933
              ],
              [
                39.300951256311826,
                -5.799053874337209
              ],
              [
                39.28944975160068,
                -5.749353769813972
              ],
              [
                39.24498964742511,
                -5.7707032052816025
              ],
              [
                39.23125673726886,
                -5.761138803997209
              ],
              [
                39.22164370015948,
                -5.769678455714019
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                39.36013032166376,
                -5.986769287814621
              ],
              [
                39.37557984558954,
                -6.025351803446606
              ],
              [
                39.39617921082392,
                -6.026717506062485
              ],
              [
                39.40167237488642,
                -6.011353153662165
              ],
              [
                39.38038636414423,
                -5.976525683625023
              ],
              [
                39.36322022644892,
                -5.978232964313484
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                39.183086403664646,
                -6.279948230965789
              ],
              [
                39.179138191994724,
                -6.285067144441533
              ],
              [
                39.18780690401701,
                -6.294537022601267
              ],
              [
                39.19814948971321,
                -6.30345223624019
              ],
              [
                39.207805641945896,
                -6.3055422942514925
              ],
              [
                39.21724701767832,
                -6.323628004164029
              ],
              [
                39.238018044289646,
                -6.337789014740469
              ],
              [
                39.251750959555324,
                -6.344101686193319
              ],
              [
                39.25346756821543,
                -6.337106565308094
              ],
              [
                39.24539903588488,
                -6.3111727409681935
              ],
              [
                39.22548676377207,
                -6.304006686028003
              ],
              [
                39.2162170494166,
                -6.2937691817319665
              ],
              [
                39.205059059914646,
                -6.287285324641041
              ],
              [
                39.1971626365748,
                -6.280972017688519
              ],
              [
                39.19441605454355,
                -6.275938380254635
              ],
              [
                39.18651963120371,
                -6.273293568212134
              ],
              [
                39.18265725022226,
                -6.275853063946673
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                39.754322257042574,
                -4.957178211394608
              ],
              [
                39.7996408605582,
                -5.013270147159199
              ],
              [
                39.842212882042574,
                -4.994117342114343
              ],
              [
                39.861438956261324,
                -4.9455487975516315
              ],
              [
                39.86487218380039,
                -4.90450217809515
              ],
              [
                39.82985326290195,
                -4.875083880667678
              ],
              [
                39.776294913292574,
                -4.8805571500635985
              ],
              [
                39.75363561153476,
                -4.931182769091941
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                39.66675718397846,
                -4.14257315735922
              ],
              [
                39.71070249647846,
                -4.091378853211468
              ],
              [
                39.726838665912055,
                -4.055934723376903
              ],
              [
                39.778940429538004,
                -3.9683212334831293
              ],
              [
                39.84159868406758,
                -3.835760498671923
              ],
              [
                40.367440049121925,
                -2.9363775511964185
              ],
              [
                40.016950228502886,
                -2.9057701449251176
              ],
              [
                39.825547346284445,
                -3.7307628686296685
              ],
              [
                39.821855773776285,
                -3.823088780148106
              ],
              [
                39.75078796371769,
                -3.9566761641879236
              ],
              [
                39.685556640475504,
                -4.054626597036587
              ],
              [
                39.66118072494816,
                -4.097090945208608
              ],
              [
                39.644357910006754,
                -4.137156045900644
              ],
              [
                39.6412680052216,
                -4.150853052387614
              ],
              [
                39.65465759262394,
                -4.1559893685987195
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                39.59042780330886,
                -7.942360823400032
              ],
              [
                39.57806818416824,
                -7.945081050038628
              ],
              [
                39.60004084041824,
                -8.019200268060471
              ],
              [
                39.637806343347926,
                -8.08106927593482
              ],
              [
                39.6584057085823,
                -8.11234011511399
              ],
              [
                39.69754450252761,
                -8.123896114468419
              ],
              [
                39.74904291561355,
                -8.08990693306657
              ],
              [
                39.82938044002761,
                -7.975002352141913
              ],
              [
                39.84585993221511,
                -7.92535899892207
              ],
              [
                39.82800714901199,
                -7.887952514801234
              ],
              [
                39.63915215654094,
                -7.954503741498445
              ],
              [
                39.60619317216594,
                -7.953823702145629
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                40.17727023374064,
                -10.226967291432741
              ],
              [
                40.1528943182133,
                -10.22764302690138
              ],
              [
                40.13813143979533,
                -10.244198096494717
              ],
              [
                40.12920504819377,
                -10.256698290590062
              ],
              [
                40.11512881528361,
                -10.245211644115113
              ],
              [
                40.1144421697758,
                -10.294195909808932
              ],
              [
                40.18756991635783,
                -10.28203500735506
              ],
              [
                40.26150025368297,
                -10.318630377897831
              ],
              [
                40.2851895237025,
                -10.300728051459147
              ],
              [
                40.299265756612655,
                -10.261204224373808
              ],
              [
                40.280039682393905,
                -10.250055584988061
              ],
              [
                40.27763642311656,
                -10.234852262792415
              ],
              [
                40.26768006325328,
                -10.215931555782012
              ],
              [
                40.253603830343124,
                -10.200050807442807
              ],
              [
                40.23918427467906,
                -10.199375013340545
              ],
              [
                40.22373475075328,
                -10.195658120145907
              ],
              [
                40.21377839089,
                -10.200388703956133
              ],
              [
                40.19180573464,
                -10.227081394527133
              ],
              [
                40.18425263405406,
                -10.228480364510899
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                38.69914229632237,
                -17.3176175494648
              ],
              [
                38.77604659319737,
                -17.45129473856267
              ],
              [
                39.87467940569737,
                -16.6004130081439
              ],
              [
                40.17002782137282,
                -16.342905928695988
              ],
              [
                40.253424673143925,
                -16.153186482844603
              ],
              [
                40.163790817766795,
                -16.09271522619858
              ],
              [
                40.09165205162679,
                -16.261888756881067
              ],
              [
                39.81150801897862,
                -16.510900604968867
              ],
              [
                38.74583419085362,
                -17.231068646125838
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                35.19498188128119,
                -21.639664974011765
              ],
              [
                35.25540668596869,
                -22.135365929409517
              ],
              [
                35.33231098284369,
                -22.313343504923438
              ],
              [
                35.44354755510931,
                -22.277766072352563
              ],
              [
                35.48062641253119,
                -22.111194444856206
              ],
              [
                35.46799316005893,
                -21.93064521512791
              ],
              [
                35.444647212793306,
                -21.887962665501366
              ],
              [
                35.46249999599643,
                -21.814034318116956
              ],
              [
                35.450140376855806,
                -21.777055813032092
              ],
              [
                35.48721923427768,
                -21.538379752944504
              ],
              [
                35.47623290615268,
                -21.499413929357473
              ],
              [
                35.246893306543306,
                -21.47705177455241
              ],
              [
                35.183721919824556,
                -21.50963548402589
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                35.37136645545757,
                -23.655182888732366
              ],
              [
                35.38853259315288,
                -23.788452505508754
              ],
              [
                35.48191638221538,
                -23.887687341942545
              ],
              [
                35.538221313856006,
                -23.843103868206416
              ],
              [
                35.565687134168506,
                -23.80541573526663
              ],
              [
                35.463376953504444,
                -23.557029725374914
              ],
              [
                35.389219238660694,
                -23.574652368926287
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                32.88757127707591,
                -25.953278492813983
              ],
              [
                32.87898820822825,
                -26.068058476041926
              ],
              [
                32.98782152121653,
                -26.089335966994824
              ],
              [
                33.026960315161844,
                -25.9474130643501
              ],
              [
                32.8927211183845,
                -25.93784252749099
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        }
      ],
      "coordinates": []
    }),
    BRS_Dl_SLNoDATA = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[40.53500169770654, -11.180543022089106],
          [40.5109691049331, -11.225671622352081],
          [40.47663682954248, -11.261028657611032],
          [40.48384660737451, -11.346877633047551],
          [40.48350174141172, -11.374646650654409],
          [40.49689287202295, -11.392653213731837],
          [40.49860948579248, -11.436402396231095],
          [40.49139970796045, -11.46466750682375],
          [40.482473316358885, -11.484182242844518],
          [40.46805376069482, -11.531617603433297],
          [40.46359056489404, -11.616712011282715],
          [40.45809740083154, -11.632180936616953],
          [40.46015733735498, -11.658408888165024],
          [40.46977037446435, -11.679927408852395],
          [40.471486988233885, -11.688668830860877],
          [40.48212999360498, -11.703797562992857],
          [40.520499351413804, -11.640837699077284],
          [40.523157711351985, -11.630330649748311],
          [40.51680559174951, -11.617720880422873],
          [40.522642078565916, -11.58812586921545],
          [40.50753587739404, -11.520852833164637],
          [40.520925464796385, -11.48283644230617],
          [40.54255479829248, -11.479135457716971],
          [40.55525774018701, -11.454573148728961],
          [40.53122514741357, -11.407124843509402],
          [40.510452848553896, -11.377339341234082],
          [40.51680559174951, -11.36236137291289],
          [40.51852120557651, -11.314222397334264],
          [40.53534502046045, -11.305134676328942],
          [40.54449080493048, -11.286900126704829],
          [40.56496735588515, -11.226918712930662],
          [40.55398102776015, -11.175727746611818]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/

///////////////////////////////
// Global coral atlas project - East Africa & Madagascar
// Contact: mitchell.lyons@gmail.com
// Region coordinator:  v1: Rodney Borrego (rodbio2008@gmail.com); v2: ...
// Description: 
// - Developing a process to combine OBIA and supervised classification
// - This script loads the raw classification data (from *_classification script)
// - Then applied some cleanup and object-based relational rules
///////////////////////////////

// Table of contents
// 1. Setting constants
// 2. Data loads & vis
// 3. OBIA clean up rules
// 4. Export

// Load and libraries needed
var map_palettes = require('users/mitchest/global_reefs_modules:colour_pals');
var pkg_vis = require('users/mitchest/global_reefs_modules:pkg_vis');
var param_module = require('users/mitchest/global_reefs_modules:reef_params');

// ###########################################
// SENSOR GENERICSgeo_depth_cutoff
var sensor_params = param_module.dove;         //<------------ THIS IS WHERE YOU CHOOSE THE SENSOR
// REGION AND SENSOR SPECIFIC LOAD PATHS
var region_params = param_module.east_africa;  //<------------ THIS IS WHERE YOU CHOOSE THE REGION
//  ^^ all the data paths are in this module ^^
// ###########################################

// 1. Setting constants

// These will get written to the asset metadata 

var vars = {
  
  // analysis type
  geomorphic: false, // map geomorphic zonation (when set to true) or benthic habitat (when set to false)

  // analysis parameters
  image_data_scale: sensor_params.pixel,
  small_object_geo: ee.Number(400).int(), // smallest object szie in pixels (geomorphic)
  small_object_benthic: ee.Number(130).int(), // smallest object szie in pixels (benthic)
  smooth_radius: ee.Number(3), // radius in pixels for initial smooth 
  dist_to_land_ORF: 1000, //distance to land in meters to convert terrestrial reef flat to ORF
  dist_to_land_RC: 200, //distance to land in meters to convert reef crest to TRF
  wave_height: 0.21, //cut off height for waves in metres, Hs95 threshold
  geo_depth_cutoff: 1400, //depth in centimetres
  shallowlag_depth_cutoff: 500, //depth in centimetres
  benthic_depth_cutoff: 1000, //depth in centimetres
  lagoon_region: "Eastern Africa and Madagascar",
  
  //############
  // Clean-up stage selection
  cleanup_stage: 2, // set to 1, 2 or 3
  geo_refinement: false, // set to true to apply the refinement_mask (the other stage 3 masks will still run)
  
  // should the global extent + depth cleanup be applied?
  global_extent_clean: true,
  global_depth_thresh: 500, // this is the depth limit for ADDING to the global extent (i.e. 5 = everything <5m will be added to the global extent layer)
  global_land_dist: -1, // [-1 (don't apply) OR +ve distance in meters] WITHIN this distance, the global extent/depth mask will be applied
  global_not_applied: true, // true = EXCLUDE reefs within 'global_not_applied' geometry polygons - mutually exclusive to land distance rule
 
  /*
  - GEOMORPHIC 1: The first pass does a small object filter, just to generally clean noise and reduce the amount of cleaning needed
  -            2: The second pass runs the OBIA cleanup rules
  -            3: The third pass is the MANUAL cleanup stage, which includes AT LEAST the no_reef masking
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY

  - BENTHIC 1: This is the main benthic stge - it does noise removal, no data reclaim and OBIA rules - review those if needed
            2: The second mas is the MANUAL stage - it's optional, but shuold include ALL region specific stuff
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY
  */
  
  // DON'T TOUCH --->
  obia_2nd_pass: null,
  obia_clean: null, // run object-based relationship rules + small object clean up
  fast_clean: null, // run a faster (but less precise) version of the OBIA clean; only applies to geomorphic (`obia_clean: true` also)
  manual_clean: false, // apply manual touch ups
  // --------------<
  //############
  
  reproject_display: true,
  
  // export options
  do_export: true, // export the results?
  geomorph_output_name: region_params.sname + '_geo_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  benthic_output_name: region_params.sname + '_benthic_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  asset_output: region_params.asset, // asset path
  local_epsg: region_params.epsg

};


// Clean up stage auto-parameterisation (DON'T TOUCH) --->

if (vars.geomorphic) {
  var temp_outname = vars.geomorph_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.obia_2nd_pass = true;
    vars.obia_clean = true;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '2';
  } else if (vars.cleanup_stage == 3) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = false;
    vars.do_export = false;
    vars.geomorph_output_name = temp_outname + '3';
  }
}

if (!vars.geomorphic) {
  var temp_outname = vars.benthic_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = true,
    vars.obia_clean = true, 
    vars.fast_clean = false, 
    vars.manual_clean = false;
    vars.benthic_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false,
    vars.obia_clean = false, 
    vars.fast_clean = false,
    vars.do_export = false;
    vars.benthic_output_name = temp_outname + '2';
  }
}

//Region extent is created in map viewer and exported to GEE asset
var region_extent = ee.FeatureCollection(region_params.extent_mask).geometry();
Map.addLayer(region_extent, {}, "Manual reef outline", false);
// -----------------------------------------<

//################################################################################################
//START OF CLEAN 3 - Manual Cleanup
//Review everything in this section
//This is the section to add/remove manual cleanups
//You MUST review it for each region

//###############################################################################################

if (vars.manual_clean && vars.geomorphic) {
  
  print("Doing GEOMORPHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.segments).select('depth');
  
  // define the manually edited map - uses the output from the second pass of cleaning
  var man_geo = ee.Image(region_params.geo_map_clean2);

  // the "GLOBAL MASK" clean
  // currently uses GCRMN extent + bathymetry threhold < vars.global_depth_thresh
  if (vars.global_extent_clean) {
    var blanket_mask = ee.Image([param_module.global_extent_mask.gcrmn]).unmask(0, false)
              .eq(1) // extent according to global extent layer
              .add(depth.lt(vars.global_depth_thresh)) // combine with areas less than depth thrshold
              .eq(0) // get leftovers
              .selfMask().connectedPixelCount(100, false).gte(100).unmask(0, false);
    
    blanket_mask = blanket_mask.where({
      test: blanket_mask.eq(0).connectedPixelCount(100,false).lt(100),
      value: ee.Image(1)
    });
    
    Map.addLayer(blanket_mask.selfMask(), {min:0,max:1}, "Global clean mask", false);
    
    if (vars.global_land_dist > 0) {
      var distToLand = ee.Image(region_params.distToLand);
      man_geo = man_geo.where({
        test: blanket_mask.eq(1)
                          .and(distToLand.lte(vars.global_land_dist)),
        value: ee.Image(0)
      });
    } else if (vars.global_not_applied) {
      var global_not_applied_i = ee.Image().byte().paint(ee.Feature(global_not_applied, {zone: 1}), 'zone').unmask(0, false);
      man_geo = man_geo.where({
        test: blanket_mask.eq(1)
                          .and(global_not_applied_i.eq(0)),
        value: ee.Image(0)
      });
    } else {
      man_geo = man_geo.where({
        test: blanket_mask.eq(1),
        value: ee.Image(0)
      });
    }
  }
  
  // the "MID MASK" CLEAN
  //  - import the mid mask from asset ****only use ee.FC if mid_mask created in map viewer****
  var mid_mask = ee.FeatureCollection(region_params.mid_mask).geometry();
  Map.addLayer(mid_mask, {color: 'red'}, "mid mask import", false, 0.4);
  var midmask = ee.Image().byte().paint(ee.Feature(mid_mask.dissolve(),{zone: 1}), "zone");
  
  man_geo = man_geo.where({
    test: midmask.eq(1),
    value: ee.Image(0)
  });
  
  
  // the "LAGOONS MASK" CLEAN
  // - import the global lagoon mask from asset
  
  // LAGOON clean stage 1 - clean inside the lagoon extent
  var lagoons_mask = ee.FeatureCollection(region_params.lagoons_mask).filterBounds(region_extent).geometry();
  var lagoons_mask_i = ee.Image().byte().paint(ee.Feature(lagoons_mask,{zone: 1}), "zone");
  Map.addLayer(lagoons_mask, {}, "lagoon mask", false);
  
  var ocean_lagoon_mask = ee.FeatureCollection(region_params.lagoons_mask)
                                    .filterBounds(region_extent).filter(ee.Filter.neq("LagoonType", "ClosedTerrestrial"))
                                    .geometry();
  var ocean_lagoon_mask_i = ee.Image().byte().paint(ee.Feature(ocean_lagoon_mask,{zone: 1}), "zone");
  Map.addLayer(ocean_lagoon_mask, {}, "ocean lagoon mask", false);
  
  // RC within Lagoon -> ORF
  man_geo = man_geo.where({
    test: lagoons_mask_i.eq(1)
                        .and(man_geo.eq(15)),
    value: ee.Image(14)
  });
  // Reef slope, sheltered slope (within lagoon mask) -> Back Reef Slope
  man_geo = man_geo.where({
    test: lagoons_mask_i.eq(1)
                        .and(man_geo.eq(21).or(man_geo.eq(22))),
    value: ee.Image(24)
  });
  // Plateau within lagoon mask -> Deep
  man_geo = man_geo.where({
    test: lagoons_mask_i.eq(1)
                        .and(man_geo.eq(23)),
    value: ee.Image(2)
  });
  // TRF within oceanic/closed lagoons -> ORF
  man_geo = man_geo.where({
    test: ocean_lagoon_mask_i.eq(1)
                             .and(man_geo.eq(16)),
    value: ee.Image(14)
  });
  

  // LAGOON clean stage 2 - buffer the lagoon mask, and clean inside buffer
  var lagoon_buffered = lagoons_mask.buffer(1000); // buffer 1000 m wide around reef mask
  var reef_band_mask = lagoon_buffered.difference(lagoons_mask);//substract buffered lagoon mask - lagoon mask resulting in band around reef of 1000 m
  var reef_band_mask_i = ee.Image().byte().paint(ee.Feature(reef_band_mask.dissolve(),{zone: 1}), "zone");

  // BRS, DL and SL should not be present on outside of reef on within reef_band_mask_i  -> Reef Slope
  man_geo = man_geo.where({
   test: reef_band_mask_i.eq(1)
                         .and(man_geo.eq(24).or(man_geo.eq(12)).or(man_geo.eq(11))),
    value: ee.Image(22)
  });    
  // IRF or TRF on within reef_band_mask_i  -> ORF as RC would get artefacts
  man_geo = man_geo.where({
    test: reef_band_mask_i.eq(1)
                          .and(man_geo.eq(13).or(man_geo.eq(16))),
    value: ee.Image(14)
  });   
  
  
  // The 'TURBID WATER' clean
  var turbid_mask = ee.FeatureCollection(region_params.turbid_mask).filterBounds(region_extent).geometry();
  var turbid_mask_i = ee.Image().byte().paint(ee.Feature(turbid_mask,{zone: 1}), "zone");
  Map.addLayer(turbid_mask, {}, "turbid mask", false);
  
  // leave only TRF within turbid mask (after changing ORF to TRF)
  man_geo = man_geo.where({
    test: turbid_mask_i.eq(1)
                       .and(man_geo.eq(14)),
    value: ee.Image(16)
  });
  
  man_geo = man_geo.where({
    test: turbid_mask_i.eq(1)
                       .and(man_geo.neq(16)),
    value: ee.Image(2)
  });
  
  
  // The 'HARBOUR & SHIPPING' clean
  var harbour_mask = ee.FeatureCollection(region_params.harbour_mask).filterBounds(region_extent).geometry();
  var harbour_mask_i = ee.Image().byte().paint(ee.Feature(harbour_mask,{zone: 1}), "zone");
  Map.addLayer(harbour_mask, {}, "harbour mask", false);
  
  // remove mapping within harbour mask
  man_geo = man_geo.where({
    test: harbour_mask_i.eq(1)
                        .and(man_geo.gt(2)),
    value: ee.Image(2)
  });
  
  //********************************************************************************************
  // The 'narrow coastline of south africa' clean chris add it
  //********************************************************************************************
  var BRS_SL_to_RS_mask = ee.Image().byte().paint(ee.Feature(BRS_SL_to_RS, {zone: 1}), "zone");
  
 
  //*************within mask BRS, SL, Dl, TRF changed to RS (not the best rule but all other is wrong)
  man_geo = man_geo.where({
  test: BRS_SL_to_RS_mask.eq(1)
             .and((man_geo.eq(11))
             .or(man_geo.eq(12))
             .or(man_geo.eq(24))
             .or(man_geo.eq(16))),// TRF 16, SL 11, DL 12, BRS 24
  value: ee.Image(22)
  });
  //********************************************************************************************
  //*************within ORF and mask where RC change to CA (based new feedback)
  //********************************************************************************************
  
   //********************************************************************************************
  // The 'area of mixed water had different classes' clean chris add it
  //********************************************************************************************
  var BRS_Dl_SLNoDATA_mask = ee.Image().byte().paint(ee.Feature(BRS_Dl_SLNoDATA, {zone: 1}), "zone");
  
 
  //*************within mask BRS, SL, Dl, changed to RS to deep water (not the best rule but all other is wrong)
  man_geo = man_geo.where({
  test: BRS_Dl_SLNoDATA_mask.eq(1)
             .and((man_geo.eq(11))
             .or(man_geo.eq(12))
             .or(man_geo.eq(24))),// SL 11, DL 12, BRS 24
  value: ee.Image(2)
  });
  //********************************************************************************************
  //*************within ORF and mask where RC change to CA (based new feedback)
  //********************************************************************************************
  /*/ the 'WAVE' clean (un-comment this sectio nbased on whether you have waves or not)*/
  var waves = ee.Image(region_params.waves);
  Map.addLayer(waves.lt(vars.wave_height), {}, vars.wave_height + "m Hs95 threshold", false);
  
  man_geo = man_geo.where({
    test: waves.lte(vars.wave_height)
               .and(man_geo.eq(22)),
    value: ee.Image(21)
  });
  
  
  /*// the "DISTANCE TO DEEP WATER" CLEAN
  // use a distance to deepwater to cut out RC/slope
  var dist_to_deep = man_geo.eq(2).fastDistanceTransform(256).sqrt()
                                  .multiply(ee.Image.pixelArea().sqrt())
                                  .uint16()
                                  .selfMask();
  Map.addLayer(dist_to_deep, {}, "distance to deepwater", false);
  
  // reef crest too far from deep water -> ORF
  man_geo = man_geo.where({
    test: man_geo.eq(15)
                 .and(dist_to_deep.gte(300)),
    value: ee.Image(14)
  });
  // reef slope too far from deep wter -> BRS
  man_geo = man_geo.where({
    test: man_geo.eq(21).or(man_geo.eq(22))
                 .and(dist_to_deep.gte(1500)),
    value: ee.Image(24)
  });*/
  
  /*
  ##############
  
  The rest of the manual geometry paintings and rules should go here
      - make the geom, paint the layer, use it in a rule
      - consult previous regions *_cleanup script for ideas/hints/existing rules etc.
  e.g. 
  var notreefcrest = ee.Image().byte().paint(ee.Feature(not_reef_crest, {zone: 1}), "zone");
  var notdeepwater = ee.Image().byte().paint(ee.Feature(not_deep_water, {zone: 1}), "zone");
  
  
  // Reef crest -> Inner reef flat (inside the reef)
  man_geo = man_geo.where({
    test: notreefcrest.eq(1)
                     .and(man_geo.eq(15)),
    value: ee.Image(13)
  });
  
  // Deep water -> Deep lagoon (inside the reef)
  man_geo = man_geo.where({
    test: notdeepwater.eq(1)
                     .and(man_geo.eq(2)),
    value: ee.Image(12)
  });
  
  ##############
  */
  
  
  /*// TRF -> ORF within manual mask
  var trf_to_orf_i = ee.Image().byte().paint(ee.Feature(trf_to_orf,{zone: 1}), "zone");
  man_geo = man_geo.where({
    test: trf_to_orf_i.eq(1)
                      .and(man_geo.eq(16)),
    value: ee.Image(14)
  });*/
  
  /*// attempt to gain back missing reef crest
  var reef_crest_smooth = man_geo.eq(15).selfMask().focalMode(10);
  Map.addLayer(reef_crest_smooth, {colour: 'red'}, "reef crest smooth", false);
  //var reef_crest_holes = man_geo.gt(2).unmask(0,false).connectedComponents(ee.Kernel.plus(1), 512);
  //Map.addLayer(reef_crest_holes, {}, "reef crest holes", false);*/
  var distToLand = ee.Image(region_params.distToLand);
  
 /* man_geo = man_geo.unmask(0, false).where({
    test: reef_crest_smooth.eq(1)
                           //.and(reef_crest_holes.select('labels').gt(1))
                           .and(man_geo.unmask(0, false).eq(0)),
    value: ee.Image(15)
  }).selfMask();*/
  
  /*// special WMIC case to deal with S2 data
  man_geo = man_geo.where({
    test: man_geo.eq(12).or(man_geo.eq(22))
                 .and(segments.select('depth').unmask(0,false).eq(0)),
                 //.and(lagoons_mask_i.uint8().unmask(0,false).lt(1)),
    value: ee.Image(2)
  })*/
  
  // mask to deep and anything removed to this point + re-do land
  man_geo = man_geo.where({
    test: distToLand.eq(0),
    value: ee.Image(0)
  });
  
  man_geo = man_geo.updateMask(man_geo.gt(2)).selfMask();
  
  if (vars.geo_refinement) {
    // make the mask image layer
    var refine = ee.Image().byte().paint(ee.Feature(refinement_mask, {zone: 1}), "zone").clip(refinement_mask);
    // apply
    man_geo = man_geo.where({
      test: refine.eq(1),
      value: ee.Image(0)
    });
  }
  
  // Add data + the manual layer to the map
  var lowtide_image = ee.Image(region_params.pixels).select(['b1','b2','b3']);
  Map.addLayer(lowtide_image, region_params.visParams, sensor_params.sname + ' low tide', false);
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(geo_clean2, map_palettes.geo, 'Geo clean stage 2', false);
  Map.addLayer(man_geo.updateMask(man_geo), map_palettes.geo, 'Geo clean stage 3', false);

  // display distance to land mask for assessing cut-off distances
  Map.addLayer(distToLand, {}, 'Distance to land mask', false);
  
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_geo,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: region_extent,
    scale: vars.image_data_scale,
    crs: vars.local_epsg,
    maxPixels: 1e13,
    shardSize: 256, // SWP specific cuase of size?
    pyramidingPolicy: {'.default': 'mode'}
  });
  
} 

if (vars.manual_clean && !vars.geomorphic) {
  
  print("Doing BENTHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.segments).select('depth');
  var dove_b1 = ee.Image(region_params.pixels).select('b1');
  
  // define the final geomorphic map (the manually edited geo map - stage 3)
  var geo_map = ee.Image(region_params.geo_map_clean3);
  
  // define the clean benthic map to apply 2nd stage rules to
  var man_benthic = ee.Image(region_params.benthic_map_clean1);
  
  // Deep (or land or missing) in geo == masked from benthic
  man_benthic = man_benthic.where({
    test: geo_map.unmask(0).lte(2),
    value: ee.Image(0)
  });
  
  
  /*
  ** Generic benthic rules **
    - should be generally applicable, but still review
  */
  
  // BMA on inner RF, outer RF,reef crest, reef slope -> rubble 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(18)
                     .and(geo_map.eq(13).or(geo_map.eq(14)).or(geo_map.eq(15)).or(geo_map.eq(22))),
    value: ee.Image(12)
  });
  
  /*// Rubble on Outer reef flat and Reef crest -> rock 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(12)
                     .and(geo_map.eq(14).or(geo_map.eq(15))),
    value: ee.Image(13)
  });*/
  // Rubble on Reef crest -> rock 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(12)
                     .and(geo_map.eq(15)),
    value: ee.Image(13)
  });
  
  
  // Sand in benthic and reef crest in geo --> coral/aglae
  man_benthic = man_benthic.where({
    test: man_benthic.eq(11)
                     .and(geo_map.eq(15)),
    value: ee.Image(15)
  });
   // Seagrass on RC or ORF -> Coral/Algae
  /*// except for these two areas (use if there are exceptions, e.g. in Indonesia this can occur)*/
  var sg_orf = ee.Image().byte().paint(ee.Feature(sg_orf, {zone: 1}), "zone").unmask(geo_map.eq(42));
  
  man_benthic = man_benthic.where({
    test: man_benthic.eq(14)
                     .and(sg_orf.eq(0))//leave sg back in to some seyschell reefs that have sg on orf
                     .and(geo_map.eq(14).or(geo_map.eq(15))),
    value: ee.Image(15)
  });    

  // Rubble on slope --> rock
  man_benthic = man_benthic.where({
    test: man_benthic.eq(12)
                     .and(geo_map.eq(21).or(geo_map.eq(22))),
    value: ee.Image(13)
  });  
  
  // Sand on slope --> rubble
  var BRS_SL_to_RS_mask = ee.Image().byte().paint(ee.Feature(BRS_SL_to_RS, {zone: 1}), "zone").unmask(0, false);
  man_benthic = man_benthic.where({
    test: man_benthic.eq(11)
                     .and (BRS_SL_to_RS_mask.eq(0))
                     .and(geo_map.eq(21).or(geo_map.eq(22))),
    value: ee.Image(12)
  });  
  
  
 //*************************** Chris added from WIO************************
  // coral or algae in benthic + TRF in geo == seagrass
  man_benthic = man_benthic.where({
    test: man_benthic.eq(15)
                   .and(geo_map.eq(16)),
    value: ee.Image(14)
  });
  
  // rock in benthic + TRF in geo == sand
  man_benthic = man_benthic.where({
    test: man_benthic.eq(13)
                   .and(geo_map.eq(16)),
    value: ee.Image(11)
  });
 ///*
  // seagrass in benthic and slope in geo == coral
  man_benthic = man_benthic.where({
    test: man_benthic.eq(14)
                   .and((geo_map.eq(21)).or(geo_map.eq(22))),
    value: ee.Image(15)
  });
  //*************************** Chris added from WIO************************ 
  //*/
  
  /*
  ** Manual polygon guided rules **
   - same as per geomorphic clean section (add a geometry, paint the layer, create a rule)
          - OR -
  ** Region-specific clean-up rules **
  */
  
  /*// Seagrass in turbid water & TRF --> rubble
  var turbid_mask = ee.FeatureCollection(region_params.turbid_mask).filterBounds(region_extent).geometry();
  var turbid_mask_i = ee.Image().byte().paint(ee.Feature(turbid_mask,{zone: 1}), "zone");
  Map.addLayer(turbid_mask, {}, "turbid mask", false);
  
  man_benthic = man_benthic.where({
    test: turbid_mask_i.eq(1)
                       .and(man_benthic.eq(14))
                       .and(geo_map.neq(16)),
    value: ee.Image(12)
  });
  
  // Rubble on Outer reef (and dark) -> rock 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(12)
                     .and(geo_map.eq(14))
                     .and(dove_b1.lt(750)),
    value: ee.Image(13)
  });*/
  
 
  
  // Add the manual layer to the map
  var dove_image = ee.Image(region_params.pixels).select(['b1','b2','b3']);
  Map.addLayer(dove_image, {bands: ['b3','b2','b1'], min:0, max:4000, gamma:1.5}, sensor_params.sname + ' low tide', true);
  
  var benthic_clean1 = ee.Image(region_params.benthic_map_clean1);
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false);
  Map.addLayer(geo_clean2.updateMask(geo_clean2.gt(2)), map_palettes.geo, 'Geo clean stage 2', false);
  Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Geo clean stage 3 - MANUAL', true);
  Map.addLayer(benthic_clean1, map_palettes.benthic, 'Benthic clean stage 1', false);
  Map.addLayer(man_benthic.reproject({crs:'EPSG:4326', scale: 5}), map_palettes.benthic, 'Benthic clean stage 2 - MANUAL', true);
  
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_benthic,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: region_extent,
    scale: vars.image_data_scale,
    crs: vars.local_epsg,
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
}

// #################################################################################################
// END OF MANUAL SECTION
// #################################################################################################


// 2. Data loads & vis

if (!vars.manual_clean) {

  // load input data
  
  // define raw geo/benthic outputs
  // Run check to see if the region has been split into multiple areas
  
  // geo
  if (ee.List(region_params.geo_map).length().getInfo() > 1) {
    var geo_map_raw = ee.Image(region_params.geo_map[0]).unmask(0, false)
                 .add(ee.Image(region_params.geo_map[1]).unmask(0,false))
                 .selfMask();
  } else {
    var geo_map_raw = ee.Image(region_params.geo_map);
  }
  
  // benthic
  if (ee.List(region_params.benthic_map).length().getInfo() > 1) {
      var benthic_map = ee.Image(region_params.benthic_map[0]).unmask(0, false)
               .add(ee.Image(region_params.benthic_map[1]).unmask(0,false))
               .selfMask();
  } else {
      var benthic_map = ee.Image(region_params.benthic_map);
  }
  
  // set the geo map for further processing
  if (vars.geomorphic && vars.obia_2nd_pass) {
    // if it's 2nd pass, you want to make sure you're loading the latest geo clean map
    var geo_map = ee.Image(region_params.geo_map_clean1);
  } else if (vars.geomorphic) {
    var geo_map = geo_map_raw;
  }
  
  var depth = ee.Image(region_params.segments).select('depth');
  var image = ee.Image(region_params.pixels).select('b3','b2','b1');
  
  var display_pal = (vars.geomorphic) ? map_palettes.geo : map_palettes.benthic;
  Map.addLayer(depth, {min:0, max:2500}, 'Depth data', false);
  Map.addLayer(image, {bands: ['b3','b2','b1'], min:200, max:1200}, 'Dove low tide', false);
  
  // load for display purposes
  if (vars.geomorphic) {
    Map.addLayer(geo_map_raw, display_pal, 'Geomorphic map RAW', false);
    if (vars.cleanup_stage == 2) Map.addLayer(ee.Image(region_params.geo_map_clean1), display_pal, 'Geomorphic map - stage 1 clean', false);
  }
  if (!vars.geomorphic) {
    // Use the manually cleaned geomorphic map as input for the benthic clean
    var geo_map = ee.Image(region_params.geo_map_clean3);
    if (!vars.manual_clean) Map.addLayer(geo_map, map_palettes.geo, 'Final geo map (manual clean - stage 3)', false);
    Map.addLayer(benthic_map, display_pal, 'Benthic map RAW', false);
  }
  
    // 3. Object-based re-classificaiton and cleaning
    
    /* OUTPUT EXTENT
      - to the mapping extent just so it doesn't balloon out
      - to the 'reef boundary' extent for noise/deep removal
    */  
    var class_extent_mask = geo_map.gt(0);
    
    /*
    
    ########
    Initial small object clean
     - this was originally at the end, but we needed to massively reduce the number of objects to 
       iterate through in the OBIA cleaning, so this happens first now
     - future collabs with google might fix this, but need to change the parallel serialisation of vector procesing
     
     - includes a possible special case for:
          - geomorphic to clean up turbid areas over size threshold; fix shallow vs. deep lagoon
          - benthic to allow breaking waves (temporal class) to grow into surrounding class
    ########
    
    */
    
    // ##############################################################################################
    // START OF CLEAN 1
    // ##############################################################################################
    
    if (vars.geomorphic && !vars.obia_2nd_pass) {
      
      // deep water in depth data == deep (s2 + ls8 data should be good enough for this)
      clean_map = geo_map.where({
        test: depth.gt(vars.geo_depth_cutoff),
        value: ee.Image(2)
      });
      
      // shallow lagoon > 5m == deep lagoon
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                      .and(depth.gt(vars.shallowlag_depth_cutoff)),
        value: ee.Image(12)
      });
      
      // the "LAND MASK" CLEAN
      var distToLand = ee.Image(region_params.distToLand);
      // display distance to land mask for assessing cut-off distances
      Map.addLayer(distToLand.unmask(8000, false).lte(vars.dist_to_land_RC).selfMask(), {}, 'RC to TRF ' + vars.dist_to_land_RC + 'm', false);
      Map.addLayer(distToLand.unmask(8000, false).gte(vars.dist_to_land_ORF).selfMask(), {}, 'TRF to ORF ' + vars.dist_to_land_ORF + 'm', false);
      // only apply RC distance rules to non-terrestrial lagoons
      var ocean_lagoon_mask = ee.FeatureCollection(region_params.lagoons_mask)
                                    .filter(ee.Filter.eq("MappingReg", vars.lagoon_region))
                                    .filter(ee.Filter.neq("LagoonType", "ClosedTerrestrial"))
                                    .geometry().buffer(1000);
      // add in manual areas for not applying land distance rules 
      var skip_rc_dist = ee.FeatureCollection(ocean_lagoon_mask).merge(RC_landDist_not_applied).geometry().dissolve();
      var skip_rc_dist_i = ee.Image().byte().paint(ee.Feature(skip_rc_dist,{zone: 1}), "zone").unmask(0, false);
      Map.addLayer(skip_rc_dist_i, {min:0,max:1}, "Skip RC landDist rule", false);
      
      
      // reef crest close to land -> TRF (check if needed or not)
      clean_map = clean_map.where({
        test: clean_map.eq(15)
                       .and(distToLand.unmask(8000, false).lte(vars.dist_to_land_RC))
                       .and(skip_rc_dist_i.eq(0)),
        value: ee.Image(16)
      });
      
      // TRF outside of specified distance from land -> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(16)
                       .and(distToLand.unmask(8000, false).gt(vars.dist_to_land_ORF)),
        value: ee.Image(14)
      });
      
      // mask out land areas
      clean_map = clean_map.updateMask(distToLand.unmask(8000, false));
      
      
      // the "DISTANCE TO DEEP WATER" CLEAN
      // use a distance to deepwater to cut out RC/slope
      var dist_to_deep = clean_map.eq(2).or(clean_map.eq(22))
                                  .fastDistanceTransform(50).sqrt()
                                  .multiply(ee.Image.pixelArea().sqrt())
                                  .uint8()
                                  //.selfMask();
      Map.addLayer(dist_to_deep, {}, "distance to deepwater", false);
  
      // reef crest too far from deep water -> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(15)
                       .and(dist_to_deep.gte(250)),
        value: ee.Image(14)
      });
      
    }
    
    if (!vars.geomorphic && vars.cleanup_stage == 1) {
      // BENTHIC CLEAN 1 rules (pre-manual)
      
      // make a smooth map with masked area as a value, and without temporal class (basically breaking waves)
      var smooth_map = benthic_map
                        .focal_mode({
                          radius: vars.smooth_radius, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 1
                        });
    
      // replace small objects with smooth underneath
      var clean_map = benthic_map.where({
        test: benthic_map.connectedPixelCount(vars.small_object_benthic, false).lt(vars.small_object_benthic),
        value: smooth_map
      }).updateMask(class_extent_mask);
      
      // replace small missing 
      var clean_map = benthic_map.unmask(0, false).where({
        test: geo_map.gt(2),
        value: smooth_map
      }).selfMask();
      
      // Deep (or land or missing) in geo == masked from benthic
      clean_map = clean_map.where({
        test: geo_map.unmask(0).lte(2),
        value: ee.Image(0)
      });
        
      // cut benthic off to < 10 - 15 m
      clean_map = clean_map.where({
        test: depth.gt(vars.benthic_depth_cutoff),
        value: ee.Image(0)
      });
     
     
     
      // #####################
     /* // special case for SWP, remap separate coral (16) & algae (17) classes back to coral/algae (15)
      clean_map = clean_map.where({
        test: clean_map.eq(16), 
        value: ee.Image(15)
      });
      clean_map = clean_map.where({
        test: clean_map.eq(17), 
        value: ee.Image(15)
      });*/
    
    }
  
  
  // ##############################################################################################
  // START OF CLEAN 2
  // ##############################################################################################
  
  if (vars.geomorphic && vars.obia_2nd_pass) {
    var clean_map = geo_map;
  }
  
  if (vars.obia_clean) {
    
    if (vars.geomorphic && !vars.fast_clean) { 
      
      // FUNCTION that maps over feature colleciton and assigns neighbour percentages
      var set_neighbour_properties = function(f) {
        // make the 1px buffer
        var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5));
        // reduce the classes in the buffer zone
        var diff_classes = ee.Dictionary(
          clean_map.unmask(ee.Image(0)).reduceRegion({
            reducer: ee.Reducer.frequencyHistogram(),
            geometry: diff.geometry(),
            scale: vars.image_data_scale,
            maxPixels: 1e11
          }).get('classification')
        );
        // calculate the percentages
        var diff_sum = diff_classes.toArray().reduce(ee.Reducer.sum(), [0]).get([0]);
        var diff_percs = diff_classes.map(function(k,v){return(ee.Number(v).divide(diff_sum).multiply(100).toUint8())});
        
        /* NOW, we can try to do the class logic right here (see /users/mitchest/global_reefs/obia_dev),
           or we can return the neighbour % and do image logic via (painted) rasters */
        
        return(f.set(diff_percs));
      };
      
      // FUNCTION to reduce the map to vectors and map the neighbour properties function
      var reduce_neighbours = function() {
        // reduce map to vectors
        var map_fc = clean_map
              .updateMask(segment_id).updateMask(clean_map.eq(classn)) // only vectorise class/es of interest
              .reduceToVectors({
                scale: vars.image_data_scale, 
                eightConnected: false,
                bestEffort: true, 
                maxPixels: 1e13,
                tileScale: 1,
                geometry: region_extent
              });
        // map the function, calculate neighbour properties
        return(map_fc.map(set_neighbour_properties));
      };
      
      // first make a make size threshold, so we're not vecortising huge objects when we don't have to
      var segment_id = clean_map.connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels');
      //Map.addLayer(segment_id.reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))))
      Map.addLayer(clean_map.updateMask(segment_id).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
      
      // This is where we select the single or group of classes to vectorise for cleaning up
      //var classn = ee.Number(15) // one class
      var classn = clean_map.where({
        test: clean_map.neq(16) //TRF
                .and(clean_map.neq(15)) //RR
                .and(clean_map.neq(14)) //ORF
                .and(clean_map.neq(13)) //IRF
                //.and(clean_map.neq(12)) // deep L
                .and(clean_map.neq(11)), // shallow L 
        value: ee.Image(99) // 99 ensures it's ignored in logic
      });
      
      // Minimum size of object to reclass based on neighbourhood
      var max_size = ee.Number(1000).divide(vars.image_data_scale).pow(2); // the first number is the square dimension of the desired min size;
      // calculate neighbours
      var map_fc_neighbours = reduce_neighbours();
      
      // #########
      // REEF RIM
      // #########
      
      var focus_class = ee.Number(15); //RR
      
      // start the object-based neighbourhood rules
      // paint out to rasters (only paint the layers needed)
      var objsize = ee.Image(30000).paint(map_fc_neighbours, 'count').rename('count');
      //var nb24 = ee.Image().byte().paint(map_fc_neighbours, '24').unmask(0).rename('nb24') //OCL
      var nb22 = ee.Image().byte().paint(map_fc_neighbours, '22').unmask(0).rename('nb22'); //SL ex
      var nb21 = ee.Image().byte().paint(map_fc_neighbours, '21').unmask(0).rename('nb21'); //Sl sh
      var nb16 = ee.Image().byte().paint(map_fc_neighbours, '16').unmask(0).rename('nb16'); //TRF
      var nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15'); //RR
      var nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14'); //ORF
      var nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13'); //IRF
      //var nb3 = ee.Image().byte().paint(map_fc_neighbours, '3').unmask(0).rename('nb3') //Turbid
      
      // RR surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // RR surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // RR surrounded by IRF + ORF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.add(nb14).gt(75)),
        value: ee.Image(13)
      });
      
      // RR with decent border to TRF --> TRF (often dark, probably seagrass)
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(40)),
        value: ee.Image(16)
      });
      
      // RR surrounded by OCL --> OCL
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb24.gt(75)),
        value: ee.Image(24)
      })
      
      // small RR objects touching OCL + stuff --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(objsize.lte(max_size))
                .and(nb13.lte(75).and(nb14.lte(75))) // to ensure we're no re-writing previous rules
                .and(nb24.gt(1)),
        value: ee.Image(14)
      })
      
      // ####
      // ORF
      // ####
      
      focus_class = ee.Number(14); // ORF
      
      // ORF surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // ORF surrounded by TRF --> TRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(75)),
        value: ee.Image(16)
      });
      
      // ORF surrounded by RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb15.gt(85)),
        value: ee.Image(15)
      });
      
      // ORF touching slope and RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb21.gt(0).or(nb22.gt(0)))
                .and(nb15.gt(0)),
        value: ee.Image(15)
      });
      
      // ####
      // IRF
      // ####
      
      focus_class = ee.Number(13); // IRF
      
      // IRF surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // IRF surrounded by TRF --> TRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(75)),
        value: ee.Image(16)
      });
      
      // IRF surrounded by RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb15.gt(85)),
        value: ee.Image(15)
      });
      
      // ####
      // TRF
      // ####
      
      focus_class = ee.Number(16); // TRF
      
      // TRF surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // TRF surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // TRF surrounded by IRF + ORF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.add(nb14).gt(75)),
        value: ee.Image(13)
      });
      
      // ####
      // LAGOONS
      // ####
      
      var nb11 = ee.Image().byte().paint(map_fc_neighbours, '11').unmask(0).rename('nb11'); // shallow lag
      
      // SL sourrounded by DL --> DL
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                .and(nb12.gt(75)),
        value: ee.Image(12)
      })
      
      // DL sourrounded by SL --> SL
      clean_map = clean_map.where({
        test: clean_map.eq(12)
                .and(nb11.gt(75)),
        value: ee.Image(11)
      })
      
      // DL/SL surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(11).or(clean_map.eq(12))
                .and(objsize.lte(max_size))
                .and(nb13.gt(80)),
        value: ee.Image(13)
      })
      
      // SL surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                .and(objsize.lte(max_size))
                .and(nb13.gt(80)),
        value: ee.Image(13)
      });
      
    
    } else if (vars.geomorphic && vars.fast_clean) {
      print("Executing the fast version OBIA");
      
      /* fast version of the geo clean up
        - blanket version assigns the underlying most common in neighbourhood
        - mode OBIA version iterates through objects+buffers but take the mode instead of doing the class percs, to see if that speeds things up
      */
      
      
      // ## Blanket version
      
      // make a very smooth map to capture the broader neighbourhood  - *** Change to ee.kernal*** see reef mask in clean 3
      var smooth_map = clean_map
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                            kernelType: 'circle', units: 'pixels', iterations: 2
                          });
      
      // first make a make size threshold, so we're not vectorising huge objects when we don't have t
      // - the unmask(99) captures small no data values/ data gaps
      var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt().multiply(2)).select('labels').pow(2).log().int();
      Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
      
      // replace small objects with smooth underneath
      var clean_map = clean_map.unmask(0).where({
        test: segment_id.gt(0), 
        value: smooth_map
      }).selfMask();
      
      // get rid of patch reef
      geo_map = geo_map.where({
        test: geo_map.eq(25),
        value: smooth_map
      });
      
      // ## mode OBIA version
      
      /* A possible faster plan
            - vectorise one/few class/es at a time, thus only spending resources on what is actually needed to clean up
            - BUT, just assign the mode of the neighbours, so save resouces even further??
      
      // FUNCTION that maps over feature colleciton and assigns neighbour percentages
      var set_neighbour_mode = function(f) {
        // make the 1px buffer
        var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5))
        // reduce the classes in the buffer zone
        var diff_mode = ee.Number(ee.Dictionary(
          clean_map.unmask(ee.Image(0)).reduceRegion({
            reducer: ee.Reducer.mode(),
            geometry: diff.geometry(),
            scale: vars.image_data_scale,
            maxPixels: 1e11
          })).get('classification'))
        
        return(f.set('mode',diff_mode))
      }
      
      // FUNCTION to reduce the map to vectors and map the neighbour properties function
      var reduce_neighbours_mode = function() {
        // reduce map to vectors
        var map_fc = clean_map.unmask(0)
              .updateMask(classn.gt(0)) // only vectorise class/es of interest
              .reduceToVectors({
                scale: vars.image_data_scale, 
                eightConnected: false,
                bestEffort: true, 
                maxPixels: 1e13,
                tileScale: 1,
                geometry: region_extent
              })
        // map the function, calculate neighbour properties
        return(map_fc.map(set_neighbour_mode))
      }
      
      // first make a make size threshold, so we're not vecortising huge objects when we don't have to
      var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels')
      Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false)
      
      // This is where we select the single or group of classes to vectorise for cleaning up
      var classn = segment_id.where({
        test: clean_map.neq(16) //TRF
                .and(clean_map.neq(15)) //RR
                .and(clean_map.neq(14)) //ORF
                .and(clean_map.neq(13)) //IRF
                //.and(clean_map.neq(12)) // deep L
                .and(clean_map.neq(11)) // shallow L 
                .and(clean_map.unmask(0).neq(0)), // no data values (want to reclaim the small gaps 
        value: ee.Image(0) // 99 ensures it's ignored in logic
      })
      
      // calculate neighbours
      var map_fc_neighbours = reduce_neighbours_mode()
      
      //print(map_fc_neighbours.limit(10))
      
      var mode_map = ee.Image().byte().paint(map_fc_neighbours, 'mode').unmask(0).rename('mode') // paint out the mode values to an image
      //Map.addLayer(mode_map, display_pal, "mode map", false)
      
      // replace small objects with mode underneath
      var clean_map = clean_map.unmask(0).where({
        test: segment_id.gt(0), 
        value: mode_map
      }).selfMask()
      
      */
      
    }
  }
  
  // Final clip to the classified extent and move on
  if (vars.geomorphic) {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  } else {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  }
  
  
  // 4. Export data
  
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  
  if (vars.do_export) {
    print("For export, the image data scale must be set to:", vars.image_data_scale);
    
    Map.addLayer(region_extent, {}, "Export footprint", false);
    
    Export.image.toAsset({
      image: clean_map.set(vars),
      description: output_name,
      assetId: vars.asset_output + 'in_out/' + output_name,
      region: region_extent,
      scale: vars.image_data_scale,
      crs: vars.local_epsg,
      maxPixels: 1e13,
      pyramidingPolicy: {'.default': 'mode'}
    });
    
  } else {
    if (vars.reproject_display) {
      Map.addLayer(clean_map.reproject(ee.Projection('EPSG:4326').atScale(vars.image_data_scale)), display_pal, output_name, true);
    } else {
      Map.addLayer(clean_map, display_pal, output_name, false);
    }
  }

}

//Generate title
var title = ui.Label({
  value: 'Classes',
  style: {fontWeight: 'bold', fontSize: '12px'}
});

// generate the legend
var geo_legend = pkg_vis.discrete_legend(map_palettes.geo_atlas_names, map_palettes.geo_atlas_cols, 'Geomorphic Zone', false);
var benthic_legend = pkg_vis.discrete_legend(map_palettes.benthic_atlas_names, map_palettes.benthic_atlas_cols, 'Benthic Habitat', false);
//var mask_legend = pkg_vis.discrete_legend(["Low confidence depth","Water conditions"], ["#f7f7f7","#bababa"], 'Confidence Mask reason', false)
var legend = (vars.geomorphic) ? geo_legend : benthic_legend;
pkg_vis.add_lgds([title, legend]);//, mask_legend])
// generate the legend