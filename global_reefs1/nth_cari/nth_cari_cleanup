/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var waves = ee.Image("users/danleeharris/reefwave/nth_cari_d2"),
    RC_landDist_not_applied = 
    /* color: #0b4a8b */
    /* shown: false */
    ee.FeatureCollection([]),
    global_not_applied = 
    /* color: #ffc82d */
    /* shown: false */
    ee.FeatureCollection([]),
    turk_fill = 
    /* color: #00ffff */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-72.271548562005, 21.605727989707464],
          [-72.10675364013, 21.480547253552977],
          [-71.92135935302062, 21.2874560548263],
          [-71.80600290770812, 21.25930232893611],
          [-71.69691344894224, 21.37824749783003],
          [-71.612368874505, 21.52271200474756],
          [-71.61923532958312, 21.58912859678579],
          [-71.8266022729425, 21.66317271383979],
          [-72.05456858153624, 21.800946660025495],
          [-72.30588083739562, 21.664449003715486]]]),
    depth_terr_lagoon = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry({
      "type": "GeometryCollection",
      "geometries": [
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                -73.4743169809585,
                20.93567388689219
              ],
              [
                -73.45989742529444,
                20.919960853496494
              ],
              [
                -73.33561458838038,
                20.914509007955385
              ],
              [
                -73.23948421728663,
                20.955232706578144
              ],
              [
                -73.25527706396632,
                20.98344420373377
              ],
              [
                -73.36033382666163,
                20.991137324207216
              ],
              [
                -73.47019710791163,
                20.93952172546143
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                -80.13203779716387,
                21.673973704290844
              ],
              [
                -79.58272139091387,
                20.967805255983134
              ],
              [
                -78.87959639091387,
                20.598033371239737
              ],
              [
                -78.50606123466387,
                20.175809975522302
              ],
              [
                -77.72603193778887,
                19.68004441130818
              ],
              [
                -76.96797529716387,
                20.217053288523132
              ],
              [
                -76.88008467216387,
                20.546604755990035
              ],
              [
                -77.00853140592992,
                20.778978967666916
              ],
              [
                -78.08436244975296,
                21.100266155270248
              ],
              [
                -78.61592451591387,
                21.704599247887
              ],
              [
                -80.16499678153887,
                21.847432196446718
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                -75.32451186809799,
                20.720072283996043
              ],
              [
                -75.24760757122299,
                20.612138703541962
              ],
              [
                -75.00590835247299,
                20.581286467104047
              ],
              [
                -74.69279800091049,
                20.493837938649474
              ],
              [
                -74.61589370403549,
                20.601855318484077
              ],
              [
                -74.84660659466049,
                20.80225582401301
              ],
              [
                -75.27507339153549,
                20.776578269169182
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        }
      ],
      "coordinates": []
    }),
    aggressive_terr_lagoon = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-80.68135420341387, 21.551406532410155],
          [-80.42866865653887, 22.29540384085483],
          [-78.76973310966387, 22.14284592275284],
          [-77.19868818778887, 21.22405534280738],
          [-76.75923506278887, 21.510527753692536],
          [-78.00069014091387, 22.559442916751166],
          [-79.33003584403887, 22.90396281147005],
          [-80.73628584403887, 23.409020878530242],
          [-82.26338545341387, 23.348514664531024],
          [-84.36813129393693, 22.77386294967873],
          [-85.19210590331193, 22.200335224900552],
          [-85.01632465331193, 21.726549913405908],
          [-83.07723773924943, 21.363787026076093],
          [-80.84151996581194, 21.460953191275625]]]),
    orf_to_sl = 
    /* color: #00e2ff */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-79.94917462386407, 21.70577055662387],
          [-79.92788866161138, 21.68439738168837],
          [-79.91552907241693, 21.66046842629869],
          [-79.8142037590028, 21.643041574721973],
          [-79.78536470481144, 21.668568730873268],
          [-79.63086979993511, 21.606657552217758],
          [-79.59110521540248, 21.613609079611557],
          [-79.57737233590778, 21.599564356510125],
          [-79.41532434587945, 21.517822580499715],
          [-79.27387567305163, 21.460320339149717],
          [-78.88523512341493, 21.558699184646194],
          [-78.8467830576559, 21.516544963219626],
          [-78.76848439007937, 21.492286683869057],
          [-78.6737487543784, 21.44498254610786],
          [-78.56288458703045, 21.116655209347858],
          [-78.51344621313733, 20.987851869006107],
          [-78.38985027347626, 20.88909147195772],
          [-78.33148552364453, 20.875619102805146],
          [-78.32393243854263, 20.889732983676613],
          [-78.29783996214016, 20.884600817157644],
          [-78.29516432614093, 20.847405806528254],
          [-78.24641259311024, 20.81082499991957],
          [-78.19010777458568, 20.78322307698971],
          [-78.16607522945486, 20.752405665548743],
          [-78.09333997540234, 20.70378435710695],
          [-78.08750336801384, 20.718556557119992],
          [-78.07720382077434, 20.716308757495955],
          [-78.07686051561559, 20.684514099788128],
          [-78.06038105573624, 20.664598929486747],
          [-78.0404683757687, 20.660101594672472],
          [-78.00956939040555, 20.671665903884787],
          [-77.96944440805981, 20.66681627182518],
          [-77.93069427277258, 20.678023152289622],
          [-77.91401321711496, 20.683571583522397],
          [-77.89595811789607, 20.68462153494035],
          [-77.86416986472449, 20.695941267588434],
          [-77.84191383043236, 20.708275775535355],
          [-77.83421873279988, 20.70416513437522],
          [-77.8323454681461, 20.70098564391037],
          [-77.82600915811561, 20.698608947972165],
          [-77.81222593370943, 20.686498945751495],
          [-77.74313009422868, 20.66033331386876],
          [-77.48970727588026, 20.6372234530402],
          [-77.44901341483742, 20.66742304714603],
          [-77.38824540386173, 20.618267295167584],
          [-77.32644742969762, 20.600271681933304],
          [-77.32782071059955, 20.53727029105484],
          [-77.24405012068303, 20.498685201647376],
          [-77.14208331955119, 20.37386022316896],
          [-77.19146507811803, 20.33300219153983],
          [-77.23331643803157, 20.319966065162568],
          [-77.24254560831362, 20.295656737873962],
          [-77.27815177183385, 20.293399083822365],
          [-77.36352617461984, 20.26052960112861],
          [-77.57007061884383, 20.132222934868555],
          [-77.57076025825796, 20.07741646530946],
          [-77.6181498779653, 20.064836888518965],
          [-77.65864776638571, 19.985164226709458],
          [-77.79254335346354, 19.838614443479596],
          [-77.7183857786917, 19.808900573045324],
          [-77.54727812301866, 20.0321620664691],
          [-77.2136209095802, 20.240186614827262],
          [-77.08453181967474, 20.32777912316637],
          [-77.05981264725908, 20.44620766567833],
          [-77.139463391844, 20.61853813860773],
          [-77.33054630746648, 20.75050134572499],
          [-77.9869780893641, 20.732521346973183],
          [-78.09409457431303, 20.771047193389204],
          [-78.44565636465482, 21.068647591285224],
          [-78.56925229542024, 21.572689868362488],
          [-78.7120742581637, 21.656953393318453],
          [-78.84390991745416, 21.65184791584598],
          [-79.21469771502902, 21.577798173187677],
          [-79.38773201407962, 21.62631783340339],
          [-79.52231424238228, 21.6901346712371],
          [-79.87112940994399, 21.771779002299972],
          [-79.96948957852936, 21.758778529095654],
          [-80.01652469545347, 21.761967113304514],
          [-80.01755466397675, 21.747617957456455],
          [-80.01412144502193, 21.739964487482204],
          [-80.0027918187562, 21.736456509393093],
          [-79.9794459224652, 21.72752672507995]]]),
    trf_to_sl = 
    /* color: #00d682 */
    /* shown: false */
    ee.Geometry.MultiPolygon(
        [[[[-77.92802570354414, 21.92741080877163],
           [-77.9263090897746, 21.922951934953474],
           [-77.91995761882734, 21.918174415170824],
           [-77.91618106853437, 21.917218891978077],
           [-77.91103122722578, 21.91578559516739],
           [-77.90897129070234, 21.914989312928256],
           [-77.89232013713789, 21.993799636614636],
           [-77.89661167156171, 21.999052103664503],
           [-77.91137454997968, 22.007646630132584]]],
         [[[-78.50003739289274, 22.346701564341487],
           [-78.53333970002164, 22.302556622680275],
           [-78.53299637726774, 22.300333126838897],
           [-78.53076477936735, 22.296680163985382],
           [-78.52698822907438, 22.29223294986811],
           [-78.5225250332736, 22.289532786535542],
           [-78.51874848298063, 22.287626757482737],
           [-78.45351715973844, 22.366228860132583],
           [-78.4419300167941, 22.37789630322404],
           [-78.44476242951383, 22.37956300097117],
           [-78.44810982636442, 22.38043602515746],
           [-78.45214386872281, 22.37964236703263],
           [-78.45626374176969, 22.380674121712197],
           [-78.4609844296359, 22.382816972370307],
           [-78.46304436615934, 22.385832780347474]]]]),
    extended_buffer = 
    /* color: #f60eff */
    /* shown: false */
    ee.FeatureCollection(
        [ee.Feature(
            ee.Geometry.Polygon(
                [[[-84.91460605738, 21.92690648902256],
                  [-84.68663974878625, 22.178924104320327],
                  [-84.46142002222375, 22.41271800398666],
                  [-83.92308994409875, 22.734809201147524],
                  [-83.30785556909875, 22.93478381057112],
                  [-83.33532138941125, 22.995477280524995],
                  [-83.64843174097375, 22.912016739583407],
                  [-83.92583652613, 22.815846979063064],
                  [-84.59874912378625, 22.44064539590196],
                  [-84.9530582058175, 22.041515611331363],
                  [-84.97777744409875, 21.878488218046233],
                  [-84.93932529566125, 21.881036958112343]]]),
            {
              "system:index": "0"
            }),
        ee.Feature(
            ee.Geometry.Polygon(
                [[[-81.14732154554049, 23.14173029567797],
                  [-80.34806617444674, 23.101314933088364],
                  [-79.70811256116549, 22.81553606058887],
                  [-79.36890968030612, 22.61918953529204],
                  [-79.28238165641304, 22.56976562484047],
                  [-79.19038184827487, 22.58622644074961],
                  [-78.612094809778, 22.558600858300704],
                  [-77.91720955587175, 22.28947756022862],
                  [-77.71396248555925, 21.968901340766692],
                  [-77.70984261251238, 21.945975189949067],
                  [-77.70726769185808, 21.947885843761085],
                  [-77.70503609395769, 21.949478035658554],
                  [-77.7017383205636, 21.94744742596355],
                  [-77.70482822534876, 21.95142788454862],
                  [-77.67869297948708, 21.95402207979076],
                  [-77.6708847412249, 21.953428679937517],
                  [-77.66605841571288, 22.00766333028474],
                  [-77.63994022486048, 22.007142595173597],
                  [-77.60981179708607, 22.01644380430159],
                  [-77.60024101776936, 22.00279010384494],
                  [-77.5868096276063, 21.992955210452834],
                  [-77.58388340924982, 21.999069982189837],
                  [-77.60800025807318, 22.07934359690388],
                  [-77.6691226589425, 22.2424937375122],
                  [-78.0536441433175, 22.48633263768438],
                  [-78.3173160183175, 22.570053410681705],
                  [-78.9105777370675, 22.737342359813784],
                  [-79.23192783472375, 22.676533607482938],
                  [-79.80321689722375, 23.008118322566684],
                  [-80.4047183620675, 23.27582895095194],
                  [-80.49535556909875, 23.232930259033218],
                  [-80.84966465113, 23.308624514374845],
                  [-81.06664463159875, 23.308624514374845],
                  [-81.2946109401925, 23.159718315397964],
                  [-81.28911777613, 23.119308373316944]]]),
            {
              "system:index": "1"
            }),
        ee.Feature(
            ee.Geometry.Polygon(
                [[[-77.58354155605817, 21.98910797551323],
                  [-77.57736174648785, 21.981785788181732],
                  [-77.57358519619488, 21.971597768756403],
                  [-77.56740538662457, 21.96459308138705],
                  [-77.55985228603863, 21.953130120712107],
                  [-77.55470244473004, 21.94676140973998],
                  [-77.54955260342145, 21.93848165901688],
                  [-77.54474608486676, 21.9311568623973],
                  [-77.52105681484723, 21.905994907285066],
                  [-77.50114409512067, 21.884970119477646],
                  [-77.48878447598004, 21.872863532426468],
                  [-77.48054472988629, 21.86234908411631],
                  [-77.47299162930035, 21.84896593925246],
                  [-77.45960204189801, 21.83335068595003],
                  [-77.44586913174176, 21.827295332957277],
                  [-77.44106261318707, 21.84450461236939],
                  [-77.57907836025738, 21.997384775772403]]]),
            {
              "system:index": "2"
            }),
        ee.Feature(
            ee.Geometry.Polygon(
                [[[-83.97936482206664, 21.995979939289825],
                  [-84.00683064237914, 21.976877890777555],
                  [-84.00133747831664, 21.952680137800108],
                  [-83.77886433378539, 21.995979939289825],
                  [-83.55089802519164, 21.901722305199606],
                  [-83.32293171659789, 21.85584467079773],
                  [-83.26800007597289, 21.753841638165998],
                  [-83.26250691191039, 21.654318861192063],
                  [-83.18285603300414, 21.503628300563314],
                  [-83.00158161894164, 21.416718624422703],
                  [-82.66924519316039, 21.419275530682224],
                  [-82.51818318144164, 21.511294311750593],
                  [-82.33965534941039, 21.498517401916583],
                  [-82.22155232206664, 21.426945980877527],
                  [-81.88372273222289, 21.56494506478626],
                  [-81.80132527128539, 21.51895991869545],
                  [-81.24926228300414, 21.587932171179737],
                  [-81.20943684355102, 21.627512522067253],
                  [-81.30007405058227, 21.721950806516237],
                  [-81.43740315214477, 21.70919249289361],
                  [-81.60494465605102, 21.668358290393265],
                  [-81.86037678495727, 21.688776838463568],
                  [-82.62118000761352, 21.584101240071387],
                  [-83.05513996855102, 21.533012481135696],
                  [-83.24190754667602, 21.981972624994942],
                  [-83.81319660917602, 22.1168945703917],
                  [-83.96700520292602, 22.04817682888993]]]),
            {
              "system:index": "3"
            }),
        ee.Feature(
            ee.Geometry.Polygon(
                [[[-81.21760313570124, 22.148052921722652],
                  [-81.25571196138483, 22.14773493144366],
                  [-81.29519407808405, 22.10607199717741],
                  [-81.34222929536921, 22.09112122556835],
                  [-81.39819090425593, 22.1846170103414],
                  [-81.45003264009577, 22.19161079588133],
                  [-81.49054472505671, 22.202100821246486],
                  [-81.52453367769343, 22.207504467837314],
                  [-81.56847899019343, 22.197332725045648],
                  [-81.58427183687311, 22.15791026402904],
                  [-81.58272688448054, 22.155207513070554],
                  [-81.58118193208796, 22.153140668485285],
                  [-81.57877867281061, 22.152504710197974],
                  [-81.57912199556452, 22.14964286234217],
                  [-81.57946531831843, 22.14232898680133],
                  [-81.56779234468561, 22.109252808020138],
                  [-81.53586332857233, 22.091121225568365],
                  [-81.49329677640155, 22.080476222548892],
                  [-81.39441982327655, 22.005374688159858],
                  [-81.2517692190285, 21.97847483701634],
                  [-81.14379421292499, 21.947111771231036],
                  [-81.11014858304218, 21.947748653596886],
                  [-81.10877529202655, 21.971311295101874],
                  [-81.14036098538593, 22.025426878198253],
                  [-81.1499740224953, 22.104334883251063],
                  [-81.18018642483905, 22.179383798741462],
                  [-81.18945613919452, 22.1835166862019],
                  [-81.20765224515155, 22.182562953730056]]]),
            {
              "system:index": "4"
            }),
        ee.Feature(
            ee.Geometry.Polygon(
                [[[-79.92147818261955, 21.621431889431864],
                  [-79.68106241986158, 21.47093957443387],
                  [-79.60965128704908, 21.253519837629273],
                  [-79.5207994365721, 21.07935253156989],
                  [-79.2736070537596, 20.979370178999325],
                  [-78.73537962495905, 20.61486425668646],
                  [-78.46072142183405, 20.55315464689464],
                  [-78.31789915620905, 20.391048467619285],
                  [-78.0734533554278, 20.270000895281434],
                  [-77.97732298433405, 20.1385444874942],
                  [-77.81252806245905, 19.823632148195667],
                  [-77.72463743745905, 19.797791826204925],
                  [-77.71365110933405, 19.888214566303265],
                  [-77.92651121675593, 20.284814990665712],
                  [-78.15173094331843, 20.449606555927353],
                  [-78.26159422456843, 20.48048535539576],
                  [-78.37420408784968, 20.606509208657688],
                  [-78.68182127534968, 20.70673950455909],
                  [-78.92352049409968, 20.86337705139272],
                  [-79.40966551363093, 21.13005475007534],
                  [-79.50579588472468, 21.224815242489647],
                  [-79.51952879488093, 21.334865862843504],
                  [-79.65685789644343, 21.534281777259757],
                  [-79.99743406831843, 21.738526791605885],
                  [-80.04687254488093, 21.73597551357839]]]),
            {
              "system:index": "5"
            })]),
    baha_brs_rs = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.MultiPolygon(
        [[[[-77.0954411517762, 26.633498877120992],
           [-76.98283128849495, 26.55245026895579],
           [-77.02422937393385, 26.44422461816161],
           [-77.02557191693064, 26.356914869402026],
           [-77.19706468693245, 26.259708813009734],
           [-77.23801604202971, 25.95161368954037],
           [-77.2787325731338, 25.92229506225191],
           [-77.28525570545801, 25.915192901973974],
           [-77.22139767323145, 25.836113909599373],
           [-77.15410641346583, 25.830242656128956],
           [-77.14998654041895, 25.930323076027314],
           [-77.12938717518458, 26.204181516172135],
           [-76.9934313646377, 26.283012556408192],
           [-76.97008541737208, 26.339639310047914],
           [-76.96321896229395, 26.48415791727343],
           [-76.92888668690333, 26.544985960103606],
           [-76.94193295155176, 26.58613412170439],
           [-77.14106014881739, 26.71439676010226],
           [-77.18981197987208, 26.725436559091754],
           [-77.19736508045801, 26.694767807471322]]],
         [[[-76.65535259664574, 25.449457186199755],
           [-76.61964703023949, 25.387439565025282],
           [-76.39168072164574, 25.305527509829684],
           [-76.21864605367699, 25.166398515454834],
           [-76.16646099508324, 25.088068579207896],
           [-76.18706036031762, 24.95118182372429],
           [-76.16646099508324, 24.86523871080469],
           [-76.22413921773949, 24.77798895397083],
           [-76.15920298253782, 24.6337750345806],
           [-76.15954630529173, 24.60287557900315],
           [-76.13723032628782, 24.596007996588426],
           [-76.10495798742063, 24.6003783199113],
           [-76.13929015242492, 24.746516737163574],
           [-76.09809142195617, 24.833788639797124],
           [-76.10083800398742, 24.933452672872818],
           [-76.07062560164367, 25.067871333271775],
           [-76.08985167586242, 25.169831570068453],
           [-76.27112608992492, 25.286607996623065],
           [-76.32331114851867, 25.373496215728306],
           [-76.40296202742492, 25.373496215728306],
           [-76.51282530867492, 25.413195755144148],
           [-76.60507004044791, 25.49715320624432],
           [-76.60335342667838, 25.545485599484408],
           [-76.6538218715026, 25.589773182369704],
           [-76.76437179826041, 25.57645765926405],
           [-76.7303828456237, 25.552609882250476]]],
         [[[-75.6674701319284, 24.651725887607494],
           [-75.63176456552215, 24.574317915125775],
           [-75.5246478663034, 24.39934986549922],
           [-75.42165104013152, 24.32554056185549],
           [-75.30978752399353, 24.159258742449733],
           [-75.29948784137635, 24.147041346515344],
           [-75.29656959796814, 24.130906329053822],
           [-75.27027358790944, 24.126410647539032],
           [-75.28537978908132, 24.209103552562787],
           [-75.35679092189382, 24.31802588107904],
           [-75.4433082558782, 24.373077456801294],
           [-75.49412002345632, 24.435606986994497],
           [-75.56141128322194, 24.55682584150196],
           [-75.60020675441335, 24.585863499250728],
           [-75.6026100136907, 24.616142916169114],
           [-75.61874618312429, 24.662952322757867],
           [-75.68483581325124, 24.70568957774958],
           [-75.69290389796804, 24.687910163968912]]],
         [[[-74.85112840179166, 23.65513687774641],
           [-74.8454635763522, 23.626516454011774],
           [-74.80598145965298, 23.624786447666963],
           [-74.78359068256785, 23.64587058571684],
           [-74.78221739155222, 23.700581795039614],
           [-74.80419004780222, 23.72510007046126],
           [-74.8687347255366, 23.72132832807481],
           [-74.86976469379832, 23.706397443895554],
           [-74.85380018574168, 23.69539464634341],
           [-74.80933988911082, 23.69413712471011],
           [-74.80796659809519, 23.67480120516549],
           [-74.8138030849116, 23.65153142788309]]],
         [[[-74.53524766908639, 24.12769888161001],
           [-74.52151475893014, 24.117671962805712],
           [-74.48786912904733, 24.14775036130603],
           [-74.45216356264108, 24.10388366669135],
           [-74.4483870123481, 24.071287247693753],
           [-74.47310625062936, 24.00105144288157],
           [-74.48546586976998, 23.968742636202293],
           [-74.47928606019967, 23.94740810982051],
           [-74.49130235658639, 23.931404899142276],
           [-74.48306261049264, 23.92324563599586],
           [-74.4590300177192, 23.930149661447047],
           [-74.44941698060983, 23.976585324451353],
           [-74.40547166810983, 24.05435891518311],
           [-74.42401109682076, 24.13584517447758],
           [-74.47756944643014, 24.187843882180943]]],
         [[[-72.65323535772347, 22.330942898909324],
           [-72.69580737920785, 22.33665913439606],
           [-72.85648242803597, 22.414122746830202],
           [-72.90935413213754, 22.4185660718178],
           [-72.99175159307504, 22.447761527154427],
           [-73.0501164612391, 22.449030755428804],
           [-73.13663379522347, 22.485198875880737],
           [-73.14968005987191, 22.48012321811499],
           [-73.06728259893441, 22.437607282819545],
           [-72.9347600159266, 22.403013812588007],
           [-72.8688420471766, 22.395713172288012],
           [-72.75794879766488, 22.346503212895936],
           [-72.6765813049891, 22.30791680111906],
           [-72.65666858526254, 22.302199388286905]]],
         [[[-72.34441576852034, 21.86497334902698],
           [-72.3203831757469, 21.863061583094378],
           [-72.29772387398909, 21.85190910507585],
           [-72.24794207467268, 21.79453975951244],
           [-72.19129382027815, 21.7919894771372],
           [-72.0845204438133, 21.906707188280905],
           [-72.00857064087259, 21.956093180373177],
           [-71.92068001587259, 21.94845085226502],
           [-71.88497444946634, 21.91787743292279],
           [-71.83416268188822, 21.81974342544853],
           [-71.67760750610697, 21.838865728843132],
           [-71.59658333618509, 21.740677480065447],
           [-71.49633309204447, 21.7087837274829],
           [-71.47431565167132, 21.670095095621704],
           [-71.44822312237444, 21.65605583546019],
           [-71.36513901592913, 21.727514192731807],
           [-71.68648911358538, 21.88943985505085],
           [-71.8032188499135, 21.880519591066616],
           [-71.84304428936663, 22.006625686693603],
           [-72.03255844952288, 22.024449838411822],
           [-72.23031235577288, 21.874147632431622],
           [-72.34841538311663, 21.899633759243223]]],
         [[[-71.13625885867401, 21.447829627592693],
           [-71.1190927209787, 21.406921755894842],
           [-71.09918000125214, 21.348096628874856],
           [-71.06484772586151, 21.33274705767598],
           [-71.06690766238495, 21.38326666662325],
           [-71.08510376834198, 21.424500761419203],
           [-71.10089661502167, 21.469557269806117],
           [-71.08922364138886, 21.539830370778184],
           [-71.0857904138498, 21.553561597965402],
           [-71.09231354617401, 21.555796791025973],
           [-71.16715790652557, 21.5059757523924],
           [-71.14552857302948, 21.482656194388994]]],
         [[[-73.88468043094396, 22.705310238939376],
           [-73.89566675906896, 22.587441256359554],
           [-73.93137232547521, 22.4834299998432],
           [-74.12225977664708, 22.320279557838],
           [-74.1064669299674, 22.283433164708182],
           [-73.9915560092824, 22.28817415990153],
           [-73.9146517124074, 22.37074456643558],
           [-73.8047884311574, 22.51163617661715],
           [-73.83637412451678, 22.64097769093165],
           [-73.81440146826678, 22.695467589241574],
           [-73.8172244412238, 22.73463897212154],
           [-73.85121339386052, 22.754902952314055],
           [-73.85945313995427, 22.734322323594228]]],
         [[[-73.6318549786235, 22.621960075185584],
           [-73.5995826397563, 22.60674762671635],
           [-73.54962917906295, 22.61070936385321],
           [-73.46019360167037, 22.584718288405522],
           [-73.45023724180709, 22.599616212425204],
           [-73.50825878721724, 22.627347413834958],
           [-73.56937023741256, 22.623861512932752],
           [-73.62550350767623, 22.651270983892733]]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/

///////////////////////////////
// Global coral atlas project - Northern Caribbean & Bahamas
// Contact: mitchell.lyons@gmail.com
// Region coordinator: V1 & V2: Mitchell Lyons (mitchell.lyons@gmail.com);
// Description:
// - Developing a process to combine OBIA and supervised classification
// - This script loads the raw classification data (from *_classification script)
// - Then applied some cleanup and object-based relational rules
///////////////////////////////

// Table of contents
// 1. Setting constants
// 2. Data loads & vis
// 3. OBIA clean up rules
// 4. Export

// Load and libraries needed
var map_palettes = require('users/mitchest/global_reefs_modules:colour_pals');
var pkg_vis = require('users/mitchest/global_reefs_modules:pkg_vis');
var param_module = require('users/mitchest/global_reefs_modules:reef_params');

// ###########################################
// SENSOR GENERICSgeo_depth_cutoff
var sensor_params = param_module.dove;         //<------------ THIS IS WHERE YOU CHOOSE THE SENSOR
// REGION AND SENSOR SPECIFIC LOAD PATHS
var region_params = param_module.nth_cari;  //<------------ THIS IS WHERE YOU CHOOSE THE REGION
//  ^^ all the data paths are in this module ^^
// ###########################################

// 1. Setting constants

// These will get written to the asset metadata 

var vars = {
  
  // analysis type
  geomorphic: false, // map geomorphic zonation (when set to true) or benthic habitat (when set to false)

  // analysis parameters
  image_data_scale: sensor_params.pixel,
  small_object_geo: ee.Number(400).int(), // smallest object szie in pixels (geomorphic)
  small_object_benthic: ee.Number(130).int(), // smallest object szie in pixels (benthic)
  smooth_radius: ee.Number(3), // radius in pixels for initial smooth 
  dist_to_land_ORF: 1000, //distance to land in meters to convert terrestrial reef flat to ORF
  dist_to_land_RC: 200, //distance to land in meters to convert reef crest to TRF
  wave_height: 0.4, //cut off height for waves in metres, Hs95 threshold
  geo_depth_cutoff: 1400, //depth in centimetres
  shallowlag_depth_cutoff: 500, //depth in centimetres
  benthic_depth_cutoff: 1000, //depth in centimetres
  lagoon_region: "Northern Caribbean and Bahamas",
  
  //############
  // Clean-up stage selection
  cleanup_stage: 2, // set to 1, 2 or 3
  geo_refinement: false, // set to true to apply the refinement_mask (the other stage 3 masks will still run)
  
  // should the global extent + depth cleanup be applied?
  global_extent_clean: true,
  global_depth_thresh: 500, // this is the depth limit for ADDING to the global extent (i.e. 5 = everything <5m will be added to the global extent layer)
  global_land_dist: -1, // [-1 (don't apply) OR +ve distance in meters] WITHIN this distance, the global extent/depth mask will be applied
  global_not_applied: true, // true = EXCLUDE reefs within 'global_not_applied' geometry polygons - mutually exclusive to land distance rule
 
  /*
  - GEOMORPHIC 1: The first pass does a small object filter, just to generally clean noise and reduce the amount of cleaning needed
  -            2: The second pass runs the OBIA cleanup rules
  -            3: The third pass is the MANUAL cleanup stage, which includes AT LEAST the no_reef masking
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY

  - BENTHIC 1: This is the main benthic stge - it does noise removal, no data reclaim and OBIA rules - review those if needed
            2: The second mas is the MANUAL stage - it's optional, but shuold include ALL region specific stuff
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY
  */
  
  // DON'T TOUCH --->
  obia_2nd_pass: null,
  obia_clean: null, // run object-based relationship rules + small object clean up
  fast_clean: null, // run a faster (but less precise) version of the OBIA clean; only applies to geomorphic (`obia_clean: true` also)
  manual_clean: false, // apply manual touch ups
  // --------------<
  //############
  
  reproject_display: true,
  
  // export options
  do_export: true, // export the results?
  geomorph_output_name: region_params.sname + '_geo_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  benthic_output_name: region_params.sname + '_benthic_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  asset_output: region_params.asset, // asset path
  local_epsg: region_params.epsg

};


// Clean up stage auto-parameterisation (DON'T TOUCH) --->

if (vars.geomorphic) {
  var temp_outname = vars.geomorph_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.obia_2nd_pass = true;
    vars.obia_clean = true;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '2';
  } else if (vars.cleanup_stage == 3) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = false;
    vars.do_export = false;
    vars.geomorph_output_name = temp_outname + '3';
  }
}

if (!vars.geomorphic) {
  var temp_outname = vars.benthic_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = true,
    vars.obia_clean = true, 
    vars.fast_clean = false, 
    vars.manual_clean = false;
    vars.benthic_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false,
    vars.obia_clean = false, 
    vars.fast_clean = false,
    vars.do_export = false;
    vars.benthic_output_name = temp_outname + '2';
  }
}

//Region extent is created in map viewer and exported to GEE asset
var region_extent = ee.FeatureCollection(region_params.extent_mask).geometry();
Map.addLayer(region_extent, {}, "Manual reef outline", false);
// -----------------------------------------<

//################################################################################################
//START OF CLEAN 3 - Manual Cleanup
//Review everything in this section
//This is the section to add/remove manual cleanups
//You MUST review it for each region

//###############################################################################################

if (vars.manual_clean && vars.geomorphic) {
  
  print("Doing GEOMORPHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.segments).select('depth');
  Map.addLayer(depth, {min:0, max:1500}, "Depth", false);
  var distToLand = ee.Image(region_params.distToLand);
  
  // define the manually edited map - uses the output from the second pass of cleaning
  var man_geo = ee.Image(region_params.geo_map_clean2);
  
  
  //##### SPECIAL INCLUSION FOR NTH CARI & BAHAMAS
  var baha_lagoons_mask = ee.FeatureCollection(region_params.lagoons_mask)
                                    .filterBounds(region_extent)
                                    .filter(ee.Filter.eq("LagoonType", "BahamaLagoon"));
  
  // the "GLOBAL MASK" clean
  // currently uses GCRMN extent + bathymetry threhold < vars.global_depth_thresh
  if (vars.global_extent_clean) {
    var blanket_mask = ee.Image([param_module.global_extent_mask.gcrmn]).unmask(0, false)
              .eq(1) // extent according to global extent layer
              .add(depth.lt(vars.global_depth_thresh)) // combine with areas less than depth thrshold
              .eq(0) // get leftovers
              .selfMask().connectedPixelCount(100, false).gte(100).unmask(0, false);
    
    blanket_mask = blanket_mask.where({
      test: blanket_mask.eq(0).connectedPixelCount(100,false).lt(100),
      value: ee.Image(1)
    });
    
    Map.addLayer(blanket_mask.selfMask(), {min:0,max:1}, "Global clean mask", false);
    
    if (vars.global_land_dist > 0) {
      man_geo = man_geo.where({
        test: blanket_mask.eq(1)
                          .and(distToLand.lte(vars.global_land_dist)),
        value: ee.Image(0)
      });
    } else if (vars.global_not_applied) {
      var global_not_applied_mask = baha_lagoons_mask.merge(depth_terr_lagoon).merge(extended_buffer).geometry().dissolve();
      var global_not_applied_i = ee.Image().byte().paint(ee.Feature(global_not_applied_mask, {zone: 1}), 'zone').unmask(0, false);
      man_geo = man_geo.where({
        test: blanket_mask.eq(1)
                          .and(global_not_applied_i.eq(0)),
        value: ee.Image(0)
      });
    } else {
      man_geo = man_geo.where({
        test: blanket_mask.eq(1),
        value: ee.Image(0)
      });
    }
  }
  
  // the "MID MASK" CLEAN
  //  - import the mid mask from asset ****only use ee.FC if mid_mask created in map viewer****
  var mid_mask = ee.FeatureCollection(region_params.mid_mask).geometry();
  Map.addLayer(mid_mask, {color: 'red'}, "mid mask import", false, 0.4);
  var midmask = ee.Image().byte().paint(ee.Feature(mid_mask.dissolve(),{zone: 1}), "zone");
  
  man_geo = man_geo.where({
    test: midmask.eq(1),
    value: ee.Image(0)
  });
  
  // remove odd occurence of geo classification where there's dove data but no depth
  man_geo = man_geo.where({
    test: man_geo.gte(2).and(depth.unmask(0,false).eq(0)),
    value: ee.Image(0)
  });
  
  
  // the "LAGOONS MASK" CLEAN
  // - import the global lagoon mask from asset
  
  // LAGOON clean stage 1 - clean inside the lagoon extent
  var lagoons_mask = ee.FeatureCollection(region_params.lagoons_mask)
                                    .filterBounds(region_extent)
                                    .filter(ee.Filter.neq("LagoonType", "BahamaLagoon"))
                                    .geometry();
  var lagoons_mask_i = ee.Image().byte().paint(ee.Feature(lagoons_mask,{zone: 1}), "zone");
  Map.addLayer(lagoons_mask, {}, "lagoon mask", false);
  
  var ocean_lagoon_mask = ee.FeatureCollection(region_params.lagoons_mask)
                                    .filterBounds(region_extent)
                                    .filter(ee.Filter.neq("LagoonType", "ClosedTerrestrial"))
                                    .filter(ee.Filter.neq("LagoonType", "BahamaLagoon"))
                                    .geometry();
  var ocean_lagoon_mask_i = ee.Image().byte().paint(ee.Feature(ocean_lagoon_mask,{zone: 1}), "zone");
  Map.addLayer(ocean_lagoon_mask, {}, "ocean lagoon mask", false);
  
  // RC within Lagoon -> ORF
  man_geo = man_geo.where({
    test: lagoons_mask_i.eq(1)
                        .and(man_geo.eq(15)),
    value: ee.Image(14)
  });
  // Reef slope, sheltered slope (within lagoon mask) -> Back Reef Slope
  man_geo = man_geo.where({
    test: lagoons_mask_i.eq(1)
                        .and(man_geo.eq(21).or(man_geo.eq(22))),
    value: ee.Image(24)
  });
  /*// Plateau within lagoon mask -> Deep
  man_geo = man_geo.where({
    test: lagoons_mask_i.eq(1)
                        .and(man_geo.eq(23)),
    value: ee.Image(2)
  });*/
  // TRF within oceanic/closed lagoons -> ORF
  man_geo = man_geo.where({
    test: ocean_lagoon_mask_i.eq(1)
                             .and(man_geo.eq(16)),
    value: ee.Image(14)
  });
  

  // LAGOON clean stage 2 - buffer the lagoon mask, and clean inside buffer
  var lagoon_buffered = lagoons_mask.buffer(1000); // buffer 1000 m wide around reef mask
  var reef_band_mask = lagoon_buffered.difference(lagoons_mask);//substract buffered lagoon mask - lagoon mask resulting in band around reef of 1000 m
  reef_band_mask = reef_band_mask.difference(extended_buffer.geometry()); // don't use hte band within extended buffer zone
  var reef_band_mask_i = ee.Image().byte().paint(ee.Feature(reef_band_mask.dissolve(),{zone: 1}), "zone");
  
  // BRS, DL and SL should not be present on outside of reef on within reef_band_mask_i  -> Reef Slope
  man_geo = man_geo.where({
   test: reef_band_mask_i.eq(1)
                         .and(man_geo.eq(24).or(man_geo.eq(12)).or(man_geo.eq(11))),
    value: ee.Image(22)
  });    
  // IRF or TRF on within reef_band_mask_i  -> ORF as RC would get artefacts
  man_geo = man_geo.where({
    test: reef_band_mask_i.eq(1)
                          .and(man_geo.eq(13).or(man_geo.eq(16))),
    value: ee.Image(14)
  });   
  
  // Stage 2 modified for large reef areas extending beyong lagoon + 1km buffer
  var reef_band_ext = extended_buffer.geometry().difference(lagoons_mask);
  var reef_band_ext_i = ee.Image().byte().paint(ee.Feature(reef_band_ext.dissolve(),{zone: 1}), "zone");
  
  // Any slopes/plat -> BRS (legit reef slope is rare, and it's a toss up between sheltered or BRS)
  man_geo = man_geo.where({
   test: reef_band_ext_i.eq(1)
                        .and(man_geo.eq(21).or(man_geo.eq(22)).or(man_geo.eq(23))),
    value: ee.Image(24)
  }); 
  
  // RC -> ORF (vast majority of RC is misclassification)
  man_geo = man_geo.where({
   test: reef_band_ext_i.eq(1)
                        .and(man_geo.eq(15)),
    value: ee.Image(14)
  }); 
  
  
  // LAGOON clean stage 3 - ### Special case for Cari & baha for the big sand banks
  
  /*#####
  SOME RULES JUST FOR BAHAMA BANKS/LAGOONS
  #####*/
  var baha_lagoons_mask_i = ee.Image().byte().paint(ee.Feature(baha_lagoons_mask.geometry(),{zone: 1}), "zone");
  Map.addLayer(baha_lagoons_mask, {}, "Bahamas lagoon mask", false);
  
  // shallow classes within baha_lagoons_mask_i  -> shallow lagoon
  man_geo = man_geo.where({
    test: baha_lagoons_mask_i.eq(1)
                             .and(man_geo.gt(12).and(man_geo.lt(20))),
    value: ee.Image(11)
  });
  
  // deep classes within baha_lagoons_mask_i  -> deep lagoon
  man_geo = man_geo.where({
    test: baha_lagoons_mask_i.eq(1)
                             .and(man_geo.gt(16))
                             .or(man_geo.eq(2)),
    value: ee.Image(12)
  });
  
  
  // BRS on the exposed bahamas lagoons side --> RS
  var baha_slopes = baha_brs_rs.difference(baha_lagoons_mask);
  var baha_slopes_i = ee.Image().byte().paint(ee.Feature(baha_slopes.dissolve(),{zone: 1}), "zone");
  
  // Any slopes/plat -> BRS (legit reef slope is rare, and it's a toss up between sheltered or BRS)
  man_geo = man_geo.where({
   test: baha_slopes_i.eq(1)
                      .and(man_geo.eq(24)),
   value: ee.Image(22)
  });
  
  
  /*#####
  SOME RULES JUST FOR OPEN TERRESTRIAL LAGOONS (CUBA only atm)
  #####*/
  
  var terr_lagoon_mask = ee.FeatureCollection(region_params.lagoons_mask)
                                    .filterBounds(region_extent)
                                    .filter(ee.Filter.eq("LagoonType", "ClosedTerrestrial"))
                                    .geometry();
  var terr_lagoons_mask_i = ee.Image().byte().paint(ee.Feature(terr_lagoon_mask,{zone: 1}), "zone");
  var depth_lag_i = ee.Image().byte().paint(ee.Feature(depth_terr_lagoon,{zone: 1}), "zone");
  var aggro_lag_i = ee.Image().byte().paint(ee.Feature(aggressive_terr_lagoon,{zone: 1}), "zone");
  var all_lags_i = ee.ImageCollection([depth_lag_i, aggro_lag_i]).mosaic();
  
  // shallow classes -> shallow lagoon
  man_geo = man_geo.where({
    test: terr_lagoons_mask_i.eq(1)
                             .and(man_geo.gt(12).and(man_geo.lt(20)))
                             .and(depth.gt(200))
                             .and(depth_lag_i.eq(1)),
    value: ee.Image(11)
  });
  
  man_geo = man_geo.where({
    test: terr_lagoons_mask_i.eq(1)
                             .and(man_geo.gt(12).and(man_geo.lt(16)))
                             .and(aggro_lag_i.eq(1)),
    value: ee.Image(11)
  });
  
  // deep classes -> deep lagoon
  man_geo = man_geo.where({
    test: terr_lagoons_mask_i.eq(1)
                             .and(man_geo.gt(16))
                             .or(man_geo.eq(2))
                             .and(all_lags_i.eq(1)),
    value: ee.Image(12)
  });
  
  // missing deep -> deep lagoons
  man_geo = man_geo.unmask(0,false).where({
    test: terr_lagoons_mask_i.eq(1)
                             .and(all_lags_i.eq(1))
                             .and(man_geo.unmask(0,false).eq(0))
                             .and(ee.Image(region_params.geo_map_clean2).gte(2)),
    value: ee.Image(12)
  }).selfMask();
  
  
  
  // The 'TURBID WATER' clean
  var turbid_mask = ee.FeatureCollection(region_params.turbid_mask).filterBounds(region_extent).geometry();
  var turbid_mask_i = ee.Image().byte().paint(ee.Feature(turbid_mask,{zone: 1}), "zone");
  Map.addLayer(turbid_mask, {}, "turbid mask", false);
  
  // leave only TRF within turbid mask (after changing ORF to TRF)
  man_geo = man_geo.where({
    test: turbid_mask_i.eq(1)
                       .and(man_geo.eq(14)),
    value: ee.Image(16)
  });
  
  man_geo = man_geo.where({
    test: turbid_mask_i.eq(1)
                       .and(man_geo.neq(16)),
    value: ee.Image(2)
  });
  
  
  // The 'HARBOUR & SHIPPING' clean
  var harbour_mask = ee.FeatureCollection(region_params.harbour_mask).filterBounds(region_extent).geometry();
  var harbour_mask_i = ee.Image().byte().paint(ee.Feature(harbour_mask,{zone: 1}), "zone");
  Map.addLayer(harbour_mask, {}, "harbour mask", false);
  
  // remove mapping within harbour mask
  man_geo = man_geo.where({
    test: harbour_mask_i.eq(1)
                        .and(man_geo.gt(2)),
    value: ee.Image(2)
  });
  
  /*// BRS and DL should not be present on outside of a reef -> Reef Slope RULE CHRIS
   man_geo = man_geo.where({
    test: lagoons_mask_i.neq(1) //Requires a mask that reprsent all areas excepth the lagoon mask
                        .and(man_geo.eq(12)),
    value: ee.Image(22)
  }); */
  
  // the 'WAVE' clean (un-comment this sectio nbased on whether you have waves or not)
  //var waves = ee.Image(region_params.waves);
  Map.addLayer(waves.lt(vars.wave_height), {}, vars.wave_height + "m Hs95 threshold", false);
  
  man_geo = man_geo.where({
    test: waves.lte(vars.wave_height)
               .and(man_geo.eq(22)),
    value: ee.Image(21)
  });
  
  
  /*// the "DISTANCE TO DEEP WATER" CLEAN
  // use a distance to deepwater to cut out RC/slope
  var dist_to_deep = man_geo.eq(2).fastDistanceTransform(256).sqrt()
                                  .multiply(ee.Image.pixelArea().sqrt())
                                  .uint16()
                                  .selfMask();
  Map.addLayer(dist_to_deep, {}, "distance to deepwater", false);
  
  // reef crest too far from deep water -> ORF
  man_geo = man_geo.where({
    test: man_geo.eq(15)
                 .and(dist_to_deep.gte(300)),
    value: ee.Image(14)
  });
  // reef slope too far from deep wter -> BRS
  man_geo = man_geo.where({
    test: man_geo.eq(21).or(man_geo.eq(22))
                 .and(dist_to_deep.gte(1500)),
    value: ee.Image(24)
  });*/
  
  /*
  ##############
  
  The rest of the manual geometry paintings and rules should go here
      - make the geom, paint the layer, use it in a rule
      - consult previous regions *_cleanup script for ideas/hints/existing rules etc.
  e.g. 
  var notreefcrest = ee.Image().byte().paint(ee.Feature(not_reef_crest, {zone: 1}), "zone");
  var notdeepwater = ee.Image().byte().paint(ee.Feature(not_deep_water, {zone: 1}), "zone");
  
  
  // Reef crest -> Inner reef flat (inside the reef)
  man_geo = man_geo.where({
    test: notreefcrest.eq(1)
                     .and(man_geo.eq(15)),
    value: ee.Image(13)
  });
  
  // Deep water -> Deep lagoon (inside the reef)
  man_geo = man_geo.where({
    test: notdeepwater.eq(1)
                     .and(man_geo.eq(2)),
    value: ee.Image(12)
  });
  
  ##############
  */
  
  
  /*// TRF -> ORF within manual mask
  var trf_to_orf_i = ee.Image().byte().paint(ee.Feature(trf_to_orf,{zone: 1}), "zone");
  man_geo = man_geo.where({
    test: trf_to_orf_i.eq(1)
                      .and(man_geo.eq(16)),
    value: ee.Image(14)
  });*/
  
  // ORF -> SL within manual mask
  var orf_to_sl_i = ee.Image().byte().paint(ee.Feature(orf_to_sl,{zone: 1}), "zone");
  man_geo = man_geo.where({
    test: orf_to_sl_i.eq(1)
                     .and(man_geo.eq(14)),
    value: ee.Image(11)
  });
  
  // TRF -> SL within manual mask (inappropriate distance to land rule)
  var trf_to_sl_i = ee.Image().byte().paint(ee.Feature(trf_to_sl,{zone: 1}), "zone");
  man_geo = man_geo.where({
    test: trf_to_sl_i.eq(1)
                     .and(man_geo.eq(16)),
    value: ee.Image(11)
  });
  
  /*// attempt to gain back missing reef crest
  var reef_crest_smooth = man_geo.eq(15).selfMask().focalMode(10);
  Map.addLayer(reef_crest_smooth, {colour: 'red'}, "reef crest smooth", false);
  //var reef_crest_holes = man_geo.gt(2).unmask(0,false).connectedComponents(ee.Kernel.plus(1), 512);
  //Map.addLayer(reef_crest_holes, {}, "reef crest holes", false);
  
  
  man_geo = man_geo.unmask(0, false).where({
    test: reef_crest_smooth.eq(1)
                           //.and(reef_crest_holes.select('labels').gt(1))
                           .and(man_geo.unmask(0, false).eq(0)),
    value: ee.Image(15)
  }).selfMask();*/
  
  
  // fill Turks and Caicos hole
  var turk_i = ee.Image().byte().paint(ee.Feature(turk_fill,{zone: 1}), "zone");
  man_geo = man_geo.unmask(0,false).where({
    test: turk_i.eq(1)
                .and(man_geo.unmask(0,false).eq(0)),
    value: ee.Image(11)
  }).selfMask();
  
  
  
  // mask to deep and anything removed to this point + re-do land
  man_geo = man_geo.where({
    test: distToLand.eq(0),
    value: ee.Image(0)
  });
  
  man_geo = man_geo.updateMask(man_geo.gt(2)).selfMask();
  
  if (vars.geo_refinement) {
    // make the mask image layer
    var refine = ee.Image().byte().paint(ee.Feature(refinement_mask, {zone: 1}), "zone").clip(refinement_mask);
    // apply
    man_geo = man_geo.where({
      test: refine.eq(1),
      value: ee.Image(0)
    });
  }
  
  // Add data + the manual layer to the map
  var lowtide_image = ee.Image(region_params.pixels).select(['b1','b2','b3']);
  Map.addLayer(lowtide_image, {bands: ['b3','b2','b1'], min:0, max:4000, gamma:1.5}, sensor_params.sname + ' low tide', false);
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(geo_clean2, map_palettes.geo, 'Geo clean stage 2', false);
  Map.addLayer(man_geo.updateMask(man_geo), map_palettes.geo, 'Geo clean stage 3', false);

  // display distance to land mask for assessing cut-off distances
  Map.addLayer(distToLand, {}, 'Distance to land mask', false);
  
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_geo,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: region_extent,
    scale: vars.image_data_scale,
    crs: vars.local_epsg,
    maxPixels: 1e13,
    shardSize: 256, // SWP specific cuase of size?
    pyramidingPolicy: {'.default': 'mode'}
  });
  
} 

if (vars.manual_clean && !vars.geomorphic) {
  
  print("Doing BENTHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.segments).select('depth');
  var dove_b1 = ee.Image(region_params.pixels).select('b1');
  
  // define the final geomorphic map (the manually edited geo map - stage 3)
  var geo_map = ee.Image(region_params.geo_map_clean3);
  
  // define the clean benthic map to apply 2nd stage rules to
  var man_benthic = ee.Image(region_params.benthic_map_clean1);
  
  // Deep (or land or missing) in geo == masked from benthic
  man_benthic = man_benthic.where({
    test: geo_map.unmask(0).lte(2),
    value: ee.Image(0)
  });
  
  
  /*
  ** Generic benthic rules **
    - should be generally applicable, but still review
  */
  
  // BMA on inner RF, outer RF,reef crest, reef slope -> rubble 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(18)
                     .and(geo_map.eq(13).or(geo_map.eq(14)).or(geo_map.eq(15)).or(geo_map.eq(22))),
    value: ee.Image(12)
  });
  
  /*// Rubble on Outer reef flat and Reef crest -> rock 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(12)
                     .and(geo_map.eq(14).or(geo_map.eq(15))),
    value: ee.Image(13)
  });*/
  // Rubble on Reef crest -> rock 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(12)
                     .and(geo_map.eq(15)),
    value: ee.Image(13)
  });
  
  // Sand in benthic and reef crest in geo --> coral/aglae
  man_benthic = man_benthic.where({
    test: man_benthic.eq(11)
                     .and(geo_map.eq(15)),
    value: ee.Image(15)
  });
    
  // Seagrass on RC or ORF -> Coral/Algae
  /*// except for these two areas (use if there are exceptions, e.g. in Indonesia this can occur)
  var sg_orf = ee.Image().byte().paint(ee.Feature(sg_on_orf, {zone: 1}), "zone").unmask(geo_map.eq(42));*/
  
  man_benthic = man_benthic.where({
    test: man_benthic.eq(14)
                     .and(geo_map.eq(14).or(geo_map.eq(15))),
                     //.and(sg_orf.eq(0)),
    value: ee.Image(15)
  });  

  // Rubble on slope --> rock
  man_benthic = man_benthic.where({
    test: man_benthic.eq(12)
                     .and(geo_map.eq(21).or(geo_map.eq(22))),
    value: ee.Image(13)
  }); 
  
  // Sand on slope --> rubble
  man_benthic = man_benthic.where({
    test: man_benthic.eq(11)
                     .and(geo_map.eq(21).or(geo_map.eq(22))),
    value: ee.Image(12)
  });  
  
  
  /*
  ** Manual polygon guided rules **
   - same as per geomorphic clean section (add a geometry, paint the layer, create a rule)
          - OR -
  ** Region-specific clean-up rules **
  */
  
  /*// Seagrass in turbid water & TRF --> rubble
  var turbid_mask = ee.FeatureCollection(region_params.turbid_mask).filterBounds(region_extent).geometry();
  var turbid_mask_i = ee.Image().byte().paint(ee.Feature(turbid_mask,{zone: 1}), "zone");
  Map.addLayer(turbid_mask, {}, "turbid mask", false);
  
  man_benthic = man_benthic.where({
    test: turbid_mask_i.eq(1)
                       .and(man_benthic.eq(14))
                       .and(geo_map.neq(16)),
    value: ee.Image(12)
  });
  
  // Rubble on Outer reef (and dark) -> rock 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(12)
                     .and(geo_map.eq(14))
                     .and(dove_b1.lt(750)),
    value: ee.Image(13)
  });*/
  
  
  /*#####
  SOME RULES JUST FOR BAHAMA BANKS/LAGOONS
  #####*/
  var baha_lagoons_mask = ee.FeatureCollection(region_params.lagoons_mask)
                                    .filterBounds(region_extent)
                                    .filter(ee.Filter.eq("LagoonType", "BahamaLagoon"));
  var baha_lagoons_mask_i = ee.Image().byte().paint(ee.Feature(baha_lagoons_mask.geometry(),{zone: 1}), "zone");
  Map.addLayer(baha_lagoons_mask, {}, "Bahamas lagoon mask", false);
  
  // rubble/rock/coral/algae classes within lagoons && baha_lagoons_mask_i  -> sand
  man_benthic = man_benthic.where({
    test: baha_lagoons_mask_i.eq(1)
                             .and(man_benthic.lt(14).or(man_benthic.eq(15)))
                             .and(geo_map.eq(11).or(geo_map.eq(12))),
    value: ee.Image(11)
  });
  
  
  /*#####
  SOME RULES JUST FOR OPEN TERRESTRIAL LAGOONS (CUBA only atm)
  #####*/
  var terr_lagoon_mask = ee.FeatureCollection(region_params.lagoons_mask)
                                    .filterBounds(region_extent)
                                    .filter(ee.Filter.eq("LagoonType", "ClosedTerrestrial"))
                                    .geometry();
  var terr_lagoons_mask_i = ee.Image().byte().paint(ee.Feature(terr_lagoon_mask,{zone: 1}), "zone");
  var aggro_lag_i = ee.Image().byte().paint(ee.Feature(aggressive_terr_lagoon,{zone: 1}), "zone");
  
  //  rubble/rock/coral/algae classes within deep terrestrial lagoons  -> sand
  man_benthic = man_benthic.where({
    test: terr_lagoons_mask_i.eq(1)
                             .and(man_benthic.lt(14).or(man_benthic.eq(15)))
                             .and(geo_map.eq(12)),
    value: ee.Image(11)
  });
  
  //  rubble/rock/coral/algae classes within shallow lagoon + aggressive clean lagoons  -> sand
  man_benthic = man_benthic.where({
    test: aggro_lag_i.eq(1)
                     .and(terr_lagoons_mask_i.eq(1))
                     .and(man_benthic.lt(14).or(man_benthic.eq(15)))
                     .and(geo_map.eq(11)),
    value: ee.Image(11)
  });
  
  // rubble/rock/coral/algae classes within shallow lagoon for SPECIFIC areas -> sand
  var orf_to_sl_i = ee.Image().byte().paint(ee.Feature(orf_to_sl,{zone: 1}), "zone");
  man_benthic = man_benthic.where({
    test: orf_to_sl_i.eq(1)
                     .and(man_benthic.lt(14).or(man_benthic.eq(15)))
                     .and(geo_map.eq(11)),
    value: ee.Image(11)
  });
  
  
  
  // Add the manual layer to the map
  var dove_image = ee.Image(region_params.pixels).select(['b1','b2','b3']);
  Map.addLayer(dove_image, {bands: ['b3','b2','b1'], min:0, max:4000, gamma:1.5}, sensor_params.sname + ' low tide', true);
  
  var benthic_clean1 = ee.Image(region_params.benthic_map_clean1);
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false);
  Map.addLayer(geo_clean2.updateMask(geo_clean2.gt(2)), map_palettes.geo, 'Geo clean stage 2', false);
  Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Geo clean stage 3 - MANUAL', true);
  Map.addLayer(benthic_clean1, map_palettes.benthic, 'Benthic clean stage 1', false);
  //Map.addLayer(man_benthic.reproject({crs:'EPSG:4326', scale: 5}), map_palettes.benthic, 'Benthic clean stage 2 - MANUAL', true);
  Map.addLayer(man_benthic, map_palettes.benthic, 'Benthic clean stage 2 - MANUAL', true);
  
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_benthic,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: region_extent,
    scale: vars.image_data_scale,
    crs: vars.local_epsg,
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
}

// #################################################################################################
// END OF MANUAL SECTION
// #################################################################################################


// 2. Data loads & vis

if (!vars.manual_clean) {

  // load input data
  
  // define raw geo/benthic outputs
  // Run check to see if the region has been split into multiple areas
  
  // geo
  if (ee.List(region_params.geo_map).length().getInfo() > 1) {
    var geo_map_raw = ee.Image(region_params.geo_map[0]).unmask(0, false)
                 .add(ee.Image(region_params.geo_map[1]).unmask(0,false))
                 .selfMask();
  } else {
    var geo_map_raw = ee.Image(region_params.geo_map);
  }
  
  // benthic
  if (ee.List(region_params.benthic_map).length().getInfo() > 1) {
      var benthic_map = ee.Image(region_params.benthic_map[0]).unmask(0, false)
               .add(ee.Image(region_params.benthic_map[1]).unmask(0,false))
               .selfMask();
  } else {
      var benthic_map = ee.Image(region_params.benthic_map);
  }
  
  // set the geo map for further processing
  if (vars.geomorphic && vars.obia_2nd_pass) {
    // if it's 2nd pass, you want to make sure you're loading the latest geo clean map
    var geo_map = ee.Image(region_params.geo_map_clean1);
  } else if (vars.geomorphic) {
    var geo_map = geo_map_raw;
  }
  
  var depth = ee.Image(region_params.segments).select('depth');
  var image = ee.Image(region_params.pixels).select('b3','b2','b1');
  
  var display_pal = (vars.geomorphic) ? map_palettes.geo : map_palettes.benthic;
  Map.addLayer(depth, {min:0, max:2500}, 'Depth data', false);
  Map.addLayer(image, {bands: ['b3','b2','b1'], min:200, max:1200}, 'Dove low tide', false);
  
  // load for display purposes
  if (vars.geomorphic) {
    Map.addLayer(geo_map_raw, display_pal, 'Geomorphic map RAW', false);
    if (vars.cleanup_stage == 2) Map.addLayer(ee.Image(region_params.geo_map_clean1), display_pal, 'Geomorphic map - stage 1 clean', false);
  }
  if (!vars.geomorphic) {
    // Use the manually cleaned geomorphic map as input for the benthic clean
    var geo_map = ee.Image(region_params.geo_map_clean3);
    if (!vars.manual_clean) Map.addLayer(geo_map, map_palettes.geo, 'Final geo map (manual clean - stage 3)', false);
    Map.addLayer(benthic_map, display_pal, 'Benthic map RAW', false);
  }
  
    // 3. Object-based re-classificaiton and cleaning
    
    /* OUTPUT EXTENT
      - to the mapping extent just so it doesn't balloon out
      - to the 'reef boundary' extent for noise/deep removal
    */  
    var class_extent_mask = geo_map.gt(0);
    
    /*
    
    ########
    Initial small object clean
     - this was originally at the end, but we needed to massively reduce the number of objects to 
       iterate through in the OBIA cleaning, so this happens first now
     - future collabs with google might fix this, but need to change the parallel serialisation of vector procesing
     
     - includes a possible special case for:
          - geomorphic to clean up turbid areas over size threshold; fix shallow vs. deep lagoon
          - benthic to allow breaking waves (temporal class) to grow into surrounding class
    ########
    
    */
    
    // ##############################################################################################
    // START OF CLEAN 1
    // ##############################################################################################
    
    if (vars.geomorphic && !vars.obia_2nd_pass) {
      
      // deep water in depth data == deep (s2 + ls8 data should be good enough for this)
      clean_map = geo_map.where({
        test: depth.gt(vars.geo_depth_cutoff),
        value: ee.Image(2)
      });
      
      // shallow lagoon > 5m == deep lagoon
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                      .and(depth.gt(vars.shallowlag_depth_cutoff)),
        value: ee.Image(12)
      });
      
      // the "LAND MASK" CLEAN
      var distToLand = ee.Image(region_params.distToLand);
      // display distance to land mask for assessing cut-off distances
      Map.addLayer(distToLand.unmask(8000, false).lte(vars.dist_to_land_RC).selfMask(), {}, 'RC to TRF ' + vars.dist_to_land_RC + 'm', false);
      Map.addLayer(distToLand.unmask(8000, false).gte(vars.dist_to_land_ORF).selfMask(), {}, 'TRF to ORF ' + vars.dist_to_land_ORF + 'm', false);
      // only apply RC distance rules to non-terrestrial lagoons
      var ocean_lagoon_mask = ee.FeatureCollection(region_params.lagoons_mask)
                                    .filter(ee.Filter.eq("MappingReg", vars.lagoon_region))
                                    .filter(ee.Filter.neq("LagoonType", "ClosedTerrestrial"))
                                    .filter(ee.Filter.neq("LagoonType", "BahamaLagoon"))
                                    .geometry().buffer(1000);
      // add in manual areas for not applying land distance rules 
      var skip_rc_dist = ee.FeatureCollection(ocean_lagoon_mask).merge(RC_landDist_not_applied).geometry().dissolve();
      var skip_rc_dist_i = ee.Image().byte().paint(ee.Feature(skip_rc_dist,{zone: 1}), "zone").unmask(0, false);
      Map.addLayer(skip_rc_dist_i, {min:0,max:1}, "Skip RC landDist rule", false);
      
      
      // reef crest close to land -> TRF (check if needed or not)
      clean_map = clean_map.where({
        test: clean_map.eq(15)
                       .and(distToLand.unmask(8000, false).lte(vars.dist_to_land_RC))
                       .and(skip_rc_dist_i.eq(0)),
        value: ee.Image(16)
      });
      
      // TRF outside of specified distance from land -> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(16)
                       .and(distToLand.unmask(8000, false).gt(vars.dist_to_land_ORF)),
        value: ee.Image(14)
      });
      
      // mask out land areas
      clean_map = clean_map.updateMask(distToLand.unmask(8000, false));
      
      
      // the "DISTANCE TO DEEP WATER" CLEAN
      // use a distance to deepwater to cut out RC/slope
      var dist_to_deep = clean_map.eq(2).or(clean_map.eq(22))
                                  .fastDistanceTransform(50).sqrt()
                                  .multiply(ee.Image.pixelArea().sqrt())
                                  .uint8()
                                  //.selfMask();
      Map.addLayer(dist_to_deep, {}, "distance to deepwater", false);
  
      // reef crest too far from deep water -> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(15)
                       .and(dist_to_deep.gte(250)),
        value: ee.Image(14)
      });
      
    }
    
    if (!vars.geomorphic && vars.cleanup_stage == 1) {
      // BENTHIC CLEAN 1 rules (pre-manual)
      
      // make a smooth map with masked area as a value, and without temporal class (basically breaking waves)
      var smooth_map = benthic_map
                        .focal_mode({
                          radius: vars.smooth_radius, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 1
                        });
    
      // replace small objects with smooth underneath
      var clean_map = benthic_map.where({
        test: benthic_map.connectedPixelCount(vars.small_object_benthic, false).lt(vars.small_object_benthic),
        value: smooth_map
      }).updateMask(class_extent_mask);
      
      // replace small missing 
      var clean_map = benthic_map.unmask(0, false).where({
        test: geo_map.gt(2),
        value: smooth_map
      }).selfMask();
      
      // Deep (or land or missing) in geo == masked from benthic
      clean_map = clean_map.where({
        test: geo_map.unmask(0).lte(2),
        value: ee.Image(0)
      });
        
      /* NOT USED JUST FOR NCB CAUSE OF ALL THE DEEP LAGOONS
      // cut benthic off to < 10 - 15 m
      clean_map = clean_map.where({
        test: depth.gt(vars.benthic_depth_cutoff),
        value: ee.Image(0)
      });*/
     
     
     
      // #####################
      // special case for SWP, remap separate coral (16) & algae (17) classes back to coral/algae (15)
      clean_map = clean_map.where({
        test: clean_map.eq(16), 
        value: ee.Image(15)
      });
      clean_map = clean_map.where({
        test: clean_map.eq(17), 
        value: ee.Image(15)
      });
    
    }
  
  
  // ##############################################################################################
  // START OF CLEAN 2
  // ##############################################################################################
  
  if (vars.geomorphic && vars.obia_2nd_pass) {
    var clean_map = geo_map;
  }
  
  if (vars.obia_clean) {
    
    if (vars.geomorphic && !vars.fast_clean) { 
      
      // FUNCTION that maps over feature colleciton and assigns neighbour percentages
      var set_neighbour_properties = function(f) {
        // make the 1px buffer
        var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5));
        // reduce the classes in the buffer zone
        var diff_classes = ee.Dictionary(
          clean_map.unmask(ee.Image(0)).reduceRegion({
            reducer: ee.Reducer.frequencyHistogram(),
            geometry: diff.geometry(),
            scale: vars.image_data_scale,
            maxPixels: 1e11
          }).get('classification')
        );
        // calculate the percentages
        var diff_sum = diff_classes.toArray().reduce(ee.Reducer.sum(), [0]).get([0]);
        var diff_percs = diff_classes.map(function(k,v){return(ee.Number(v).divide(diff_sum).multiply(100).toUint8())});
        
        /* NOW, we can try to do the class logic right here (see /users/mitchest/global_reefs/obia_dev),
           or we can return the neighbour % and do image logic via (painted) rasters */
        
        return(f.set(diff_percs));
      };
      
      // FUNCTION to reduce the map to vectors and map the neighbour properties function
      var reduce_neighbours = function() {
        // reduce map to vectors
        var map_fc = clean_map
              .updateMask(segment_id).updateMask(clean_map.eq(classn)) // only vectorise class/es of interest
              .reduceToVectors({
                scale: vars.image_data_scale, 
                eightConnected: false,
                bestEffort: true, 
                maxPixels: 1e13,
                tileScale: 1,
                geometry: region_extent
              });
        // map the function, calculate neighbour properties
        return(map_fc.map(set_neighbour_properties));
      };
      
      // first make a make size threshold, so we're not vecortising huge objects when we don't have to
      var segment_id = clean_map.connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels');
      //Map.addLayer(segment_id.reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))))
      Map.addLayer(clean_map.updateMask(segment_id).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
      
      // This is where we select the single or group of classes to vectorise for cleaning up
      //var classn = ee.Number(15) // one class
      var classn = clean_map.where({
        test: clean_map.neq(16) //TRF
                .and(clean_map.neq(15)) //RR
                .and(clean_map.neq(14)) //ORF
                .and(clean_map.neq(13)) //IRF
                //.and(clean_map.neq(12)) // deep L
                .and(clean_map.neq(11)), // shallow L 
        value: ee.Image(99) // 99 ensures it's ignored in logic
      });
      
      // Minimum size of object to reclass based on neighbourhood
      var max_size = ee.Number(1000).divide(vars.image_data_scale).pow(2); // the first number is the square dimension of the desired min size;
      // calculate neighbours
      var map_fc_neighbours = reduce_neighbours();
      
      // #########
      // REEF RIM
      // #########
      
      var focus_class = ee.Number(15); //RR
      
      // start the object-based neighbourhood rules
      // paint out to rasters (only paint the layers needed)
      var objsize = ee.Image(30000).paint(map_fc_neighbours, 'count').rename('count');
      //var nb24 = ee.Image().byte().paint(map_fc_neighbours, '24').unmask(0).rename('nb24') //OCL
      var nb22 = ee.Image().byte().paint(map_fc_neighbours, '22').unmask(0).rename('nb22'); //SL ex
      var nb21 = ee.Image().byte().paint(map_fc_neighbours, '21').unmask(0).rename('nb21'); //Sl sh
      var nb16 = ee.Image().byte().paint(map_fc_neighbours, '16').unmask(0).rename('nb16'); //TRF
      var nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15'); //RR
      var nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14'); //ORF
      var nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13'); //IRF
      //var nb3 = ee.Image().byte().paint(map_fc_neighbours, '3').unmask(0).rename('nb3') //Turbid
      
      // RR surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // RR surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // RR surrounded by IRF + ORF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.add(nb14).gt(75)),
        value: ee.Image(13)
      });
      
      // RR with decent border to TRF --> TRF (often dark, probably seagrass)
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(40)),
        value: ee.Image(16)
      });
      
      // RR surrounded by OCL --> OCL
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb24.gt(75)),
        value: ee.Image(24)
      })
      
      // small RR objects touching OCL + stuff --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(objsize.lte(max_size))
                .and(nb13.lte(75).and(nb14.lte(75))) // to ensure we're no re-writing previous rules
                .and(nb24.gt(1)),
        value: ee.Image(14)
      })
      
      // ####
      // ORF
      // ####
      
      focus_class = ee.Number(14); // ORF
      
      // ORF surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // ORF surrounded by TRF --> TRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(75)),
        value: ee.Image(16)
      });
      
      // ORF surrounded by RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb15.gt(85)),
        value: ee.Image(15)
      });
      
      // ORF touching slope and RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb21.gt(0).or(nb22.gt(0)))
                .and(nb15.gt(0)),
        value: ee.Image(15)
      });
      
      // ####
      // IRF
      // ####
      
      focus_class = ee.Number(13); // IRF
      
      // IRF surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // IRF surrounded by TRF --> TRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(75)),
        value: ee.Image(16)
      });
      
      // IRF surrounded by RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb15.gt(85)),
        value: ee.Image(15)
      });
      
      // ####
      // TRF
      // ####
      
      focus_class = ee.Number(16); // TRF
      
      // TRF surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // TRF surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // TRF surrounded by IRF + ORF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.add(nb14).gt(75)),
        value: ee.Image(13)
      });
      
      // ####
      // LAGOONS
      // ####
      
      var nb11 = ee.Image().byte().paint(map_fc_neighbours, '11').unmask(0).rename('nb11'); // shallow lag
      
      // SL sourrounded by DL --> DL
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                .and(nb12.gt(75)),
        value: ee.Image(12)
      })
      
      // DL sourrounded by SL --> SL
      clean_map = clean_map.where({
        test: clean_map.eq(12)
                .and(nb11.gt(75)),
        value: ee.Image(11)
      })
      
      // DL/SL surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(11).or(clean_map.eq(12))
                .and(objsize.lte(max_size))
                .and(nb13.gt(80)),
        value: ee.Image(13)
      })
      
      // SL surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                .and(objsize.lte(max_size))
                .and(nb13.gt(80)),
        value: ee.Image(13)
      });
      
    
    } else if (vars.geomorphic && vars.fast_clean) {
      print("Executing the fast version OBIA");
      
      /* fast version of the geo clean up
        - blanket version assigns the underlying most common in neighbourhood
        - mode OBIA version iterates through objects+buffers but take the mode instead of doing the class percs, to see if that speeds things up
      */
      
      
      // ## Blanket version
      
      // make a very smooth map to capture the broader neighbourhood  - *** Change to ee.kernal*** see reef mask in clean 3
      var smooth_map = clean_map
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                            kernelType: 'circle', units: 'pixels', iterations: 2
                          });
      
      // first make a make size threshold, so we're not vectorising huge objects when we don't have t
      // - the unmask(99) captures small no data values/ data gaps
      var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt().multiply(2)).select('labels').pow(2).log().int();
      Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
      
      // replace small objects with smooth underneath
      var clean_map = clean_map.unmask(0).where({
        test: segment_id.gt(0), 
        value: smooth_map
      }).selfMask();
      
      // get rid of patch reef
      geo_map = geo_map.where({
        test: geo_map.eq(25),
        value: smooth_map
      });
      
      // ## mode OBIA version
      
      /* A possible faster plan
            - vectorise one/few class/es at a time, thus only spending resources on what is actually needed to clean up
            - BUT, just assign the mode of the neighbours, so save resouces even further??
      
      // FUNCTION that maps over feature colleciton and assigns neighbour percentages
      var set_neighbour_mode = function(f) {
        // make the 1px buffer
        var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5))
        // reduce the classes in the buffer zone
        var diff_mode = ee.Number(ee.Dictionary(
          clean_map.unmask(ee.Image(0)).reduceRegion({
            reducer: ee.Reducer.mode(),
            geometry: diff.geometry(),
            scale: vars.image_data_scale,
            maxPixels: 1e11
          })).get('classification'))
        
        return(f.set('mode',diff_mode))
      }
      
      // FUNCTION to reduce the map to vectors and map the neighbour properties function
      var reduce_neighbours_mode = function() {
        // reduce map to vectors
        var map_fc = clean_map.unmask(0)
              .updateMask(classn.gt(0)) // only vectorise class/es of interest
              .reduceToVectors({
                scale: vars.image_data_scale, 
                eightConnected: false,
                bestEffort: true, 
                maxPixels: 1e13,
                tileScale: 1,
                geometry: region_extent
              })
        // map the function, calculate neighbour properties
        return(map_fc.map(set_neighbour_mode))
      }
      
      // first make a make size threshold, so we're not vecortising huge objects when we don't have to
      var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels')
      Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false)
      
      // This is where we select the single or group of classes to vectorise for cleaning up
      var classn = segment_id.where({
        test: clean_map.neq(16) //TRF
                .and(clean_map.neq(15)) //RR
                .and(clean_map.neq(14)) //ORF
                .and(clean_map.neq(13)) //IRF
                //.and(clean_map.neq(12)) // deep L
                .and(clean_map.neq(11)) // shallow L 
                .and(clean_map.unmask(0).neq(0)), // no data values (want to reclaim the small gaps 
        value: ee.Image(0) // 99 ensures it's ignored in logic
      })
      
      // calculate neighbours
      var map_fc_neighbours = reduce_neighbours_mode()
      
      //print(map_fc_neighbours.limit(10))
      
      var mode_map = ee.Image().byte().paint(map_fc_neighbours, 'mode').unmask(0).rename('mode') // paint out the mode values to an image
      //Map.addLayer(mode_map, display_pal, "mode map", false)
      
      // replace small objects with mode underneath
      var clean_map = clean_map.unmask(0).where({
        test: segment_id.gt(0), 
        value: mode_map
      }).selfMask()
      
      */
      
    }
  }
  
  // Final clip to the classified extent and move on
  if (vars.geomorphic) {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  } else {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  }
  
  
  // 4. Export data
  
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  
  if (vars.do_export) {
    print("For export, the image data scale must be set to:", vars.image_data_scale);
    
    Map.addLayer(region_extent, {}, "Export footprint", false);
    
    Export.image.toAsset({
      image: clean_map.set(vars),
      description: output_name,
      assetId: vars.asset_output + 'in_out/' + output_name,
      region: region_extent,
      scale: vars.image_data_scale,
      crs: vars.local_epsg,
      maxPixels: 1e13,
      pyramidingPolicy: {'.default': 'mode'}
    });
    
  } else {
    if (vars.reproject_display) {
      Map.addLayer(clean_map.reproject(ee.Projection('EPSG:4326').atScale(vars.image_data_scale)), display_pal, output_name, true);
    } else {
      Map.addLayer(clean_map, display_pal, output_name, false);
    }
  }

}

//Generate title
var title = ui.Label({
  value: 'Classes',
  style: {fontWeight: 'bold', fontSize: '12px'}
});

// generate the legend
var geo_legend = pkg_vis.discrete_legend(map_palettes.geo_atlas_names, map_palettes.geo_atlas_cols, 'Geomorphic Zone', false);
var benthic_legend = pkg_vis.discrete_legend(map_palettes.benthic_atlas_names, map_palettes.benthic_atlas_cols, 'Benthic Habitat', false);
//var mask_legend = pkg_vis.discrete_legend(["Low confidence depth","Water conditions"], ["#f7f7f7","#bababa"], 'Confidence Mask reason', false)
var legend = (vars.geomorphic) ? geo_legend : benthic_legend;
pkg_vis.add_lgds([title, legend]);//, mask_legend])
// generate the legend