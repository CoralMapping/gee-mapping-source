/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var land_dist = ee.Image("projects/coral_atlas/global_datasets/mod44w6_global_distToLand"),
    imageVisParam = {"opacity":1,"bands":["depth"],"min":1500,"max":2500,"gamma":1},
    reef_boundary = 
    /* color: #051ad6 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[133.65904403361668, 1.5423670875241082],
          [133.70298934611668, -3.3334940665077855],
          [140.07505965861668, -9.227839178840291],
          [151.80845809611668, -13.662997256508245],
          [159.85045028361668, -14.430353736128849],
          [164.99205184611668, -13.0216133807959],
          [165.47545028361668, -9.791275221974912],
          [164.72837997111668, -5.1302650823301885],
          [160.11412215861668, 2.1133630909724754],
          [152.59947372111668, 3.0352733285728117],
          [146.66685653361668, 2.991388778986984],
          [139.89927840861668, 2.7719401962986745],
          [134.58189559611668, 1.981611352071806]]]),
    Terrestrial_RF = /* color: #1bd604 */ee.Geometry.Polygon(
        [[[150.40174995987542, -2.6555178955989795],
          [150.4388288172973, -2.6630628621906873],
          [150.4662946376098, -2.663748765954904],
          [150.4937604579223, -2.658261525152828],
          [150.50749336807854, -2.6548319872581607],
          [150.53015266983635, -2.6692359823076366],
          [150.5926374110473, -2.697357580503395],
          [150.63864266007073, -2.713818702546113],
          [150.6922010096801, -2.7453685587230403],
          [150.7251599940551, -2.748111985245722],
          [150.81511055557854, -2.7522271132052882],
          [150.9009412440551, -2.702158764175671],
          [150.90506111710198, -2.676780864779207],
          [150.8789685878051, -2.636998237042073],
          [150.82129036514885, -2.612990862187874],
          [150.78421150772698, -2.6075033976102904],
          [150.7581189784301, -2.6198501591754084],
          [150.72721993057854, -2.6253375697166397],
          [150.6750348719848, -2.632196798999795],
          [150.64344917862542, -2.6555178955989795],
          [150.62971626846917, -2.6541460785366042],
          [150.6043103846801, -2.6397419076052286],
          [150.58989082901604, -2.6205360868091914],
          [150.5713514003051, -2.6150486552236036],
          [150.54182564346917, -2.593098689347572],
          [150.53633247940667, -2.5560572600118596],
          [150.50749336807854, -2.492261189968533],
          [150.50062691300042, -2.477855195028588],
          [150.48414742081292, -2.4661930842786273],
          [150.46972786514885, -2.4504147718005194],
          [150.43264900772698, -2.481285208075033],
          [150.39213692276604, -2.564288781684939],
          [150.39076363175042, -2.608189331992447]]]),
    mid_mask = /* color: #14ff46 */ee.Geometry.Polygon(
        [[[150.36947762100823, -2.4342932709534937],
          [150.34750496475823, -2.460362001002339],
          [150.3729108485473, -2.4740821808825157],
          [150.39213692276604, -2.4486997370777552],
          [150.38115059464104, -2.43360724490873]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
///////////////////////////////
// Global coral atlas project - PNG - Solomons
// Contact: mitchell.lyons@gmail.com
// Region coordinator: Chris Roelfsema (chris.m.roelfsema@gmail.com)
// Description:
// - Developing a process to combine OBIA and supervised classification
// - This script loads the raw classification data (from *_classification script)
// - Then applied some cleanup and object-based relational rules
///////////////////////////////

// Table of contents
// 1. Setting constants
// 2. Data loads & vis
// 3. OBIA clean up rules
// 4. Export

// Load and libraries needed
var map_palettes = require('users/mitchest/global_reefs:Modules/colour_pals');
var pkg_vis = require('users/mitchest/global_reefs:Modules/pkg_vis');
var param_module = require('users/mitchest/global_reefs:Modules/reef_params');

// ###########################################
// SENSOR GENERICS
var sensor_params = param_module.dove;         //<------------ THIS IS WHERE YOU CHOOSE THE SENSOR
// REGION AND SENSOR SPECIFIC LOAD PATHS
var region_params = param_module.png_solomons;  //<------------ THIS IS WHERE YOU CHOOSE THE REGION
//  ^^ all the data paths are in this module ^^
// ###########################################

// 1. Setting constants

// These will get written to the asset metadata 

var vars = {
  
  // analysis type
  geomorphic: true, // map geomorphic zonation (when set to true) or benthic habitat (when set to false)

  // analysis parameters
  image_data_scale: sensor_params.pixel,
  small_object_geo: ee.Number(400).int(), // smallest object szie in pixels (geomorphic)
  small_object_benthic: ee.Number(130).int(), // smallest object szie in pixels (benthic)
  smooth_radius: ee.Number(3), // radius in pixels for initial smooth 
  dist_to_land: 1000, //distance to land in meters to disallow reef crest, and convert to terrestrial reef flat
  wave_height: 0.4, //cut off height for waves in metres, Hs95 threshold
  geo_depth_cutoff: 1000, //depth in centimetres
  shallowlag_depth_cutoff: 500, //depth in centimetres
  benthic_depth_cutoff: 800, //depth in centimetres
  
  //############
  // Clean-up stage selection
  cleanup_stage: 3, // set to 1, 2 or 3
  geo_refinement: false, // set to true to apply the refinement_mask (the other stage 3 masks will still run)
  
  /*
  - GEOMORPHIC 1: The first pass does a small object filter, just to generally clean noise and reduce the amount of cleaning needed
  -            2: The second pass runs the OBIA cleanup rules
  -            3: The third pass is the MANUAL cleanup stage, which includes AT LEAST the no_reef masking
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY

  - BENTHIC 1: This is the main benthic stge - it does noise removal, no data reclaim and OBIA rules - review those if needed
            2: The second mas is the MANUAL stage - it's optional, but shuold include ALL region specific stuff
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY
  */
  
  // DON'T TOUCH ---> DO WE NEED TO KEEP IT LINE 68-91
  obia_2nd_pass: null,
  obia_clean: null, // run object-based relationship rules + small object clean up
  fast_clean: null, // run a faster (but less precise) version of the OBIA clean; only applies to geomorphic (`obia_clean: true` also)
  manual_clean: false, // apply manual touch ups
  // --------------<
  //############
  
  smooth_output: false, // run smoother over final output (includes noise removal) (should be false for second pass)
  
  // results/layers to show
  export_small_area: false,
  show_eg_area: false, // constrain the map add to the corresponding example_area polygon geomtery (you can change that)
                              // - you can either set this, or have it false and just navigate to the area you want to see (keeping in mind ALL tiles in the zoom area will calcualte)
  reproject_display: true,
  //reproject_res: ee.Number(sensor_params.pixel).pow(2),
  
  // export options
  do_export: true, // export the results?
  geomorph_output_name: region_params.sname + '_geo_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  benthic_output_name: region_params.sname + '_benthic_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  asset_output: region_params.asset // asset path

};


// Clean up stage auto-parameterisation (DON'T TOUCH) --->

// Geomorphic

if (vars.geomorphic) {
  var temp_outname = vars.geomorph_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.obia_2nd_pass = true;
    vars.obia_clean = true;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '2';
  } else if (vars.cleanup_stage == 3) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = false;
    vars.smooth_output = false;
    vars.do_export = false;
    vars.geomorph_output_name = temp_outname + '3';
  }
}

// Benthic

if (!vars.geomorphic) {
  var temp_outname = vars.benthic_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = true,
    vars.obia_clean = true, 
    vars.fast_clean = false, 
    vars.manual_clean = false;
    vars.benthic_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false,
    vars.obia_clean = false, 
    vars.fast_clean = false,
    vars.smooth_output = false,
    vars.do_export = false;
    vars.benthic_output_name = temp_outname + '2';
  }
}
// END OF INITIAL SETTINGS -----------------------------------------<

// ############################
// START OF CLEAN 3 - Manual Cleanup

// review everything in this section
// first review the reef_boundary object - as it is required for all cleanup stages
// ############################

// This can be hand drawn or imported from elsewhere, or could just be a big box
// Reef_boundary defines export extent and can be used to clip out unwanted areas
Map.addLayer(reef_boundary, {}, "Manual reef outline", false);

// ############################
// This is the section to add/remove manual cleanups
// You MUST review it for each region
// ############################

if (vars.manual_clean && vars.geomorphic) {
  
  print("Doing GEOMORPHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.pixels).select('depth');
  var depth_cont = depth.lt(900);// WHY DO WE HAVE THIS CHRIS ASK
  Map.addLayer(depth_cont, {}, "depth contour", false);
  
  // update these values based on inspection of the layer
  //Map.addLayer(waves.lt(vars.wave_height), {}, vars.wave_height + "m Hs95 threshold", false)
  
  
  var midmask = ee.Image().byte().paint(ee.Feature(mid_mask, {zone: 1}), "zone").clip(mid_mask);
  var TerrestrialRF = ee.Image().byte().paint(ee.Feature(Terrestrial_RF, {zone: 1}), "zone").clip(Terrestrial_RF);
  
 
  // define the manually edited map - uses the output from the second pass of cleaning
  var man_geo = ee.Image(region_params.geo_map_clean2);
 
  /* // "LAND MASK" CLEAN
  // remove
  man_geo = man_geo.where({
    test: landmask.eq(1),
    value: ee.Image(0)
  });*/
  
  // "NOT REEF" CLEAN
  // remove
  man_geo = man_geo.where({
    test: midmask.eq(1),
    value: ee.Image(0)
  });
  
  /*// WAVE clean ############# ---> (to be integrated into RF classifier when feasible)
  // remove
  man_geo = man_geo.where({
    test: waves.lte(vars.wave_height)
               .and(man_geo.eq(22)),
    value: ee.Image(21)
  })*/
  
  // **Terrestrail Reef Flat clean**
  
// R
  man_geo = man_geo.where({
    test: TerrestrialRF.neq(1)
                     .and(man_geo.eq(16)),
    value: ee.Image(14)
  });
  
  /*   // Deep water -> Deep lagoon (inside the reef)
  man_geo = man_geo.where({
    test: notdeepwater.eq(1)
                     .and(man_geo.eq(2)),
    value: ee.Image(12)
  });
  
  // Shallow lagoon/Deep lagoon/Shelterd reef slope -> Reef slope (around the reef edge)
  man_geo = man_geo.where({
    test: reefslope.eq(1)
                     .and(man_geo.eq(11)).or(man_geo.eq(12)).or(man_geo.eq(21)),
    value: ee.Image(22)
  });
  
  // Reef slope/Sheletered reef slope -> Deep lagoon (insided the reef)
  man_geo = man_geo.where({
    test: notdeepwater.eq(1)
                     .and(man_geo.eq(22)).or(man_geo.eq(21)),
    value: ee.Image(12)
  });
  

  // **Shallow Water clean**
  
  // Create smoothed depth layer to use in where operations
  var smooth_depth = depth
                      //.unmask(99)
                      .focal_mode({
                        radius: vars.smooth_radius, // relates to smoothness required
                        kernelType: 'circle', units: 'pixels', iterations: 2
                      });
  
  
  // **Litchfield Coast**
  
  // Inner reef flat/Outer reef flat -> TRF
  man_geo = man_geo.where({
    test: litchfield.eq(1)
                     .and(man_geo.eq(13)).or(man_geo.eq(14)),
    value: ee.Image(16)
  });
  
  // Non TRF -> Mask
  man_geo = man_geo.where({
    test: litchfield.eq(1)
                     .neq(man_geo.eq(16)),
    value: ee.Image(0)
  });
  
  // **Arnhem Land Coast**
  
  // Shallow lagoon, IRF, SRS, BRS, RC -> TRF
  man_geo = man_geo.where({
    test: arnhemcoast.eq(1)
                     .and(man_geo.eq(11)).or(man_geo.eq(13)).or(man_geo.eq(21)).or(man_geo.eq(24)).or(man_geo.eq(15))
                     .and(smooth_depth.lte(300)),
    value: ee.Image(16)
  });
  
  // Shallow lagoon, IRF, BRS -> Mask
  man_geo = man_geo.where({
    test: arnhemcoast.eq(1)
                     .and(man_geo.eq(11)).or(man_geo.eq(16)).or(man_geo.eq(21)).or(man_geo.eq(24))
                     .and(smooth_depth.gt(300)),
    value: ee.Image(0)
  });
  
  // **Northern WA Coast** was 150 and BRS
  // Shallow lagoon, IRF, BRS -> TRF 
 
  
  // Shallow lagoon, IRF, Sheltered slope -> TRF
  man_geo = man_geo.where({
    test: northernwa.eq(1)
                     .and(man_geo.eq(11)).or(man_geo.eq(13)).or(man_geo.eq(21)),
    value: ee.Image(16)
  });
  
  // **Dampier Coast**
  
  // Shallow lagoon, IRF, Sheltered slope -> TRF
  man_geo = man_geo.where({
    test: dampier.eq(1)
                     .and(man_geo.eq(11)).or(man_geo.eq(13)).or(man_geo.eq(21)),
    value: ee.Image(16)
  });
  
  // **Wellesley Island & Tiwi Islands**
  
  // Shallow lagoon -> BRS 
  man_geo = man_geo.where({
    test: welleslytiwi.eq(1)
                     .and(man_geo.eq(11)),
    value: ee.Image(24)
  });
  
  // IRF, SRS -> TRF 
  man_geo = man_geo.where({
    test: welleslytiwi.eq(1)
                     .and(man_geo.eq(13)).or(man_geo.eq(21)),
    value: ee.Image(16)
  });
  
  // BRS -> TRF
  man_geo = man_geo.where({
    test: tiwi.eq(1)
                     .and(man_geo.eq(24)),
    value: ee.Image(16)
  });
  
  // **Mid-Shelf**
  
  // Shallow lagoon, Deep lagoon, SRS -> BRS 
  man_geo = man_geo.where({
    test: midshelf.eq(1)
                     .and(man_geo.eq(11)).or(man_geo.eq(12)).or(man_geo.eq(21)),
    value: ee.Image(24)
  });
  
  // Reef crest -> Outer reef flat
  man_geo = man_geo.where({
    test: midshelf.eq(1)
                     .and(man_geo.eq(15)),
    value: ee.Image(14)
  });
  
  // **Inshore reef**
  
  // Inner reef flat, TRF -> Outer reef flat
  man_geo = man_geo.where({
    test: inshorereefouter.eq(1)
                     .and(man_geo.eq(13)).or(man_geo.eq(16)),
    value: ee.Image(14)
  });
  
  // TRF, SRS -> Inner reef flat
  man_geo = man_geo.where({
    test: inshorereefinner.eq(1)
                     .and(man_geo.eq(16)).or(man_geo.eq(21)),
    value: ee.Image(13)
  });*/ 
  
  if (vars.geo_refinement) {
    // make the mask image layer
    var refine = ee.Image().byte().paint(ee.Feature(refinement_mask, {zone: 1}), "zone").clip(refinement_mask);
    // apply
    man_geo = man_geo.where({
      test: refine.eq(1),
      value: ee.Image(0)
    });
  }
  
  // Add the manual layer to the map
  var image = ee.Image(region_params.image);
  Map.addLayer(image, {bands: ['b3','b2','b1'], min:0, max:4000, gamma:1.5}, sensor_params.sname + ' low tide', true);
  
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(geo_clean2, map_palettes.geo, 'Geo clean stage 2', false);
  Map.addLayer(man_geo.updateMask(man_geo.gt(2)), map_palettes.geo, 'Geo clean stage 3 - MANUAL', true);
  
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_geo,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: reef_boundary,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
} 

if (vars.manual_clean && !vars.geomorphic) {
  
  print("Doing BENTHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.pixels).select('depth');
  var depth_cont = depth.lt(900);
  Map.addLayer(depth_cont, {}, "depth contour", false);
  
  // define the final geomorphic map (the manually edited geo map - stage 3)
  var geo_map = ee.Image(region_params.geo_map_clean3);
  
  var man_benthic = ee.Image(region_params.benthic_map_clean1);
  
  // **Generic benthic rules**
  
  // BMA on inner RF, outer RF,reef crest, reef slope -> rubble 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(18)
                     .and(geo_map.eq(13).or(geo_map.eq(14)).or(geo_map.eq(15)).or(geo_map.eq(22))),
    value: ee.Image(12)
  });
    
  // **Manual polygon guided rules**
    
  // Sub-regions copied here to run in benthic clean, originally defined under manual cleanup for geo
  var subreg_1 = ee.Image().byte().paint(ee.Feature(inner, {zone: 1}), "zone").clip(inner);
  var subreg_2 = ee.Image().byte().paint(ee.Feature(outer, {zone: 1}), "zone").clip(outer);
  var ashmore = ee.Image().byte().paint(ee.Feature(ashmore_reef, {zone: 1}), "zone").clip(ashmore_reef);
   
  // **Inshore**
    
  // Rock on TRF -> coral/algae
  man_benthic = man_benthic.where({
    test: subreg_1.eq(1)
                      .and(geo_map.eq(16))
                      .and(man_benthic.eq(13)),
    value: ee.Image(15)
  });
    
  // **Offshore**
    
  // Seagrass -> Coral/algae (Ashmore Reef)
  man_benthic = man_benthic.where({
    test: ashmore.eq(1)
                      .and(man_benthic.eq(14)),
    value: ee.Image(15)
  });
  
  // Seagrass -> Sand
  man_benthic = man_benthic.where({
    test: subreg_2.eq(1)
                      .and(man_benthic.eq(14)),
    value: ee.Image(11)
  });
  
  // Sand on RC, RS -> Coral/algae
  man_benthic = man_benthic.where({
    test: subreg_2.eq(1)
                      .and(man_benthic.eq(11))
                      .and(geo_map.eq(15)).or(geo_map.eq(22)),
    value: ee.Image(15)
  });
     
  // Add the manual layer to the map

  var low_tide_image_dove = ee.Image(region_params.image);
  Map.addLayer(low_tide_image_dove, {bands: ['b3','b2','b1'], min: 0, max: 3000}, sensor_params.sname + ' low tide', false); // image data
  
  var benthic_clean1 = ee.Image(region_params.benthic_map_clean1);
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false);
  Map.addLayer(geo_clean2.updateMask(geo_clean2.gt(2)), map_palettes.geo, 'Geo clean stage 2', false);
  Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Geo clean stage 3 - MANUAL', true);
  Map.addLayer(benthic_clean1, map_palettes.benthic, 'Benthic clean stage 1', false);
  Map.addLayer(man_benthic, map_palettes.benthic, 'Benthic clean stage 2 - MANUAL', true);
  
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_benthic,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: reef_boundary,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
}

// ############################
// END OF MANUAL SECTION
// ############################


// 2. Data loads & vis

// load input data

// define raw geo/benthic outputs
// Run check to see if the region has been split into multiple areas

// geo
if (ee.List(region_params.geo_map).length().getInfo() > 1) {
  var geo_map_raw = ee.Image(region_params.geo_map[0]).unmask(0, false)
               .add(ee.Image(region_params.geo_map[1]).unmask(0,false))
               .selfMask();
} else {
  var geo_map_raw = ee.Image(region_params.geo_map);
}

// benthic
if (ee.List(region_params.benthic_map).length().getInfo() > 1) {
    var benthic_map = ee.Image(region_params.benthic_map[0]).unmask(0, false)
             .add(ee.Image(region_params.benthic_map[1]).unmask(0,false))
             .selfMask();
} else {
    var benthic_map = ee.Image(region_params.benthic_map);
}

// set the geo map for further processing
if (vars.geomorphic && vars.obia_2nd_pass) {
  // if it's 2nd pass, you want to make sure you're loading the latest geo clean map
  var geo_map = ee.Image(region_params.geo_map_clean1);
} else if (vars.geomorphic) {
  var geo_map = geo_map_raw;
}

var depth = ee.Image(region_params.pixels).select('depth');
var low_tide_image = ee.Image(region_params.image);

var display_pal = (vars.geomorphic) ? map_palettes.geo : map_palettes.benthic;
//Map.centerObject(eg_area, 11)
Map.addLayer(depth, {min:0, max:2500}, 'Depth data', false);
Map.addLayer(low_tide_image, {bands: ['b3','b2','b1'], min:0, max:3000}, sensor_params.sname + ' low tide', false);

// load for display purposes
if (vars.geomorphic) {
  Map.addLayer(geo_map_raw, display_pal, 'Geomorphic map RAW', false);
  if (vars.cleanup_stage == 2) Map.addLayer(ee.Image(region_params.geo_map_clean1), display_pal, 'Geomorphic map - stage 1 clean', false);
}
if (!vars.geomorphic) {
  // Use the manually cleaned geomorphic map as input for the benthic clean
  var geo_map = ee.Image(region_params.geo_map_clean3);
  if (!vars.manual_clean) Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Final geo map (manual clean - stage 3)', false);
  Map.addLayer(benthic_map, display_pal, 'Benthic map RAW', false);
}

// 3. Object-based re-classificaiton and cleaning

/*

// if we want to retain the land/waves flags, need to add them in before makign the mask

######## Not that straight forwards - the land and bright masks are a LOT of not land and not breakign waves... =(

// add in land, for geomorphic clean up rules
  geo_map = geo_map.unmask(0).where({
    test: depth.eq(-2).and(globcover.select('landcover').neq(210)),
    value: ee.Image(1)
  })
  
  // change -3 to reef rim, hope that clouds have been handleded by masking
  geo_map = geo_map.unmask(0).where({
    test: depth.eq(-3),
    value: ee.Image(15)
  })
  
  // remask
  geo_map = geo_map.updateMask(geo_map.gt(0))

*/


/* OUTPUT EXTENT
  - to the mapping extent just so it doesn't balloon out
  - to the 'reef boundary' extent for noise/deep removal
*/  
var class_extent_mask = geo_map.gt(0);

/*

########
Initial small object clean
 - this was originally at the end, but we needed to massively reduce the number of objects to 
   iterate through in the OBIA cleaning, so this happens first now
 - future collabs with google might fix this, but need to change the parallel serialisation of vector procesing
 
 - includes a possible special case for:
      - geomorphic to clean up turbid areas over size threshold; fix shallow vs. deep lagoon
      - benthic to allow breaking waves (temporal class) to grow into surrounding class
########

*/

// ############################
// START OF CLEAN 1
// ############################

// Geomorphic Clean

if (vars.geomorphic && !vars.obia_2nd_pass) {
  
  // make a smooth map with masked area as a value
  var smooth_map = geo_map
                      //.unmask(99)
                      .focal_mode({
                        radius: vars.smooth_radius, // relates to smoothness required
                        kernelType: 'circle', units: 'pixels', iterations: 2
                      });
  //smooth_map = smooth_map.updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)
  
  //replace small objects with smooth underneath
  var clean_map = geo_map.where({
    test: geo_map.connectedPixelCount(vars.small_object_geo, false).lt(vars.small_object_geo), 
    value: smooth_map
  //}).updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)
  }).updateMask(class_extent_mask);
  
  // shallow lagoon > 5m == deep lagoon
  clean_map = clean_map.where({
    test: clean_map.eq(11)
                   .and(depth.gt(vars.shallowlag_depth_cutoff)),
    value: ee.Image(12)
  });
  
  /*// deep lagoon == deep (to hard to differentiate deep water vs. deep lagoon effectively over large areas)
  clean_map = clean_map.where({
    test: clean_map.eq(12),
    value: ee.Image(2)
  })*/
  
  // deep water in depth data == deep (s2 + ls8 data should be good enough for this)
  clean_map = clean_map.where({
    test: depth.gt(vars.geo_depth_cutoff),
    value: ee.Image(2)
  });
  
  // deep water in depth data == deep (only for inshore reefs of Timor Sea)
  //  var inner_extent = ee.Image().byte().paint(ee.Feature(inner, {zone: 1}), "zone").clip(inner);
   // clean_map = clean_map.where({
   //   test: depth.gt(700)
   //                  .and(inner_extent.eq(1)),
   //   value: ee.Image(2)
  //  });
  
  // LAND mask cleaning
  Map.addLayer(land_dist.lte(vars.dist_to_land), {}, "Land mask (dist to land)", false);
  
  // reef crest close to terrestrial main land not including coral cays -> TRF 
  //var inner_extent = ee.Image().byte().paint(ee.Feature(inner, {zone: 1}), "zone").clip(inner);
  clean_map = clean_map.where({
    test: land_dist.lte(vars.dist_to_land)
  //                 .and(inner_extent.eq(1))
                   .and(clean_map.eq(15)),
    value: ee.Image(16)
  });
  
  // TRF far from land -> ORF
  clean_map = clean_map.where({
    test: land_dist.gt(vars.dist_to_land)
                   .and(clean_map.eq(16)),
    value: ee.Image(14)
  });
  
  
  
  /*//CLEAN UP SMALL (but slightly larger) TURBID AREAS
  var smooth_noturbid = clean_map
                          .updateMask(clean_map.neq(3))
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(1.5),
                            kernelType: 'circle', units: 'pixels', iterations: 2
                          })
  
  clean_map = clean_map.where({
    test: clean_map.eq(3).connectedPixelCount(vars.small_object_geo.multiply(10), false).lt(vars.small_object_geo.multiply(10)), 
    value: smooth_noturbid
  }).updateMask(class_extent_mask)*/
}

// Benthic Clean 1
if (!vars.geomorphic && vars.cleanup_stage == 1) {
  
  // make a smooth map with masked area as a value, and without temporal class (basically breaking waves)
  var smooth_map = benthic_map
                      //.unmask(99)
                      .focal_mode({
                        radius: vars.smooth_radius, // relates to smoothness required
                        kernelType: 'circle', units: 'pixels', iterations: 1
                      });
  //smooth_map = smooth_map.updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)
  
  //replace small objects with smooth underneath
  var clean_map = benthic_map.where({
    test: benthic_map.connectedPixelCount(vars.small_object_benthic, false).lt(vars.small_object_benthic),
    value: smooth_map
  //}).updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)
  }).updateMask(class_extent_mask);
  
  
  /*// CLEAN UP ALL TEMPORAL AREAS
  var smooth_notemp = benthic_map
                          .updateMask(benthic_map.neq(2))
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(2),
                            kernelType: 'circle', units: 'pixels', iterations: 3
                          })
  
  
  clean_map = clean_map1.where({
    test: benthic_map.eq(2), 
    value: smooth_notemp
  }).updateMask(clean_map1.gte(0))
  
  // this catches any left over unmasked temporal, and assigned it back to temporal
  clean_map = clean_map.where({
    test: clean_map.unmask(99).eq(99).and(clean_map1.eq(2)),
    value: ee.Image(2)
  })*/
  
}

// ############################
// START OF CLEAN 2
// ############################

if (vars.geomorphic && vars.obia_2nd_pass) {
  var clean_map = geo_map;
}

if (vars.obia_clean) {
  
  if (vars.geomorphic && !vars.fast_clean) { // SHOULD TRY TO PUT THIS OUT TO A MODULE TO KEEP THE RULES THE SAME EVERYWEHRE?
    
    // #########
    // THE PLAN - vectorise one/few class/es at a time, thus only spending resources on what is actually needed to clean up
    // #########
    
    // FUNCTION that maps over feature colleciton and assigns neighbour percentages
    var set_neighbour_properties = function(f) {
      // make the 1px buffer
      var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5));
      // reduce the classes in the buffer zone
      var diff_classes = ee.Dictionary(
        clean_map.unmask(ee.Image(0)).reduceRegion({
          reducer: ee.Reducer.frequencyHistogram(),
          geometry: diff.geometry(),
          scale: vars.image_data_scale,
          maxPixels: 1e11
        }).get('classification')
      );
      // calculate the percentages
      var diff_sum = diff_classes.toArray().reduce(ee.Reducer.sum(), [0]).get([0]);
      var diff_percs = diff_classes.map(function(k,v){return(ee.Number(v).divide(diff_sum).multiply(100).toUint8())});
      
      /* NOW, we can try to do the class logic right here (see /users/mitchest/global_reefs/obia_dev),
         or we can return the neighbour % and do image logic via (painted) rasters */
      
      return(f.set(diff_percs));
    };
    
    // FUNCTION to reduce the map to vectors and map the neighbour properties function
    var reduce_neighbours = function() {
      // reduce map to vectors
      var map_fc = clean_map
            .updateMask(segment_id).updateMask(clean_map.eq(classn)) // only vectorise class/es of interest
            .reduceToVectors({
              scale: vars.image_data_scale, 
              eightConnected: false,
              bestEffort: true, 
              maxPixels: 1e13,
              tileScale: 1,
              geometry: reef_boundary
            });
      // map the function, calculate neighbour properties
      return(map_fc.map(set_neighbour_properties));
    };
    
    // first make a make size threshold, so we're not vecortising huge objects when we don't have to
    var segment_id = clean_map.connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels');
    //Map.addLayer(segment_id.reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))))
    Map.addLayer(clean_map.updateMask(segment_id).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
    
    // This is where we select the single or group of classes to vectorise for cleaning up
    //var classn = ee.Number(15) // one class
    var classn = clean_map.where({
      test: clean_map.neq(16) //TRF
              .and(clean_map.neq(15)) //RR
              .and(clean_map.neq(14)) //ORF
              .and(clean_map.neq(13)) //IRF
              //.and(clean_map.neq(12)) // deep L
              .and(clean_map.neq(11)), // shallow L 
      value: ee.Image(99) // 99 ensures it's ignored in logic
    });
    
    // Minimum size of object to reclass based on neighbourhood
    var max_size = ee.Number(1000).divide(vars.image_data_scale).pow(2); // the first number is the square dimension of the desired min size;
    // calculate neighbours
    var map_fc_neighbours = reduce_neighbours();
    
    // #########
    // REEF RIM
    // #########
    
    var focus_class = ee.Number(15); //RR
    
    // start the object-based neighbourhood rules
    // paint out to rasters (only paint the layers needed)
    var objsize = ee.Image(30000).paint(map_fc_neighbours, 'count').rename('count');
    //var nb24 = ee.Image().byte().paint(map_fc_neighbours, '24').unmask(0).rename('nb24') //OCL
    var nb22 = ee.Image().byte().paint(map_fc_neighbours, '22').unmask(0).rename('nb22'); //SL ex
    var nb21 = ee.Image().byte().paint(map_fc_neighbours, '21').unmask(0).rename('nb21'); //Sl sh
    var nb16 = ee.Image().byte().paint(map_fc_neighbours, '16').unmask(0).rename('nb16'); //TRF
    var nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15'); //RR
    var nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14'); //ORF
    var nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13'); //IRF
    //var nb3 = ee.Image().byte().paint(map_fc_neighbours, '3').unmask(0).rename('nb3') //Turbid
    
    // RR surrounded by ORF --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb14.gt(75)),
      value: ee.Image(14)
    });
    
    // RR surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.gt(75)),
      value: ee.Image(13)
    });
    
    // RR surrounded by IRF + ORF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.add(nb14).gt(75)),
      value: ee.Image(13)
    });
    
    // RR with decent border to TRF --> TRF (often dark, probably seagrass)
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb16.gt(40)),
      value: ee.Image(16)
    });
    
    /*// RR surrounded by OCL --> OCL
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb24.gt(75)),
      value: ee.Image(24)
    })*/
    
    /* with 2nd/3rd pass method, we don't really need this
    // RR surrounded by IRF + ORF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.lte(75).and(nb14.lte(75))) // to ensure we're no re-writing previous rules
              .and(nb13.add(nb14).gt(75))
              .and(nb21.add(nb22).lte(0)), // to not get rid of complex reef rims (if touching slope, it's probably RR)
      value: ee.Image(13) // could try assigning to a place-holder, then deal with at the end?
    })*/
    
    /*// small RR objects touching OCL + stuff --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(objsize.lte(max_size))
              .and(nb13.lte(75).and(nb14.lte(75))) // to ensure we're no re-writing previous rules
              .and(nb24.gt(1)),
      value: ee.Image(14)
    })*/
    
    // ####
    // ORF
    // ####
    
    focus_class = ee.Number(14); // ORF
    
    //classn = ee.Number(14)
    //map_fc_neighbours = reduce_neighbours()
    //var nb22 = ee.Image().byte().paint(map_fc_neighbours, '22').unmask(0).rename('nb22') //SL ex
    //var nb21 = ee.Image().byte().paint(map_fc_neighbours, '21').unmask(0).rename('nb21') //Sl sh
    //nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15') //RR
    //nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13') //IRF
    //var nb1 = ee.Image().byte().paint(map_fc_neighbours, '1').unmask(0).rename('nb1') //Land
    
    // ORF surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.gt(75)),
      value: ee.Image(13)
    });
    
    // ORF surrounded by TRF --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb16.gt(75)),
      value: ee.Image(16)
    });
    
    // ORF surrounded by RR --> RR
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb15.gt(85)),
      value: ee.Image(15)
    });
    
    // ORF touching slope and RR --> RR
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb21.gt(0).or(nb22.gt(0)))
              .and(nb15.gt(0)),
      value: ee.Image(15)
    });
    
    /*// ORF touching land --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb1.gt(10)),
      value: ee.Image(16)
    })*/
    
    // ####
    // IRF
    // ####
    
    focus_class = ee.Number(13); // IRF
    
    //classn = ee.Number(13)
    //map_fc_neighbours = reduce_neighbours()
    //nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15') //RR
    //nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14') //ORF
    
    // IRF surrounded by ORF --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb14.gt(75)),
      value: ee.Image(14)
    });
    
    // IRF surrounded by TRF --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb16.gt(75)),
      value: ee.Image(16)
    });
    
    // IRF surrounded by RR --> RR
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb15.gt(85)),
      value: ee.Image(15)
    });
    
    /*// IRF touching land --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb1.gt(10)),
      value: ee.Image(16)
    })*/
    
    // ####
    // TRF
    // ####
    
    focus_class = ee.Number(16); // TRF
    
    //classn = ee.Number(16)
    //map_fc_neighbours = reduce_neighbours()
    //nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15') //RR
    //nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14') //ORF
    //nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13') //IRF
    
    // TRF surrounded by ORF --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb14.gt(75)),
      value: ee.Image(14)
    });
    
    // TRF surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.gt(75)),
      value: ee.Image(13)
    });
    
    // TRF surrounded by IRF + ORF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.add(nb14).gt(75)),
      value: ee.Image(13)
    });
    
    /*// TRF not touching land --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb1.lt(10)),
      value: ee.Image(13)
    })*/
    
    
    // ####
    // LAGOONS
    // ####
    
    var nb11 = ee.Image().byte().paint(map_fc_neighbours, '11').unmask(0).rename('nb11'); // shallow lag
    //var nb12 = ee.Image().byte().paint(map_fc_neighbours, '12').unmask(0).rename('nb12') //deep lag
    
    // DL touching SL --> SL
    /* 
    This is a stop-gap until we have better depth product - below are the rules we want,
    but too much band-aiding is required to make it work, so for the moment just err on the side
    of shallow lagoon when it's mixed.
    */
    /*clean_map = clean_map.where({
      test: clean_map.eq(12)
              .and(nb11.gt(0)),
      value: ee.Image(11)
    })*/
    
    /*// SL sourrounded by DL --> DL
    clean_map = clean_map.where({
      test: clean_map.eq(11)
              .and(nb12.gt(75)),
      value: ee.Image(12)
    })*/
    
    /*// DL sourrounded by SL --> SL
    clean_map = clean_map.where({
      test: clean_map.eq(12)
              .and(nb11.gt(75)),
      value: ee.Image(11)
    })*/
    
    /*// DL/SL surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(11).or(clean_map.eq(12))
              .and(objsize.lte(max_size))
              .and(nb13.gt(80)),
      value: ee.Image(13)
    })*/
    
    // SL surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(11)
              .and(objsize.lte(max_size))
              .and(nb13.gt(80)),
      value: ee.Image(13)
    });
    
    /*// DL/SL touching OCL --> OCL
    clean_map = clean_map.where({
      test: clean_map.eq(11).or(clean_map.eq(12))
              .and(nb24.gt(0)),
      value: ee.Image(24)
    })*/
    
    
    /*// ####
    // Turbid
    // ####
    
    focus_class = ee.Number(3) // turbid
    
    // Turb surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.gt(75)),
      value: ee.Image(13)
    })
    
    // Turb surrounded by ORF --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb14.gt(75)),
      value: ee.Image(14)
    })
    
    // Turb surrounded by TRF --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb16.gt(75)),
      value: ee.Image(16)
    })*/
  
  } else if (vars.geomorphic && vars.fast_clean) {
    print("Executing the fast version OBIA");
    
    /* fast version of the geo clean up
      - blanket version assigns the underlying most common in neighbourhood
      - mode OBIA version iterates through objects+buffers but take the mode instead of doing the class percs, to see if that speeds things up
    */
    
    
    //############
    //# blanket version
    //############
    // make a very smooth map to capture the broader neighbourhood
    var smooth_map = clean_map
                        .focal_mode({
                          radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 2
                        });
    
    
    // first make a make size threshold, so we're not vectorising huge objects when we don't have t
    // - the unmask(99) captures small no data values/ data gaps
    var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt().multiply(2)).select('labels').pow(2).log().int();
    Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
    
    
    // replace small objects with smooth underneath
    var clean_map = clean_map.unmask(0).where({
      test: segment_id.gt(0), 
      value: smooth_map
    }).selfMask();
    //############
    //############
    
    
    /*    
    //############
    //# mode OBIA version
    //############
    
    // #########
    // THE FASTER PLAN - vectorise one/few class/es at a time, thus only spending resources on what is actually needed to clean up
    //                 - BUT, just assign the mode of the neighbours, so save resouces even further??
    // #########
    
    // FUNCTION that maps over feature colleciton and assigns neighbour percentages
    var set_neighbour_mode = function(f) {
      // make the 1px buffer
      var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5))
      // reduce the classes in the buffer zone
      var diff_mode = ee.Number(ee.Dictionary(
        clean_map.unmask(ee.Image(0)).reduceRegion({
          reducer: ee.Reducer.mode(),
          geometry: diff.geometry(),
          scale: vars.image_data_scale,
          maxPixels: 1e11
        })).get('classification'))
      
      return(f.set('mode',diff_mode))
    }
    
    // FUNCTION to reduce the map to vectors and map the neighbour properties function
    var reduce_neighbours_mode = function() {
      // reduce map to vectors
      var map_fc = clean_map.unmask(0)
            .updateMask(classn.gt(0)) // only vectorise class/es of interest
            .reduceToVectors({
              scale: vars.image_data_scale, 
              eightConnected: false,
              bestEffort: true, 
              maxPixels: 1e13,
              tileScale: 1,
              geometry: reef_boundary
            })
      // map the function, calculate neighbour properties
      return(map_fc.map(set_neighbour_mode))
    }
    
    // first make a make size threshold, so we're not vecortising huge objects when we don't have to
    var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels')
    Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false)
    
    // This is where we select the single or group of classes to vectorise for cleaning up
    var classn = segment_id.where({
      test: clean_map.neq(16) //TRF
              .and(clean_map.neq(15)) //RR
              .and(clean_map.neq(14)) //ORF
              .and(clean_map.neq(13)) //IRF
              //.and(clean_map.neq(12)) // deep L
              .and(clean_map.neq(11)) // shallow L 
              .and(clean_map.unmask(0).neq(0)), // no data values (want to reclaim the small gaps 
      value: ee.Image(0) // 99 ensures it's ignored in logic
    })
    
    // calculate neighbours
    var map_fc_neighbours = reduce_neighbours_mode()
    
    //print(map_fc_neighbours.limit(10))
    
    var mode_map = ee.Image().byte().paint(map_fc_neighbours, 'mode').unmask(0).rename('mode') // paint out the mode values to an image
    //Map.addLayer(mode_map, display_pal, "mode map", false)
    
    // replace small objects with mode underneath
    var clean_map = clean_map.unmask(0).where({
      test: segment_id.gt(0), 
      value: mode_map
    }).selfMask()
    
    //############
    //############
    */
    
  } else {
    
    if (vars.cleanup_stage == 1) {
      // BENTHIC CLEAN-UP RULES
      
      // reclaim shallow no data to surrounding class
      var smooth_map = clean_map
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                            kernelType: 'circle', units: 'pixels', iterations: 2
                          });
      
      var clean_map = clean_map.unmask(0).where({
        test: geo_map.gt(2).and(clean_map.eq(0)), 
        value: smooth_map
      }).selfMask();
      
      // cut benthic off to < 10 - 15 m
      clean_map = clean_map.where({
        test: depth.gt(vars.benthic_depth_cutoff),
        value: ee.Image(0)
      });
      
      // Deep (or land or missing) in geo == masked from benthic
      clean_map = clean_map.where({
        test: geo_map.unmask(0).lte(2),
        value: ee.Image(0)
      });
      
      /*// Deep lagoon in geo == masked from benthic
      clean_map = clean_map.where({
        test: geo_map.eq(12),
        value: ee.Image(0)
      })*/
      
      
      /*// turbid in geo == turbid (temporal - class num 2)
      // ############## ---> need to decide here whether to push geo turbid through regardless of benthic class
      clean_map = clean_map.where({
        test: geo_map.eq(3),
        value: ee.Image(2)
      })*/
      
      /*
      // Ignore in benthic + ORF in geo == rock
      clean_map = clean_map.where({
        test: clean_map.eq(0)
                       .and(geo_map.eq(14)),
        value: ee.Image(13)
      })
      
      // Ignore in benthic + IRF in geo == sand
      clean_map = clean_map.where({
        test: clean_map.eq(0)
                       .and(geo_map.eq(13)),
        value: ee.Image(11)
      })
      
      // Ignore in benthic + TRF in geo == sand
      clean_map = clean_map.where({
        test: clean_map.eq(0)
                       .and(geo_map.eq(16)),
        value: ee.Image(11)
      })
      
      // Ignore in benthic + RR in geo == rock
      */
      
      /*// seagrass in benthic + ORF/RR/slope in geo == coral/algae
      clean_map = clean_map.where({
        test: clean_map.eq(14)
                       .and(geo_map.eq(14).or(geo_map.eq(15)).or(geo_map.eq(21)).or(geo_map.eq(22))),
        value: ee.Image(15)
      })*/
      
      // ####--> CR: "Seagrass neighbouring deep water or no data not shallow a rock or coral algae class"
      
      /*// rock in benthic + TRF in geo == sand
      clean_map = clean_map.where({
        test: clean_map.eq(13)
                       .and(geo_map.eq(16)),
        value: ee.Image(11)
      })*/
    }
  }
}

// final smooth
if (!vars.manual_clean) {
  if (vars.smooth_output) {
    // smooth the output lightly to make nice edges, and get rid of noise
    var noise_smooth = clean_map.unmask(99) // unmasking to a value allows us to include masked areas in the smooth, then re-mask after
                          .focal_mode({
                            radius: 2, // relates to smoothness required
                            kernelType: 'circle', units: 'pixels', iterations: 2
                          });
    clean_map = clean_map.updateMask(noise_smooth.neq(99)).updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too;
  } else {
    // just clip to the classified extent and move on
    if (vars.geomorphic) {
      clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
    } else {
      clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
    }
  }
}

// 4. Export data

var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;

if (vars.do_export) {
  print("For export, the image data scale must be set to:", vars.image_data_scale);
  
  if (vars.export_small_area) {
    var export_convhull = export_small;
  } else {
    //var export_convhull = clean_map.gt(2).reduceToVectors({scale: 1000, maxPixels: 1e13, bestEffort: true, geometry: region_extent, crs: "EPSG:4326"}).geometry().convexHull({maxError: 100})
    var export_convhull = reef_boundary;
  }
  Map.addLayer(export_convhull, {}, "Export footprint", false);
  
  Export.image.toAsset({
    image: clean_map.set(vars),
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: export_convhull,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  /*Export.image.toCloudStorage({
    image: clean_map,//.set(vars),
    description: 'swp_geo_clean',
    bucket: 'mitchest_unet_bucket',
    fileNamePrefix: 'swp_geo_clean',
    region: export_convhull,
    scale: 25,
    crs: 'EPSG:4326',
    maxPixels: 1e13
  })*/
  
} else {
  if (!vars.manual_clean) {
    if (vars.show_eg_area) {
      if (vars.reproject_display) {
        Map.addLayer(clean_map.clip(eg_area).reproject(ee.Projection('EPSG:4326').atScale(vars.image_data_scale)), display_pal, output_name, false);
      } else {
        Map.addLayer(clean_map.clip(eg_area), display_pal, output_name, false);
      }
    } else {
      if (vars.reproject_display) {
        Map.addLayer(clean_map.reproject(ee.Projection('EPSG:4326').atScale(vars.image_data_scale)), display_pal, output_name, true);
      } else {
        Map.addLayer(clean_map, display_pal, output_name, false);
      }
    }
  }
}

//Generate title
var title = ui.Label({
  value: 'Classes',
  style: {fontWeight: 'bold', fontSize: '12px'}
});

// generate the legend
var geo_legend = pkg_vis.discrete_legend(map_palettes.geo_atlas_names, map_palettes.geo_atlas_cols, 'Geomorphic Zone', false);
var benthic_legend = pkg_vis.discrete_legend(map_palettes.benthic_atlas_names, map_palettes.benthic_atlas_cols, 'Benthic Habitat', false);
//var mask_legend = pkg_vis.discrete_legend(["Low confidence depth","Water conditions"], ["#f7f7f7","#bababa"], 'Confidence Mask reason', false)
var legend = (vars.geomorphic) ? geo_legend : benthic_legend;
pkg_vis.add_lgds([title, legend]);//, mask_legend])
// generate the legend
