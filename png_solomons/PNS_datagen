/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var map_centre = /* color: #d63000 */ee.Geometry.Point([149.22561970263274, -5.792489261066369]),
    region_extent = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[133.93506336268342, -0.27082436810697647],
          [133.69336414393342, -1.3034277804031318],
          [133.78125476893342, -2.072131335894604],
          [134.55029773768342, -3.2573505312845414],
          [146.92090320643342, -9.93261226820655],
          [149.49170398768342, -11.271627819855544],
          [161.99414539393342, -13.823690454929968],
          [163.68567051433308, -11.128481634776966],
          [164.08154773768342, -7.6963062486568115],
          [164.25732898768342, -6.125820449330304],
          [160.9878025393591, -4.065372376281473],
          [157.67651844080842, -2.456351881729639],
          [151.53516101893342, -0.4685740595351938],
          [148.70068836268342, 0.25651751645627113],
          [144.61377430018342, 0.4103234597361438],
          [138.37353992518342, 0.4982113137085982],
          [134.48437976893342, 0.14665493202083]]]),
    noReef_mask = /* color: #ff0000 */ee.Geometry.MultiPolygon(
        [[[[136.23460438801584, -2.629275602393311],
           [136.54427215599102, -2.6962787263763],
           [137.36482013102457, -2.6642552504268946],
           [139.9995688809453, -2.5488413084834396],
           [140.07921983543994, -2.3677343285527304],
           [140.06823358805778, -2.329314547708212],
           [140.09020640950374, -2.1854847510356965],
           [140.1231655546508, -2.0345255557659154],
           [139.63448174799328, -1.9669377329328368],
           [139.49441008227905, -2.0918267724754664],
           [139.5314881643882, -2.116529138763426],
           [139.52736506429588, -2.1590732891643567],
           [139.4779267245694, -2.149467044103999],
           [139.44702752783493, -2.1364300548067074],
           [139.43123492792634, -2.1137861921821144],
           [139.45595566720115, -2.08359346232172],
           [139.48754244073766, -2.090454349328754],
           [139.54384696346003, -1.9923256158176599],
           [139.5246187017566, -1.9339977952593315],
           [139.36257072084962, -1.8543904470764119],
           [139.27742670959822, -2.0177183714923896],
           [139.24996091781156, -2.052028911291586],
           [139.2183752982711, -2.032815066888063],
           [139.22661505062067, -1.9998765582770235],
           [139.3158789203569, -1.8379195014091445],
           [139.15383091818813, -1.743208750439816],
           [139.1140055109585, -1.8022318777858688],
           [139.0453410146064, -1.9271349034216445],
           [139.03160811474413, -1.957329886529148],
           [139.00276905663648, -1.9573298729370465],
           [138.9835430281675, -1.9339974195429486],
           [138.99727592261027, -1.91340970740139],
           [139.03023484752666, -1.913409722828662],
           [139.11812540735292, -1.748699334409607],
           [138.91773994280973, -1.5812461623387108],
           [138.86504146035546, -1.676821768127756],
           [138.80204113775144, -1.7325886201906302],
           [138.71861290024526, -1.67047400566644],
           [138.68943055312397, -1.6172809060505622],
           [138.67535436102222, -1.4878959602114388],
           [138.80169701766204, -1.262741578012466],
           [138.6314091475644, -1.1419187033444245],
           [138.12603852128439, -0.9332130799140748],
           [137.35699635552635, -1.0485527089145301],
           [136.9944485474737, -1.5098621463199164],
           [136.86947954194483, -1.612818145966949],
           [136.98895568769177, -1.7157737768162993],
           [137.07409974041192, -1.824211687443526],
           [137.08783288063466, -1.8736240112529094],
           [137.05487379382166, -1.892840019458443],
           [137.00268881657726, -1.884604837618182],
           [136.8969455186693, -1.8338247953769289],
           [136.7307777778106, -1.9436237149937916],
           [136.40668192102845, -2.058910156772861],
           [136.10455880821428, -2.2016340367542937]]],
         [[[140.71373901908086, -2.519074775282059],
           [140.81673584525274, -2.393534125840512],
           [140.64782105033086, -2.3029730415497327],
           [140.511865239784, -2.2899372546960612],
           [140.41024170462774, -2.307775669833533],
           [140.35531006400274, -2.3516846576705537],
           [140.3745361382215, -2.41411536419168],
           [140.43221436087774, -2.4834032269293895]]],
         [[[141.01554161343432, -2.387859721554285],
           [140.81778770718432, -2.8103972628843534],
           [143.70169883999682, -3.8358778782129113],
           [144.47623497280932, -3.9893279430452173],
           [144.861104733211, -4.114675941761769],
           [144.99808555874682, -3.872872867174884],
           [144.57648521694995, -3.6796593376325206],
           [144.47552778474923, -3.593346729811558],
           [144.08072716030932, -3.5288961647240895],
           [143.73053795132495, -3.3493190968681943],
           [143.60693752278266, -3.490864395121523],
           [143.51767784390307, -3.431572330714073],
           [143.49059614019686, -3.412637628239037],
           [143.46711920932088, -3.403297989914695],
           [143.44535929714593, -3.397899047607604],
           [143.42566025255888, -3.3918146080873],
           [143.3956183987176, -3.3777633645023197],
           [143.4136420139484, -3.3458902334157075],
           [143.30962425503589, -3.2876246268176796],
           [143.21555382046557, -3.2293541220233344],
           [142.62228591753225, -3.0515008073622583],
           [142.5452147010249, -3.052256989853185],
           [142.52375977021381, -3.0948364536741915],
           [142.49474882336892, -3.1183889132894542],
           [142.50530539369186, -3.1493624488793324],
           [142.4980092648015, -3.1721086640064704],
           [142.4666499559995, -3.161155754741027],
           [142.45039778869068, -3.131005394371224],
           [142.46948817473128, -3.111787510014121],
           [142.4940711264162, -3.102168014898324],
           [142.5382918119067, -3.049447468494804],
           [142.49530847595784, -3.0296389838063837],
           [142.44401743960728, -3.020190317366411],
           [142.4159365767008, -3.0770604152104624],
           [142.4218444790445, -3.1137014765581057],
           [142.41134446803005, -3.125618030331904],
           [142.39741101603315, -3.1320494428617125],
           [142.3884272183513, -3.1284569050030293],
           [142.38871320960297, -3.1159511828595705],
           [142.43803684947088, -3.0189993360011136],
           [141.11991173062182, -2.3933481048259027]]],
         [[[145.21952800346358, -4.2738047138002],
           [145.20785502983077, -4.305301928527081],
           [145.24562053276046, -4.3981678926099725],
           [145.27995280815108, -4.395429393667492],
           [145.32115153861983, -4.405014095909013],
           [145.33767395566056, -4.411689210082155],
           [145.34956149650557, -4.40698236769878],
           [145.36852999193823, -4.434879814516641],
           [145.35411052299483, -4.441297919007947],
           [145.35814454404175, -4.44912781605429],
           [145.36475352836592, -4.447202429309091],
           [145.37131974775963, -4.43920148412537],
           [145.3854388307375, -4.440699112586922],
           [145.4168527562712, -4.458412311356147],
           [145.42505499768322, -4.479889606114662],
           [145.4325038877046, -4.487975519783595],
           [145.4455840002671, -4.486713220665236],
           [145.45426985631863, -4.490360341485443],
           [145.45591770358362, -4.498542421633423],
           [145.46867141018305, -4.527761992604998],
           [145.50022366735283, -4.557579367043024],
           [145.5944364507292, -4.678125161332891],
           [145.70567302299483, -4.5515075843828035],
           [145.47529899424939, -4.342791359648398],
           [145.3880950147572, -4.271581916429295],
           [145.30913078135876, -4.266103991729912]]],
         [[[145.6133541386202, -5.370215193785555],
           [145.6298336308077, -5.586204004849849],
           [145.85779993940145, -5.6067051817884765],
           [145.98551600385457, -5.471384228231634],
           [145.96628992963582, -5.331930621906449],
           [145.9319576542452, -5.225268206335136],
           [145.82166488984257, -5.211602215155205],
           [145.80887776375215, -5.205110192988256],
           [145.66416590619832, -5.237576342001267]]],
         [[[147.6394295424008, -6.575348731674722],
           [147.53780600724454, -6.5535201300551575],
           [146.9417977064633, -6.509860063645987],
           [146.76876303849454, -6.613546476096603],
           [146.7275643080258, -6.913567550664378],
           [146.8319344252133, -7.235196480466454],
           [147.2878670424008, -7.6845455744788485],
           [147.68200156388517, -7.921285558025248],
           [147.8914299826872, -7.6450335761539545],
           [147.7932381361508, -7.491245934917704],
           [147.6943611830258, -7.360515750107844],
           [147.8207039564633, -6.889027412822765],
           [147.70809409318204, -6.594447971880935]]],
         [[[149.81287598377014, -9.759604790651878],
           [149.60550904041077, -9.752837640550407],
           [149.61649536853577, -9.926033168752364],
           [149.61512207752014, -10.366723373189567],
           [149.61939415201212, -10.42549656293051],
           [149.69775615974652, -10.442722973453531],
           [149.73487565213944, -10.372312060934986],
           [149.79533110499034, -10.378887446325564],
           [149.84786256143937, -10.489024044005982],
           [149.85939776293532, -10.517380249720935],
           [149.89840077160318, -10.513328348413188],
           [150.0774910875286, -10.587905093132598],
           [150.30382752185608, -10.354565274760462],
           [150.39171814685608, -10.293092127730384],
           [150.4418432689264, -10.249175398193326],
           [150.51188111072327, -10.141046796732594],
           [150.40476441150452, -10.07615208629753],
           [150.14246582752014, -9.954439356985928],
           [149.9859106517389, -9.913858333176595],
           [149.86368775134827, -9.793438477225978]]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
///////////////////////////////
// Coral atlas mapping project - PNG_Solomons region 
// Contact: mitchell.lyons@gmail.com
// Region coordinator: Chris Roelfsema (chris.m.roelfsema@gmail.com)
// Description:
// - Developing a process to combine OBIA and supervised classification 
// - This script generates the data as an asset (for quick load)
// - Corresponding '_classification' script performs the machine learning classificaiton
///////////////////////////////

// Need to load the segmentation package
// https://earthengine.googlesource.com/users/gena/packages/+/master/slic#
// TODO: need to modify the source code to be able to use 2 bands?
// var Slic = require('users/mitchest/global_reefs:Modules/slic').Slic
// load analysis params module
var param_module = require('users/mitchest/global_reefs:Modules/reef_params')

// ###########################################
// SENSOR GENERICS
var sensor_params = param_module.dove         //<------------ THIS IS WHERE YOU CHOOSE THE SENSOR
// REGION AND SENSOR SPECIFIC LOAD PATHS
var region_params = param_module.png_solomons       //<------------ THIS IS WHERE YOU CHOOSE THE REGION
//  ^^ all the data paths are in this module ^^
// ###########################################


// Table of contents
// 1. Setting constants
// 2. Data loads & vis
// 3. Segmentation and metrics calculation
// 4. Export data to asset

// 1. Setting constants

// These will get written to the asset metadata 

var vars = {
  // OBIA settings
  pixel_based: true, // if true the metrics and output will simply be pixels (i.e. no segmentation)
  scale_factor: 20, // segment size (0 - Inf) - need to play around [~8-15 for SLIC; ~ 20 for SNIC]
  compactness: 10, // trades off color-similarity and proximity - small = more sensitive to 'colour' (a bit black box) [~800-1000 for SLIC; ~10 for SNIC]
  //segment_iters: 3, // number of (SLIC) segmentation iterations
  //segment_max: 1499, // must be <reduce_max below (~1500 at this point seems fair)
  reduce_max: 1500, // the max size of object to be able to reduce
  //segment_compactness: 0.7, // higher the number, the more compact (square) objects are
  segment_all_bands: true, // segement on all input bands or those chosen below
  segment_bands: (sensor_params.sname == 'dove') ? ['b1','b2','b3'] : ['B2','B3','B4'], // only handles Landsat/Sentinel-2/Dove
  
  // analysis parameters
  //image_data_scale: sensor_params.pixel, // pixel size of the image data
  //depth_limit: 15.00,//RB: make the right depth limit as S2 depth is not *100 as dove?
  depth_limit: 2500, // depth limit for analysis in cm 
  min_depth: 0, // the minimum valid depth (also allows use of bathy/topo layers)
  all_bands: (sensor_params.sname == 'dove') ? ['b1','b2','b3','b4'] : ['B1','B2','B3','B4','B5'], // only handles Landsat/Sentinel-2/Dove
  red_band: (sensor_params.sname == 'dove') ? 'b3' : 'B4', // only handles Landsat/Sentinel-2/Dove
  green_band: (sensor_params.sname == 'dove') ? 'b2' : 'B3', // only handles Landsat/Sentinel-2/Dove
  blue_band: (sensor_params.sname == 'dove') ? 'b1' : 'B2', // only handles Landsat/Sentinel-2/Dove
  nir_band: (sensor_params.sname == 'dove') ? 'b4' : 'B5', // doesn't handle the Landsat-8/Sentinel-2 difference
  use_glcm: true, // use glcm metrics
  small_object: 400, // the smallest size a group of image pixels should be to not be considered noise
  
  // use relative band brightness as predictor variables (instead of Rrs values)?
  use_brightness: false,
  
  // use global reef mask layer to remove junk + limit size
  global_mask: false,
  
  // export options
  do_export: true, // export the results?
  export_scale: sensor_params.pixel, // pixel size to export at
  segments_output_name: region_params.sname + '_'+ 'segmentation',
  pixels_output_name: region_params.sname + '_' + 'pixels',
  asset_output: region_params.asset // asset path
}

var output_name = (vars.pixel_based) ? vars.pixels_output_name : vars.segments_output_name // export file path/name



// 2. Data loads & vis

Map.centerObject(map_centre, 6)

// load input data
var reflec = ee.Image(region_params.image).select(vars.all_bands)

/* 
// import depth data
Depth data used as follows:
    - take mean where ls8 and sentinel2 exist
    - use s2 flags where no ls8, and vica verca
    - use dove where no s2 or ls8 data exist

NB depth is 16bit s integer in centimeters)
*/
var dove_depth = ee.Image(region_params.depth).rename('depth')
var s2_depth = ee.Image(region_params.s2_depth).rename('depth')
var ls8_depth = ee.Image(region_params.ls8_depth).rename('depth')
Map.addLayer(dove_depth, {bands: ['depth'], min: vars.min_depth, max: vars.depth_limit, palette:['#9ecae1','#6baed6','#4292c6','#2171b5','#08519c','#08306b']}, "Dove depth (cm)", false) // water depth
Map.addLayer(s2_depth, {bands: ['depth'], min: vars.min_depth, max: vars.depth_limit, palette:['#9ecae1','#6baed6','#4292c6','#2171b5','#08519c','#08306b']}, "Sentinel-2 depth (cm)", false) // water depth
Map.addLayer(ls8_depth, {bands: ['depth'], min: vars.min_depth, max: vars.depth_limit, palette:['#9ecae1','#6baed6','#4292c6','#2171b5','#08519c','#08306b']}, "Landsat 8 depth (cm)", false) // water depth

// make the depth data for modelling/mapping
// --> Use S2 where possible, then LS8, then Dove
// --> The GEE mosaic algorithm uses the LAST non-masked pixel in the stack 
var depth = ee.ImageCollection([dove_depth, ls8_depth, s2_depth]).mosaic()
// get back the negative retrievals as very shallow
depth = depth.where(depth.eq(-1), 10) // handle "too shallow" retrievals

// define a mask based on min/max depth
var depth_mask = depth.lt(vars.depth_limit).and(depth.gt(vars.min_depth)).and(reflec.select(0).gt(0))//.updateMask(waves)

// "NOT REEF" CLEAN
var not_reef_img = ee.Image().byte().paint(ee.Feature(noReef_mask, {zone: 1}), "zone");
// remove
depth_mask = depth_mask.where({
  test: not_reef_img.eq(1),
  value: ee.Image(0)
});

/*// "TURBID WATER" CLEAN
var tmask = ee.FeatureCollection(region_params.turbid_mask).geometry();
var tmask_img = ee.Image().byte().paint(ee.Feature(tmask, {zone: 1}), "zone");
// remove
depth_mask = depth_mask.where({
  test: tmask_img.eq(1),
  value: ee.Image(0)
});*/

// clip and load other variables
var depth = depth.updateMask(depth_mask).int16().rename('depth'); // mask out depth below set limit

//var waves = waves.rename('waves')
//var waves = ee.Image(region_params.waves).unmask(0)
//var geomorph = ee.FeatureCollection(region_params.geo_train)
//var benthic = ee.FeatureCollection(region_params.benthic_train)

// define it if it's a normal shape, otherwise draw it
//var export_geom = ee.Geometry.Rectangle(-168.034,-24.0093,162.7417,-7.3087)
var export_geom = depth_mask.gt(0).reduceToVectors({scale: 1000, maxPixels: 1e13, bestEffort: true, geometry: region_extent, crs: "EPSG:4326"}).geometry().convexHull({maxError: 100});

Map.addLayer(reflec, {bands: ['b3','b2','b1'], min: 0, max: 3000}, sensor_params.sname, false); // image data
Map.addLayer(depth, {bands: ['depth'], min: vars.min_depth, max: vars.depth_limit, palette:['#9ecae1','#6baed6','#4292c6','#2171b5','#08519c','#08306b']}, "Depth covariate (cm)", false); // water depth
//Map.addLayer(tmask,{}, "turbid mask", false);
//Map.addLayer(waves, {min:0, max:2, palette:['#fee5d9','#fcbba1','#fc9272','#fb6a4a','#ef3b2c','#cb181d','#99000d']}, "Sig. wave height (modelled)", false) // significant wave height (modelled)

// add in global bathy if using
if (vars.global_mask) {
  /*// manual touch-ups if needed
  var manual_adds = manual_mask_additions.reduceToImage(['mask'],ee.Reducer.first()).unmask(0)
  print(manual_adds)
  global_mask = global_mask.unmask(0).add(manual_adds).selfMask().clip(export_geom)*/
  // mask the depth mask with global mask
  global_mask = global_mask.clip(export_geom)
  depth_mask = depth_mask.updateMask(global_mask)
  Map.addLayer(global_mask, {min:0, max:1}, 'global reef mask', false)
}


/*
// TESTING DEPTH IMPORVEMENTS // ################################################### //

Map.addLayer(depth, {min:0,max:5}, "raw depth", false)
Map.addLayer(depth.focal_min({radius: 5, kernelType: 'octagon'}).updateMask(depth.gt(0)), {min:0,max:5}, "smooth depth", false)

// TESTING OUTLINE EXTRACTION // ################################################### //

var rbratio = reflec.select('b3').divide(reflec.select('b1')) // get reef area + land
var nir_ratio = reflec.select('b4').divide(reflec.select('b1')) // mask out land
var b_bright = reflec.expression(' B / (B + G + R)', {
  'B': reflec.select('b1'),
  'G': reflec.select('b2'),
  'R': reflec.select('b3')
})
var g_bright = reflec.expression(' G / (B + G + R)', {
  'B': reflec.select('b1'),
  'G': reflec.select('b2'),
  'R': reflec.select('b3')
})
var r_bright = reflec.expression(' R / (B + G + R)', {
  'B': reflec.select('b1'),
  'G': reflec.select('b2'),
  'R': reflec.select('b3')
})

var ratio_bright = reflec.select('b3').divide(reflec.select('b1'))
                    .multiply(reflec.select('b2').divide(reflec.select('b3')))
                    .multiply(reflec.select('b2').divide(reflec.select('b1')))
      

var depth_bbri = depth.multiply(b_bright)
var depth_rb = depth.multiply(rbratio)
var bbri_rb = b_bright.multiply(rbratio)

Map.addLayer(rbratio, {palette:['#f7fbff','#deebf7','#c6dbef','#9ecae1','#6baed6','#4292c6','#2171b5','#08519c','#08306b']}, "rb ratio", false)
Map.addLayer(b_bright, {palette:['#f7fbff','#deebf7','#c6dbef','#9ecae1','#6baed6','#4292c6','#2171b5','#08519c','#08306b']}, "b bright", false)
Map.addLayer(bbri_rb, {palette:['#f7fbff','#deebf7','#c6dbef','#9ecae1','#6baed6','#4292c6','#2171b5','#08519c','#08306b']}, "b bright + rb", false)
Map.addLayer(depth_bbri, {palette:['#8e0152','#c51b7d','#de77ae','#f1b6da','#fde0ef','#f7f7f7','#e6f5d0','#b8e186','#7fbc41','#4d9221','#276419']}, "depth + b bright", false)
Map.addLayer(depth_rb, {palette:['#67001f','#b2182b','#d6604d','#f4a582','#fddbc7','#f7f7f7','#d1e5f0','#92c5de','#4393c3','#2166ac','#053061']}, "depth + rb ratio", false)
Map.addLayer(ratio_bright, {palette:['#8e0152','#c51b7d','#de77ae','#f1b6da','#fde0ef','#f7f7f7','#e6f5d0','#b8e186','#7fbc41','#4d9221','#276419']}, "rgb brightness", false)

Map.addLayer(depth.lt(3).selfMask(), {palette:'4eb3d3'}, "3m depth mask", false)
Map.addLayer(rbratio.gt(0.4).selfMask(), {palette:'feb24c'}, "rb ratio mask", false)
Map.addLayer(depth_bbri.lt(5).selfMask(), {palette:'bf812d'}, "dix ratio mask", false)

Map.addLayer(nir_ratio.gt(1).selfMask(), {palette:'e5f5e0'}, "nir ratio mask", false)

// END TESTING // ################################################### //
 */


// 3. Segmentation and metrics calculation

// replace the band values with relatvie brightness values if set
if (vars.use_brightness) {
  reflec = reflec
    .addBands({overwrite: true, srcImg:
    reflec.expression(' B / (B + G + R)', {
      'B': reflec.select(vars.blue_band),
      'G': reflec.select(vars.green_band),
      'R': reflec.select(vars.red_band) }).rename(vars.blue_band).multiply(10000).int16()})
    .addBands({overwrite: true, srcImg:
    reflec.expression(' G / (B + G + R)', {
      'B': reflec.select(vars.blue_band),
      'G': reflec.select(vars.green_band),
      'R': reflec.select(vars.red_band) }).rename(vars.green_band).multiply(10000).int16()})
    .addBands({overwrite: true, srcImg:
    reflec.expression(' R / (B + G + R)', {
      'B': reflec.select(vars.blue_band),
      'G': reflec.select(vars.green_band),
      'R': reflec.select(vars.red_band) }).rename(vars.red_band).multiply(10000).int16()})
    .addBands({overwrite: true, srcImg:
    reflec.expression(' N / (B + G + R + N)', {
      'B': reflec.select(vars.blue_band),
      'G': reflec.select(vars.green_band),
      'R': reflec.select(vars.red_band),
      'N': reflec.select(vars.nir_band)}).rename(vars.nir_band).multiply(10000).int16()})
}

// calculate slope
var slope = ee.Terrain.slope(depth) // slope in degress


if (vars.use_glcm) {
  // glcm texture (mixed usefulness - will vary with image quality and type)
  var depth_glcm = depth.int16().glcmTexture().select(['depth_ent']).focal_max(5).rename('depth_maxent').multiply(100).int16() // maximum neighbourhood glcm entropy on depth
  var blue_glcm = reflec.select(vars.blue_band).int16().glcmTexture().select([vars.blue_band+'_savg']).focal_median(5).int16()
  var green_glcm = reflec.select(vars.green_band).int16().glcmTexture().select([vars.green_band+'_savg']).focal_median(5).int16()
}

// local variance in depth and red reflectance (5 pixels)
var depth_var = depth.reduceNeighborhood({reducer: ee.Reducer.stdDev(), kernel: ee.Kernel.circle(5)}).rename('depth_stdDev').multiply(10).int16()
var red_var = reflec.select(vars.red_band).reduceNeighborhood({reducer: ee.Reducer.stdDev(), kernel: ee.Kernel.circle(5)}).rename('red_stdDev').multiply(10).int16()

// segmentation functions

// ***SNIC segmentation***
  var run_snic = function(bands) {
    return(
    ee.Algorithms.Image.Segmentation.SNIC({
    image: bands,
    seeds: ee.Algorithms.Image.Segmentation.seedGrid(vars.scale_factor, "hex"),
    //size: 1000,
    neighborhoodSize: vars.scale_factor*2,
    compactness: vars.compactness,
    connectivity: 4
    })
    )
  }
  
  // ***SLIC segmentation***
  /*
  segment_on = segment_on.rename(['v1','v2','v3'])
  var slic = new Slic(segment_on, vars.scale_factor, false)
  slic.compactness = vars.compactness
  var segmentation = slic.iterate(vars.segment_iters)
  var segmented_data = segmentation.image.select('label').rename('clusters').int32()
  Map.addLayer(segmented_data.randomVisualizer(), {}, "Slic labels", false)
  */
  
  
  // ***k-means segmentation***
  /*
  var segmented_data = ee.Algorithms.Image.Segmentation.KMeans({
    image: reflec.select(['b2']).addBands(depth), //all_data.select(segment_bands),
    numClusters: segment_size,
    numIterations: 10,
    //neighborhoodSize: 100
    gridSize: segment_max
  })
  Map.addLayer({eeObject: segmented_data, shown: false, name: "Segmentation algorithm segments"})
  */


// calculate pixel or object data
if (vars.pixel_based) {
  // pixel-based data generation
  // combine data to move forward with
  var all_data = reflec.addBands(depth).addBands(slope)//.addBands(waves)
                  .addBands(depth_var).addBands(red_var)
                  .updateMask(depth_mask) // make sure all layers are clipped down
  if (vars.use_glcm) { // add glcm if using
    all_data = all_data.addBands(depth_glcm).addBands(blue_glcm).addBands(green_glcm).updateMask(depth_mask)
  }
  
} else {
  //// OBIA data generation
  
  if (vars.segment_all_bands) { 
    // do the segmentation on all input bands (internal GEE mean calcs seem to be faster)
    var segmented_data_mean = run_snic(reflec
                                       .addBands(depth)
                                       .addBands(slope)//.addBands(waves)
                                       .updateMask(depth_mask)
                                       )
                                       .regexpRename('_mean', '')
    Map.addLayer(segmented_data_mean.randomVisualizer().reproject(ee.Projection('EPSG:4326').atScale(sensor_params.pixel)), {}, "SNIC clusters", false)
    // remove the cluster band - index starts at 0
    segmented_data_mean = segmented_data_mean.select(ee.List.sequence(1, segmented_data_mean.bandNames().length().subtract(1)))
    segmented_data_mean = segmented_data_mean.cast(ee.Dictionary.fromLists(segmented_data_mean.bandNames(), ee.List.repeat('int16', segmented_data_mean.bandNames().length())))
    
  } else {
    // segment on the bands specified by var segment_on
    var segment_on = reflec.select(vars.segment_bands)//.addBands(depth.multiply(100)) // which data to segment on (transform depth so it's on a similar scale - may help numerically)
                         .updateMask(depth_mask)
    var segmented_data = run_snic(segment_on)
    Map.addLayer(segmented_data.randomVisualizer().reproject(ee.Projection('EPSG:4326').atScale(sensor_params.pixel)), {}, "SNIC clusters", false)
    // Calculate object statistics
    var segmented_data_mean = reflec.addBands(depth).addBands(slope)//.addBands(waves)
                              //.addBands(depth_glcm).addBands(blue_glcm).addBands(green_glcm)
                              //.addBands(depth_var).addBands(red_var)
                              .addBands(segmented_data.select('clusters'))
                              .reduceConnectedComponents(ee.Reducer.mean(), 'clusters', vars.reduce_max) // need to be mindful that really big objects may make this fall over
    segmented_data_mean = segmented_data_mean.cast(ee.Dictionary.fromLists(segmented_data_mean.bandNames(), ee.List.repeat('int16', segmented_data_mean.bandNames().length())))
    
  /*
  // For this analysis anyway, SD has not come up as adding much useful info
  // Looks like you can also use .combine - and do both mean and SD in one reduction??
  var segmented_data_sd = reflec.addBands(depth).addBands(waves).addBands(slope)//.addBands(depth_glcm)
                          .addBands(segmented_data.select('clusters'))
                          .reduceConnectedComponents(ee.Reducer.stdDev(), "clusters", vars.reduce_max)
                          //.rename(['b1_sd','b2_sd','b3_sd','b4_sd','b5_sd','depth_mean','waves_sd','slope_sd','depth_corr_sd','depth_var_sd','depth_idm_sd'])
  */
  }
  
  // combine data to move forward with
  var all_data = segmented_data_mean
                 //.addBands(segmented_data_sd)
                 //.addBands(depth_var).addBands(red_var)
                 .updateMask(depth_mask)
  //Map.addLayer(all_data.reproject(ee.Projection('EPSG:4326').atScale(sensor_params.pixel)), {bands: ['b3','b2','b1'], min: 95, max: 3000}, "Segmented image/predictor data (OBIA)", false) 
}




// Add any extra indices needed

all_data = all_data
              .addBands(all_data.select(vars.red_band).divide(all_data.select(vars.blue_band)).multiply(1000).int16().rename('rb'))
              .addBands(all_data.select(vars.green_band).divide(all_data.select(vars.blue_band)).multiply(1000).int16().rename('gb'))
              .addBands(all_data.select(vars.red_band).divide(all_data.select(vars.green_band)).multiply(1000).int16().rename('rg'))

// clean up noise
all_data = all_data.updateMask(depth_mask.selfMask().connectedPixelCount(vars.small_object, false).gte(vars.small_object))
Map.addLayer(all_data, {}, "Model predictor data", false)
// add noReef_mask to viewer - check for slivers between polys
Map.addLayer(not_reef_img, {}, "noReef_mask", false);


/*
####### SOME POSSIBLY FUTURE USEFUL JUNK ######

//all_data.select('b1_1','b2_1','b3_1','b4_1','b5_1').reduce('sum').aside(Map.addLayer, {}, "sd_sum", false)
//all_data.select('b3','b4','waves','slope','depth').spectralGradient().aside(Map.addLayer, {}, "SAM", false)

// export data to guide threshold development
var geomorphic_sample = all_data.sampleRegions({
  collection: geomorph,
  properties: ['Class_na_1'],
  scale: vars.image_data_scale
})

Export.table.toDrive({
    collection: geomorphic_sample,
    description: 'geomorphic_object_sample',
    folder: output_folder,
    fileFormat: 'CSV'
  })
*/


// 4. Export data to asset

// export if specified in input params
if (vars.do_export) {
  Map.addLayer(export_geom, {}, "export geometry", false);
  
  Export.image.toAsset({
    image: all_data,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    scale: vars.export_scale,
    region: export_geom,
    maxPixels: 1e13,
    pyramidingPolicy:{'.default': 'mean'},
  });
  
  /*
  
  // add raster flag for either side of dateline
  var latlong = ee.Image.pixelLonLat().select('longitude').clip(export_geom)
  var export_stack_east = all_data.updateMask(depth_mask).set(vars).updateMask(latlong.lte(0))
  var export_stack_west = all_data.updateMask(depth_mask).set(vars).updateMask(latlong.gt(0))
  
  var export_geom_east = ee.Geometry.Rectangle(-179.99998,-24.0093,-168.034,-8.081)
  var export_geom_west = ee.Geometry.Rectangle(162.7417,-23.0584,179.99998,-7.3087)
  
  Map.addLayer(export_geom_east, {}, "export footprint east", true)
  Map.addLayer(export_geom_west, {}, "export footprint west", true)
  
  Export.image.toAsset({
    image: export_stack_east,
    description: output_name + '_east',
    assetId: vars.asset_output + 'in_out/' + output_name + '_east',
    scale: vars.export_scale,
    region: export_geom_east,
    maxPixels: 1e13,
    pyramidingPolicy:{'.default': 'mean'},
  })
  
  Export.image.toAsset({
    image: export_stack_west,
    description: output_name + '_west',
    assetId: vars.asset_output + 'in_out/' + output_name + '_west',
    scale: vars.export_scale,
    region: export_geom_west,
    maxPixels: 1e13,
    pyramidingPolicy:{'.default': 'mean'},
  })
  
  */
  
}