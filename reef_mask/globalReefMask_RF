/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var wcmcReefs = ee.FeatureCollection("users/murrnick/global-reefs/existingData/WCMC008_CoralReefs2010_v3"),
    GBR_Test = /* color: #d63000 */ee.Geometry.Polygon(
        [[[154.50264257962965, -29.360860757263083],
          [154.36020071778967, -21.291356296671434],
          [153.46233819978193, -15.33226682962104],
          [146.8212707506558, -7.614568390671287],
          [142.38338949392414, -6.178371431738409],
          [140.8740543169929, -11.16707855305966],
          [152.77164350655664, -29.896770255364927]]]),
    lsFootprint = ee.FeatureCollection("projects/coral_atlas/reefMask/globalLandsatFootprint"),
    ls8 = ee.Image("projects/remap-app/ls_8_cflte1_2k16to19_at_30m_ui8"),
    trainingData = ee.FeatureCollection("projects/coral_atlas/reefMask/reefMaskTrainingData_v3");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
////////////////////////////////////
// Global Reef Classification
// August 2018
// n.murray@unsw.edu.au
////////////////////////////////////

////////////////////////////////////
// 00. Global Variables
////////////////////////////////////


var lsFootprint = infraRoads.map(
  function(f) {
  return f.buffer(-6000); // 3km width
}).union(); 
var aoi = lsFootprint;
Map.addLayer(aoi, {color: 'red'}, 'aoi', false);
Map.centerObject(aoi);
var lsVis = {min: 0, max: 128, bands: ['Red', 'Green', 'Blue']};
Map.addLayer(ls8, lsVis, 'Landsat 8 At-surface', true) ;

//Map.setCenter(12.0087, -4.5343, 12);

var globOptions = { 
  versionID: '_v3', //file name prefix
  outFolder: 'reefsOut',
  mapDebug: false, // set to true to add all layers of the map
  startDate: '2016-0-01',
  endDate: '2019-01-01',
  parallelScale: 8, // A scaling factor used to limit memory use; using a larger parallelScale (e.g. 2 or 4) may enable computations that run out of memory with the default.
  trainingValidationRatio: 0.01, // training vs validation
  nTrees: 10, 
  outScale: 500, //resolution in metres
  conPixels: 4, // set min patch size (10 ~ 1 ha, 100 ~ 9ha @ 30m Landsat scale). 3 = 0.27ha 6 = 0.54ha 9 = 0.81ha
  classifyClean: false, //remove patches smaller than x connected pixels if true
  numPoints: 100, // size of training set per class
  samplePredictorData: true,
  maskAltitude: 100,  
  maskDepth: -1000, 
  maskDistance: 100000,
};
Map.setOptions('SATELLITE');
////////////////////////////////////


////////////////////////////////////
// 0. Functions
////////////////////////////////////

var landsatFunctions = {
  
  applyNDWI: function(image) {
    // apply NDWI to an image
    var ndwi = image.normalizedDifference(['Green','NIR']);
    return ndwi.select([0], ['ndwi']);
  },

  applyNDVI: function(image) {
    // apply NDVI to an image
    var ndvi = image.normalizedDifference(['NIR','Red']);
    return ndvi.select([0], ['ndvi']);
  },
  
  applyEVI: function(image) {
    var evi = image.expression("2.5*(b('NIR')-b('Red'))/(b('NIR')+6*b('Red') - 7.5*b('Blue') + 1)");
    return evi.select([0], ['evi']);
  }
};

function samplePredictors(feature) {
    // sample training composite for predictor data
    var predictorData = trainComposite.reduceRegion({
    reducer: ee.Reducer.first(), // mean and first return the same
    geometry: feature.geometry(),
    scale: 1}); //1m sample = <1 pixel
    return feature.set(predictorData);
 }

////////////////////////////////////
// 1. Data Imports and Processing
////////////////////////////////////


var collection = ls8
print (collection);

// TODO: add band metrics
// Data processing to final predictors
var covariates = {
    redBand: collection.select(['Red']),
    blueBand: collection.select(['Blue']),
    greenBand: collection.select(['Green']),
    nirBand: collection.select(['NIR'])
};

var trainComposite1 = covariates.nirBand
    .addBands(covariates.redBand)
    .addBands(covariates.blueBand)
    .addBands(covariates.greenBand);

// Mithc: Landsat 8 – Bands 1-4, maybe 5 if there’s trouble with land classification
// // MODIS
// var modis = ee.ImageCollection('MODIS/006/MYD09A1') //MYD09A1.006 Aqua Surface Reflectance 8-Day Global 500m
//   .select('sur_refl_b01', 'sur_refl_b03', 'sur_refl_b04')
//   .median()
//   .mask(ls8.select('NIR')); // mask to LS8

var coastMask = ee.FeatureCollection('ft:1Hsoe_WwULJ23Nuj1wikGzfH_WQMtpDWOR3XpWkHk') // Natural Earth coastline
    .distance(globOptions.maskDistance).gte(-200); 
var topoMask = ee.Image('NOAA/NGDC/ETOPO1')
    .select(['bedrock'], ['etopo'])
    .gte(globOptions.maskDepth)
    .and(ee.Image('NOAA/NGDC/ETOPO1').lte(globOptions.maskAltitude));
var topoMask = topoMask.updateMask(topoMask).clip(aoi).select('bedrock');
Map.addLayer(topoMask);

// Add a training image
var trainVectors = trainingData.reduceToImage({
    properties: ['CLASS'],
    reducer: ee.Reducer.first()
});

// FINAL MASK
var trainComposite = trainComposite1
  .addBands(ls8.normalizedDifference(['NIR', 'Red']).rename(['NDVI']))
  .addBands(ls8.normalizedDifference(['Green', 'NIR']).rename(['NDWI']))
  .addBands(ls8.select('Blue').divide(ls8.select('NIR')).rename(['WBI']))
  .addBands(ls8.select('Blue').subtract(ls8.select('Red')).rename(['BR']))
  .addBands(ls8.normalizedDifference(['Blue', 'Green']).rename(['BG']))
  .addBands (ee.Image('NOAA/NGDC/ETOPO1')
    .select(['bedrock'], ['etopo']))
  //.addBands(trainVectors.rename('training'))
 // .addBands(modis) // remove this line to run more quickly
  .clip(aoi);
//var bands = trainComposite.select([1,2,3,4,5,6,7,8,9,10,11,12]).bandNames().aside(print); // with modis
//var bands = trainComposite.select([1,2,3,4,5,6,7,8,9]).bandNames().aside(print); // without modis (Landsat Only)
//var bandList = ee.List.sequence(0, 84, 1);
var bands = trainComposite.bandNames().aside(print); // bands used in classification


////////////////////////////////////
// 2. Training Data
////////////////////////////////////

// Training points
var randomPoints = trainingData.filterBounds(aoi)

// Sample the Classifier
var predictorSet = randomPoints.map(samplePredictors)
print (predictorSet.limit(10), 'predictorSet')
var trainingSet = predictorSet.filter(ee.Filter.neq('CLASS', null)) //handle null data points;

////////////////////////////////////
// 3. Run the Classification 
////////////////////////////////////

// Train a classifier
var classifier = ee.Classifier.randomForest({
    numberOfTrees: globOptions.nTrees, 
    variablesPerSplit: 0, // 0 is the default: sqrt of nPredictors 
    bagFraction: 0.5,
    seed: 0})
  .train(trainingSet, 'CLASS', bands)
  .setOutputMode('CLASSIFICATION');

// Classify the composite image
var classified = trainComposite.select(bands)
  .mask(topoMask)
  .classify(classifier);
var finalOut = classified
  .clip(aoi);

  
////////////////////////////////////
// 4. Postprocess
////////////////////////////////////
  
// Postprocessing
if (globOptions.classifyClean) {
  var finalOut = finalOut.mask(finalOut
  .connectedPixelCount(globOptions.conPixels)
  .gte(globOptions.conPixels)); 
  var clean = 'CP'.concat(globOptions.conPixels); // connected pixel 100 (@30m = 9 ha)
} else {clean = 'CP00';} // connected pixel zero


// focal_mode = excellent!
//var finalOutPost = finalOut2.focal_mode({kernel: ee.Kernel.chebyshev(globOptions.kernelSize, "meters")}); // use a chebyshev kernel


////////////////////////////////////
// 6. Export final classifications
////////////////////////////////////

// METADATA
// Batch mode
// File naming
var fileName = 'reefMask_gen2_'
  .concat('S') //scale 
  .concat(globOptions.outScale)
  .concat(globOptions.versionID);
print(fileName);

// Gather metadata
var metaData = ee.Feature(null, {
  fileName: fileName,
  filePath: 'uq-global-reefs/reefsOut'.concat(fileName), 
  globOptions: globOptions,
  nPredictors: bands.length(),
  predictorList: bands,
  nTrainingPoints: trainingSet.size(),
  nPoints: globOptions.numPoints,
  nPointsUsed:  trainingSet.size(),
  nPointsReef: trainingSet.filter(ee.Filter.eq('CLASS', 1)).size(),
  nPointsOcean: trainingSet.filter(ee.Filter.eq('CLASS', 2)).size(),
  nPointsShallow: trainingSet.filter(ee.Filter.eq('CLASS', 3)).size(),
  nPointsLand: trainingSet.filter(ee.Filter.eq('CLASS', 4)).size()
});

Export.table.toDrive({
  collection: ee.FeatureCollection(metaData), //
  description: 'exportMetaDataToDrive-'.concat(globOptions.versionID),
  folder: globOptions.outFolder,
  fileNamePrefix: 'reefsMETA'.concat(fileName),
  fileFormat: 'CSV'
});

// Export final classified image to asset
Export.image.toAsset({
  image: finalOut.set({
  fileName: fileName,
  filePath: 'uq-global-reefs/reefsOut'.concat(fileName), 
  globOptions: globOptions,
  nPredictors: bands.length(),
  predictorList: bands,
  nTrainingPoints: trainingSet.size(),
  nPoints: globOptions.numPoints,
  nPointsUsed:  trainingSet.size(),
  nPointsLand: trainingSet.filter(ee.Filter.eq('CLASS', 1)).size(),
  nPointsWater: trainingSet.filter(ee.Filter.eq('CLASS', 2)).size(),
  nPointsReef: trainingSet.filter(ee.Filter.eq('CLASS', 3)).size()
  }), 
  description: 'exportFinaltoAsset-'.concat(globOptions.versionID),
  assetId: 'global-reefs/reefOut/'.concat(fileName),
  scale: globOptions.outScale,
  region: aoi,
  maxPixels: 800000000000
});

/*
Export.image.toDrive({
  image: finalOut,
  description: 'exportFinaltoDrive-'.concat(globOptions.versionID),
  fileNamePrefix: 'reefMask'.concat(fileName).concat('_raw'),
  scale: globOptions.outScale,
  region: aoi,
  folder: globOptions.outFolder,
  maxPixels: 800000000000
});
*/

////////////////////////////////////////////


////////////////////////////////////////////
// 7. Debugging
if (globOptions.mapDebug) {
  print('Debug: adding data to map');
  //print('Image collection:', collection.size());
  print('Band names for training:', bands);
  Map.addLayer(aoi, {color:'ffffff'}, 'AOI');
  Map.addLayer(trainVectors.randomVisualizer(), null , 'Training vectors');
  print (randomPoints.limit(10), 'randomPoints');
  print (predictorSet.limit(10), 'predictorSet');
  print (trainingSet.limit(10), 'training set');
  Map.addLayer(trainingSet,{color:'ffeb00'}, 'Training Points');
  Map.addLayer(trainComposite,null, 'Train Composite');
  print (finalOut, 'final Out');
  Map.addLayer(finalOut.randomVisualizer(),null, 'Reef Mask Classified');
} else {print('Not debugging: running in batch mode')}







