/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var land_dist = ee.Image("projects/coral_atlas/global_datasets/mod44w6_global_distToLand"),
    imageVisParam = {"opacity":1,"bands":["depth"],"min":1500,"max":2500,"gamma":1},
    region_extent = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[75.50260244893565, 10.732564931074679],
          [75.50260244893565, 4.572761773416827],
          [85.19254385518565, 4.572761773416827],
          [85.19254385518565, 10.732564931074679]]], null, false),
    geometry = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry.MultiPoint(),
    rbl_sand = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[79.92260737118959, 8.576721817234404],
          [79.76741830765246, 8.5779475938491],
          [79.70424199477903, 8.257202171134733],
          [79.7365264385724, 7.974861777229614],
          [79.75798411069154, 7.970951729889293],
          [79.8009852175752, 7.9571815264655115],
          [79.8632125347638, 8.014810115596545]]]),
    cr_sand = /* color: #0b4a8b */ee.Geometry({
      "type": "GeometryCollection",
      "geometries": [
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                80.0552623148497,
                9.63458261388337
              ],
              [
                80.02779677097801,
                9.606149360029333
              ],
              [
                80.01543727602898,
                9.56417209819434
              ],
              [
                80.09646064516495,
                9.496455926713855
              ],
              [
                79.99621139182887,
                9.389437098959167
              ],
              [
                79.97628519684933,
                9.316427554793847
              ],
              [
                79.98897545618325,
                9.31320606795998
              ],
              [
                79.99684564607458,
                9.30642501203072
              ],
              [
                79.99919616389627,
                9.307769968474334
              ],
              [
                80.01659820778009,
                9.311475555451267
              ],
              [
                80.03320429114058,
                9.310754930069159
              ],
              [
                80.04053921693348,
                9.29326441835071
              ],
              [
                80.04650035455319,
                9.284582958327752
              ],
              [
                80.04484793780385,
                9.26935774787326
              ],
              [
                80.03037510899753,
                9.26708173556143
              ],
              [
                80.01573080450868,
                9.263280593852766
              ],
              [
                80.00642042561171,
                9.256377735855969
              ],
              [
                80.00826811747152,
                9.252693613425757
              ],
              [
                80.00393607814395,
                9.251042598475546
              ],
              [
                79.98659844504809,
                9.19699123313866
              ],
              [
                79.91793454404254,
                9.112932598725342
              ],
              [
                79.8341645809013,
                9.080388458476866
              ],
              [
                79.82180505942911,
                8.981381875072922
              ],
              [
                79.84240419581185,
                8.76971582780979
              ],
              [
                79.88497580538775,
                8.583729940449055
              ],
              [
                79.97149236702688,
                8.583729933626307
              ],
              [
                79.96599926646735,
                8.937973164367584
              ],
              [
                80.15963147148541,
                9.103440869017298
              ],
              [
                80.14315210285072,
                9.325751965981542
              ],
              [
                80.25164098906495,
                9.518126591883446
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                81.55660118563287,
                7.951027773861705
              ],
              [
                81.54977764589898,
                7.9502627230268645
              ],
              [
                81.54943432314508,
                7.943419704904614
              ],
              [
                81.5510221908819,
                7.940656963404746
              ],
              [
                81.55252422793023,
                7.93972187745708
              ],
              [
                81.55698742373102,
                7.9457573947324
              ],
              [
                81.55866112215631,
                7.950645248622619
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                81.69509197239512,
                7.759864346354133
              ],
              [
                81.69165874485606,
                7.757823268403707
              ],
              [
                81.70461917881602,
                7.743450397519851
              ],
              [
                81.7116572952711,
                7.727120860589004
              ],
              [
                81.71618492939791,
                7.733712117038444
              ],
              [
                81.71109951601288,
                7.742854869120384
              ],
              [
                81.70401836399668,
                7.753656036833729
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                81.27152542352076,
                8.50356790269685
              ],
              [
                81.27229789971705,
                8.495843096734578
              ],
              [
                81.27882103204126,
                8.477803795902942
              ],
              [
                81.28701786279078,
                8.47470519545497
              ],
              [
                81.29122356652613,
                8.480859925302711
              ],
              [
                81.2840137886941,
                8.501445718763954
              ],
              [
                81.27856353997583,
                8.500214846699075
              ],
              [
                81.27500156640406,
                8.502124818900958
              ],
              [
                81.27139667748804,
                8.503907451035563
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                81.19762236555584,
                8.580746801439602
              ],
              [
                81.19058424910077,
                8.569968165000322
              ],
              [
                81.18929678877362,
                8.545948530067946
              ],
              [
                81.19642073591717,
                8.534065465425702
              ],
              [
                81.222684926591,
                8.538818735690935
              ],
              [
                81.22551733931073,
                8.534235226097165
              ],
              [
                81.23272711714276,
                8.542044135368549
              ],
              [
                81.24088103254803,
                8.556048843856878
              ],
              [
                81.22508818586834,
                8.58006784124058
              ],
              [
                81.22062499006756,
                8.585329751023707
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                79.70237035677678,
                9.120485151123269
              ],
              [
                79.68520421908147,
                9.11590886219757
              ],
              [
                79.70202703402288,
                9.097772622180987
              ],
              [
                79.7253729812885,
                9.11031554053096
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                79.59782857821233,
                9.055394649349195
              ],
              [
                79.59542531893499,
                9.047257506155535
              ],
              [
                79.64709539339788,
                9.035560040467736
              ],
              [
                79.67164297030217,
                9.045731771315717
              ],
              [
                79.6565367691303,
                9.05624225784287
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                79.77489059528955,
                8.57776272695149
              ],
              [
                79.74811142048486,
                8.541775883600518
              ],
              [
                79.7666508491958,
                8.413417897436693
              ],
              [
                79.84698837360986,
                8.483374919593027
              ],
              [
                79.84973495564111,
                8.565541161750776
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                81.45311132956641,
                8.117815833480018
              ],
              [
                81.45122305441993,
                8.116753698981052
              ],
              [
                81.45165220786231,
                8.115861503831795
              ],
              [
                81.45190969992774,
                8.114501964556656
              ],
              [
                81.45860449362891,
                8.109616082325223
              ],
              [
                81.46259562064307,
                8.111018124171345
              ],
              [
                81.46276728202002,
                8.112377675231404
              ],
              [
                81.46160856772559,
                8.11225021751486
              ],
              [
                81.46225229037582,
                8.11437450567224
              ],
              [
                81.46469847251075,
                8.116158902435041
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                81.46731630850928,
                8.112377675231404
              ],
              [
                81.46628634024756,
                8.111442984371527
              ],
              [
                81.46620050955909,
                8.110848179965528
              ],
              [
                81.46637217093604,
                8.110210888554013
              ],
              [
                81.46761671591895,
                8.108978788960846
              ],
              [
                81.46907583762305,
                8.111485470366862
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                81.46794889700539,
                8.062250298314057
              ],
              [
                81.46451566946632,
                8.059530853599561
              ],
              [
                81.49232481253273,
                8.00547810625193
              ],
              [
                81.50863264334328,
                7.994258711153825
              ],
              [
                81.51326750052101,
                8.003098260368153
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                81.5187381629487,
                8.00082346476865
              ],
              [
                81.51985396822629,
                7.99910230904914
              ],
              [
                81.52255762858587,
                7.998146106596795
              ],
              [
                81.52298678202825,
                7.996021206646404
              ],
              [
                81.52169931901854,
                7.994533771201292
              ],
              [
                81.52071226878363,
                7.994023790599501
              ],
              [
                81.52298678202828,
                7.989688939159224
              ],
              [
                81.52946699900826,
                7.986629016308348
              ],
              [
                81.53307188792428,
                7.990368918900418
              ],
              [
                81.5320848350068,
                7.997083658005496
              ],
              [
                81.51966710491433,
                8.001624056078873
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                81.61394356036709,
                7.825544791124642
              ],
              [
                81.60776375079678,
                7.824864539630457
              ],
              [
                81.6055536105685,
                7.825502275438768
              ],
              [
                81.60456655765103,
                7.824184287026385
              ],
              [
                81.61201236987637,
                7.822760004542297
              ],
              [
                81.6152953937106,
                7.824460639780646
              ],
              [
                81.61503790164517,
                7.825417244054028
              ],
              [
                81.61432979846523,
                7.825821142977089
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                81.62368676306329,
                7.823821284775306
              ],
              [
                81.62366530539117,
                7.825011727140525
              ],
              [
                81.62310740591607,
                7.825947072328638
              ],
              [
                81.62220618368707,
                7.825564431368963
              ],
              [
                81.62212035299859,
                7.823906316485543
              ],
              [
                81.62602564932428,
                7.815764451600449
              ],
              [
                81.62793538214288,
                7.816402201320988
              ],
              [
                81.62411591650567,
                7.824161411512187
              ],
              [
                81.62364384771905,
                7.824947953528554
              ],
              [
                81.62362239004693,
                7.824246443153063
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                81.66223637856268,
                7.772172159791934
              ],
              [
                81.66335217751288,
                7.771321736762713
              ],
              [
                81.66824452675604,
                7.768047592018805
              ],
              [
                81.67124860085272,
                7.765623858040357
              ],
              [
                81.6806470612409,
                7.761074003868876
              ],
              [
                81.68759934700752,
                7.756524100454458
              ],
              [
                81.68978802956367,
                7.757161940348418
              ],
              [
                81.69081799782538,
                7.760308603000571
              ],
              [
                81.69407956398749,
                7.7628174117554565
              ],
              [
                81.68583981789374,
                7.768345242595824
              ],
              [
                81.67240731514715,
                7.768260199595343
              ],
              [
                81.66296593941473,
                7.773447791105413
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        }
      ],
      "coordinates": []
    }),
    refinement_maskb = /* color: #d63000 */ee.Geometry.MultiPolygon(
        [[[[78.72810782988012, 9.175697440235215],
           [78.72398795683324, 9.164512587397313],
           [78.72398795683324, 9.155022132970455],
           [78.7270778616184, 9.156377927691329],
           [78.72879447538793, 9.157055823112639],
           [78.73308600981176, 9.160614752861237],
           [78.73737754423558, 9.16027580870657],
           [78.74673302908077, 9.15942866127189],
           [78.76226844389379, 9.165020997444191],
           [78.7658733328098, 9.16874931554561],
           [78.75557365019262, 9.179425646162588]]],
         [[[78.70184363920629, 9.15942844690528],
           [78.70630683500707, 9.15519160759334],
           [78.70424689848363, 9.151632623549519],
           [78.70047034819066, 9.150615764423575],
           [78.6941188772434, 9.144853507809353],
           [78.72553290922582, 9.139430122245894],
           [78.72776450712621, 9.146209341289993],
           [78.71763648588598, 9.148751515142802],
           [78.72518958647191, 9.159089501618995]]],
         [[[78.79024924833715, 9.155700030977238],
           [78.73644070562017, 9.149259947733706],
           [78.72614102300298, 9.145022987276896],
           [78.72648434575689, 9.139769086263735],
           [78.78107266362798, 9.14587038340407],
           [78.79085736211431, 9.150954717788556]]],
         [[[78.64986072309318, 9.170661248433186],
           [78.64436755903068, 9.163204613237838],
           [78.617588384226, 9.154053074291001],
           [78.6201633048803, 9.147104526280202],
           [78.66273532636467, 9.14795191745071],
           [78.67303500898186, 9.169136040338715]]],
         [[[78.58417049021432, 9.130361377439677],
           [78.57121005625436, 9.121802211366553],
           [78.57395663828561, 9.115022528161603],
           [78.57713237375924, 9.113920817480945],
           [78.57902064890573, 9.118158147648217],
           [78.58159556956002, 9.118073401537682],
           [78.58176723093698, 9.114175058708906],
           [78.59189525217721, 9.114175058708906],
           [78.6131812629194, 9.105785002654027],
           [78.61146464914987, 9.129598687809738],
           [78.59283938975045, 9.13137829440809],
           [78.59013571688108, 9.136039152046916]]],
         [[[78.53622893298711, 9.109429192616108],
           [78.54627112353887, 9.105446006350093],
           [78.5476444145545, 9.093411429382142],
           [78.55545500720586, 9.100530523825107],
           [78.55511168445196, 9.110191925347205],
           [78.53588561023321, 9.11248011377076]]],
         [[[78.48970869983282, 9.105022260518131],
           [78.48953703845586, 9.094767458290159],
           [78.49614600146856, 9.09442845154477],
           [78.49311163237127, 9.104528721518662]]],
         [[[78.43192317492117, 9.122819588929374],
           [78.45355250841726, 9.094683142857628],
           [78.46316554552664, 9.112650044828303],
           [78.48221995836843, 9.108751642806022],
           [78.48908641344656, 9.126548349160586],
           [78.4834215880071, 9.123836527403135],
           [78.46814372545828, 9.130785529375355],
           [78.45578410631765, 9.12909066333172],
           [78.44771602160085, 9.125870395654054]]],
         [[[78.23640388265483, 8.965954444363522],
           [78.25013679281108, 8.966293571939772],
           [78.26318305745951, 8.956458743691815],
           [78.28103584066264, 9.001222013896692],
           [78.26970618978373, 9.007664756477476],
           [78.2425103770122, 8.990710572712466],
           [78.21497403259491, 8.970023954373348],
           [78.19677792663788, 8.94730194027783],
           [78.22132550354218, 8.930513869098167],
           [78.24398480529999, 8.927630991190373],
           [78.24638806457733, 8.94611493036819],
           [78.24844800110077, 8.959002259274811],
           [78.25067959900116, 8.964089237033447]]],
         [[[78.84188912274732, 9.186073913504954],
           [78.84034417035474, 9.153536132699372],
           [78.89355919721021, 9.153705608030567],
           [78.88892434003247, 9.18658229264903]]],
         [[[78.7939955985774, 9.187090671063611],
           [78.7888457572688, 9.164551861149933],
           [78.79777214887037, 9.164212920751831],
           [78.80103371503247, 9.18658229264903]]],
         [[[79.34998393964304, 9.26833292488229],
           [79.33384777020945, 9.269349445316527],
           [79.31633830976023, 9.26697755972526],
           [79.38671947431101, 9.204964021084875],
           [79.41315532636179, 9.184290420509434],
           [79.43409801435007, 9.214792030376515]]],
         [[[79.91955938795326, 9.03059789624071],
           [79.93466558912513, 9.029919761300707],
           [79.96487799146888, 9.028563487594226],
           [79.95423498609779, 9.061451685115646],
           [79.91551953166424, 9.049269073157891]]],
         [[[79.98129276910419, 6.509159979880881],
           [79.9493637529909, 6.501826069777664],
           [79.95520023980731, 6.469078004670235],
           [79.9713364092409, 6.475218428871058],
           [79.98112110772723, 6.469930845828564],
           [79.99468235650653, 6.483746671896751]]],
         [[[79.95829014459247, 6.4446555019362],
           [80.01030354180926, 6.353047633242966],
           [79.99391078678701, 6.396464040986011],
           [79.99227994102387, 6.408149548610523],
           [79.99099210757741, 6.418470602062808],
           [79.98918919244403, 6.42759755496179],
           [79.98824505930708, 6.431691500966625],
           [79.98609928765887, 6.435614861390316],
           [79.98369610597075, 6.438642621098139],
           [79.97906127587767, 6.444570195237711],
           [79.97288136163348, 6.451307945856616]]],
         [[[80.50277929200193, 5.933747750957681],
           [80.50921658075822, 5.93131467208262],
           [80.5440638402797, 5.922435996592228],
           [80.55281857050431, 5.935753956238905],
           [80.55196026361955, 5.937034512331777],
           [80.55127361990738, 5.938101641906718],
           [80.54887035883439, 5.938315065448325],
           [80.5458233660882, 5.938656553788795],
           [80.54277637995256, 5.937119882632149],
           [80.53930022575794, 5.936052761535842],
           [80.535652432809, 5.933619689471811],
           [80.53350666559709, 5.92883890193368],
           [80.5301592687465, 5.931229300883157],
           [80.52492359674943, 5.932339125445224],
           [80.51531061475708, 5.933790560722375],
           [80.502693448434, 5.935668585726911]]]]),
    cr_sg = /* color: #98ff00 */ee.Geometry.Polygon(
        [[[79.8426282997442, 8.471826709586955],
          [79.73963147357233, 8.386243928868836],
          [79.7162855263067, 7.925408142639621],
          [79.88245373919733, 7.932208955984822],
          [79.87833386615046, 8.44465962638692]]]),
    sand_cr = /* color: #0b4a8b */ee.Geometry.MultiPoint();
/***** End of imports. If edited, may not auto-convert in the playground. *****/
///////////////////////////////
// Global coral atlas project - SA
// Contact: mitchell.lyons@gmail.com
// Region coordinator: Rodney B (rodbio2008@gmail.com)
// Description:
// - Developing a process to combine OBIA and supervised classification
// - This script loads the raw classification data (from *_classification script)
// - Then applied some cleanup and object-based relational rules
///////////////////////////////

// Table of contents
// 1. Setting constants
// 2. Data loads & vis
// 3. OBIA clean up rules
// 4. Export

// Load and libraries needed
var map_palettes = require('users/mitchest/global_reefs:Modules/colour_pals');
var pkg_vis = require('users/mitchest/global_reefs:Modules/pkg_vis');
var param_module = require('users/mitchest/global_reefs:Modules/reef_params');

// ###########################################
// SENSOR GENERICS
var sensor_params = param_module.dove;         //<------------ THIS IS WHERE YOU CHOOSE THE SENSOR
// REGION AND SENSOR SPECIFIC LOAD PATHS
var region_params = param_module.south_asia;  //<------------ THIS IS WHERE YOU CHOOSE THE REGION
//  ^^ all the data paths are in this module ^^
// ###########################################

// 1. Setting constants

// These will get written to the asset metadata 

var vars = {
  
  // analysis type
  geomorphic: false, // map geomorphic zonation (when set to true) or benthic habitat (when set to false)

  // analysis parameters
  image_data_scale: sensor_params.pixel,
  small_object_geo: ee.Number(400).int(), // smallest object szie in pixels (geomorphic)
  small_object_benthic: ee.Number(130).int(), // smallest object szie in pixels (benthic)
  smooth_radius: ee.Number(3), // radius in pixels for initial smooth 
  dist_to_land: 1000, //distance to land in meters to disallow reef crest, and convert to terrestrial reef flat
  wave_height: 0.4, //cut off height for waves in metres, Hs95 threshold
  geo_depth_cutoff: 300, //depth in centimetres
  shallowlag_depth_cutoff: 400, //depth in centimetres
  benthic_depth_cutoff: 300, //depth in centimetres

  //############
  // Clean-up stage selection
  cleanup_stage: 2, // set to 1, 2 or 3
  geo_refinement: false, // set to true to apply the refinement_mask (the other stage 3 masks will still run)
  
  /*
  - GEOMORPHIC 1: The first pass does a small object filter, just to generally clean noise and reduce the amount of cleaning needed
  -            2: The second pass runs the OBIA cleanup rules
  -            3: The third pass is the MANUAL cleanup stage, which includes AT LEAST the no_reef masking
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY

  - BENTHIC 1: This is the main benthic stge - it does noise removal, no data reclaim and OBIA rules - review those if needed
            2: The second mas is the MANUAL stage - it's optional, but shuold include ALL region specific stuff
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY
  */
  
  // DON'T TOUCH --->
  obia_2nd_pass: null,
  obia_clean: null, // run object-based relationship rules + small object clean up
  fast_clean: null, // run a faster (but less precise) version of the OBIA clean; only applies to geomorphic (`obia_clean: true` also)
  manual_clean: false, // apply manual touch ups
  // --------------<
  //############
  
  reproject_display: true,
  
  // export options
  do_export: false, // export the results?
  geomorph_output_name: region_params.sname + '_geo_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  benthic_output_name: region_params.sname + '_benthic_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  asset_output: region_params.asset // asset path

};


// Clean up stage auto-parameterisation (DON'T TOUCH) --->

if (vars.geomorphic) {
  var temp_outname = vars.geomorph_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.obia_2nd_pass = true;
    vars.obia_clean = true;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '2';
  } else if (vars.cleanup_stage == 3) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = false;
    vars.do_export = false;
    vars.geomorph_output_name = temp_outname + '3';
  }
}

if (!vars.geomorphic) {
  var temp_outname = vars.benthic_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = true,
    vars.obia_clean = true, 
    vars.fast_clean = false, 
    vars.manual_clean = false;
    vars.benthic_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false,
    vars.obia_clean = false, 
    vars.fast_clean = false,
    vars.do_export = false;
    vars.benthic_output_name = temp_outname + '2';
  }
}

//var region_extent = ee.FeatureCollection(region_params.extent_mask).geometry()
// -----------------------------------------<


/* ############################
START OF CLEAN 3 - Manual Cleanup
 - review everything in this section
 - first review the reef_boundary object - as it is required for all cleanup stages
    - This can be hand drawn or imported from elsewhere, or could just be a big box
    - Reef_boundary defines export extent and can be used to clip out unwanted areas */
var reef_boundary = region_extent;
Map.addLayer(reef_boundary, {}, "Manual reef outline", false);

/* This is the section to add/remove manual cleanups
 - You MUST review it for each region

############################ */

if (vars.manual_clean && vars.geomorphic) {
  
  print("Doing GEOMORPHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.pixels).select('depth');
  
  // define the manually edited map - uses the output from the second pass of cleaning
  var man_geo = ee.Image(region_params.geo_map_clean2);
  
  
  /*
  // import the mid mask from asset
  var mid_mask = ee.FeatureCollection(region_params.midMask).merge(refinement_mask).geometry()
  Map.addLayer(mid_mask, {color: 'red'}, "mid mask import", true, 0.4)
  var midmask = ee.Image().byte().paint(ee.Feature(mid_mask.dissolve(),{zone: 1}), "zone").clip(mid_mask.dissolve());
  
  
  /*
  ##############
  
  The rest of the manual geometry paintings and rules should go here
      - make the geom, paint the layer, use it in a rule
      - consult previous regions *_cleanup script for ideas/hints/existing rules etc.
  e.g. 
  var notreefcrest = ee.Image().byte().paint(ee.Feature(not_reef_crest, {zone: 1}), "zone").clip(not_reef_crest);
  var notdeepwater = ee.Image().byte().paint(ee.Feature(not_deep_water, {zone: 1}), "zone").clip(not_deep_water);
  
  
  // Reef crest -> Inner reef flat (inside the reef) + Yawajaba Island (inshore)
  man_geo = man_geo.where({
    test: notreefcrest.eq(1)
                     .and(man_geo.eq(15)),
    value: ee.Image(13)
  });
  
  // Deep water -> Deep lagoon (inside the reef)
  man_geo = man_geo.where({
    test: notdeepwater.eq(1)
                     .and(man_geo.eq(2)),
    value: ee.Image(12)
  });
  
  
  var reefCrestToReefSlope = ee.Image().byte().paint(ee.Feature(rc_rs,{zone:1}), "zone").clip(rc_rs);
  var orfToTerrestrialRF =ee.Image().byte().paint(ee.Feature(orf_trf,{zone:1}), "zone").clip(orf_trf);
  var orfToShallowL =ee.Image().byte().paint(ee.Feature(orf_sl,{zone:1}), "zone").clip(orf_sl);
  var slToReefSlope = ee.Image().byte().paint(ee.Feature(sl_rs,{zone:1}), "zone").clip(sl_rs);
  var bReefSlopetoRS = ee.Image().byte().paint(ee.Feature(brs_rs,{zone:1}), "zone").clip(brs_rs);
  var srstoRS = ee.Image().byte().paint(ee.Feature(srs_rs,{zone:1}), "zone").clip(srs_rs);
  var trfToRs = ee.Image().byte().paint(ee.Feature(trf_rs,{zone:1}), "zone").clip(trf_rs);
 // var irfToRs = ee.Image().byte().paint(ee.Feature(irf_rs,{zone:1}), "zone").clip(irf_rs);
 var irfToSl = ee.Image().byte().paint(ee.Feature(irf_sl,{zone:1}), "zone").clip(irf_sl);
 var rsTosl = ee.Image().byte().paint(ee.Feature(rs_sl,{zone:1}), "zone").clip(rs_sl);
 var dlTors = ee.Image().byte().paint(ee.Feature(dl_rs,{zone:1}), "zone").clip(dl_rs)
  // the "MID MASK" CLEAN
  man_geo = man_geo.where({
    test: midmask.eq(1),
    value: ee.Image(0)
  });
  
  
  //turning RC to RS
  man_geo = man_geo.where({
      test:reefCrestToReefSlope.eq(1)
                                   .and (man_geo.eq(15)),
      value: ee.Image(22)
  });
  
  
  man_geo =man_geo.where({
    test:orfToTerrestrialRF.eq(1)
                           .and (man_geo.eq(14)),
    value: ee.Image(16)
  });
  
  
  man_geo =man_geo.where({
    test:orfToShallowL.eq(1)
                           .and (man_geo.eq(14)),
    value: ee.Image(11)
  });
  
  man_geo =man_geo.where({
   test:slToReefSlope.eq(1)
                       .and (man_geo.eq(11)),
   value: ee.Image(22)
  });
  
  
  man_geo =man_geo.where({
 mask1   test:bReefSlopetoRS.eq(1)
                           .and (man_geo.eq(24)),
    value: ee.Image(22)
  });
  
  man_geo =man_geo.where({
    test:srstoRS.eq(1)
                           .and (man_geo.eq(21)),
    value: ee.Image(22)
  });
  
   man_geo =man_geo.where({
    test:trfToRs.eq(1)
                           .and (man_geo.eq(16)),
    value: ee.Image(22)
  });
  
  man_geo =man_geo.where({
    test:irfToSl.eq(1)
                           .and (man_geo.eq(13)),
    value: ee.Image(11)
  });
  
  man_geo =man_geo.where({
    test:rsTosl.eq(1)
                           .and (man_geo.eq(22)),
    value: ee.Image(11)
  });
  
  man_geo =man_geo.where({
    test:dlTors.eq(1)
                           .and (man_geo.eq(12)),
    value: ee.Image(22)
  });
  man_geo =man_geo.where({
    test:irfToRs.eq(1)
                           .and (man_geo.eq(13)),
    value: ee.Image(22)
  });

 ##############
  */  
  
/*
  // WAVE clean (un-comment this sectio nbased on whether you have waves or not)
  
  var waves = ee.Image(region_params.waves)
  Map.addLayer(waves.lt(vars.wave_height), {}, vars.wave_height + "m Hs95 threshold", false)
  
  man_geo = man_geo.where({
    test: waves.lte(vars.wave_height)
               .and(man_geo.eq(22)),
    value: ee.Image(21)
  })
  */
  

  
  if (vars.geo_refinement) {
    // make the mask image layer
    var refine = ee.Image().byte().paint(ee.Feature(refinement_mask, {zone: 1}), "zone").clip(refinement_mask);
    // apply
    man_geo = man_geo.where({
      test: refine.eq(1),
      value: ee.Image(0)
    });
  }
  
  // Add data + the manual layer to the map
  var dove_image = ee.Image(region_params.image);
  Map.addLayer(dove_image, {bands: ['b3','b2','b1'], min:0, max:4000, gamma:1.5}, sensor_params.sname + ' low tide', true);
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(geo_clean2, map_palettes.geo, 'Geo clean stage 2', false);
  Map.addLayer(man_geo.updateMask(man_geo.gt(2)), map_palettes.geo, 'Geo clean stage 3 - MANUAL', true);
  
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_geo,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: reef_boundary,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
} 

if (vars.manual_clean && !vars.geomorphic) {
  
  print("Doing BENTHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.pixels).select('depth');
  
  // define the final geomorphic map (the manually edited geo map - stage 3)
  var geo_map = ee.Image(region_params.geo_map_clean3);
  
  // define the clean benthic map to apply 2nd stage rules to
  var man_benthic = ee.Image(region_params.benthic_map_clean1);
  
  
  /*
  **Generic benthic rules**
    - should be generally applicable, but still review
  */
  
  // BMA on inner RF, outer RF,reef crest, reef slope -> rubble 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(18)
                     .and(geo_map.eq(13).or(geo_map.eq(14)).or(geo_map.eq(15)).or(geo_map.eq(22))),
    value: ee.Image(12)
  });
  
  // Rubble on Outer reef flat and Reef crest -> rock 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(12)
                     .and(geo_map.eq(14).or(geo_map.eq(15))),
    value: ee.Image(13)
  });
    
  // Seagrass on Back reef slope -> Sand 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(14)
                     .and(geo_map.eq(24)),
    value: ee.Image(11)
  });  
  
    
  /*
  
  **Manual polygon guided rules**
   - same as per geomorphic clean section
   - add a geometry, paint the layer, create a rule
  
  */

//Map.addLayer(mid_mask, {color: 'red'}, "mid mask import", true, 0.4)
var midmaskbenthic = ee.Image().byte().paint(ee.Feature(refinement_maskb,{zone: 1}), "zone").clip(refinement_maskb);
  
var rubbleToSand = ee.Image().byte().paint(ee.Feature(rbl_sand,{zone:1}), "zone").clip(rbl_sand);
var coralToSand = ee.Image().byte().paint(ee.Feature(cr_sand,{zone:1}), "zone").clip(cr_sand);
var coralToSeaG = ee.Image().byte().paint(ee.Feature(cr_sg,{zone:1}), "zone").clip(cr_sg);
var sandToCoral = ee.Image().byte().paint(ee.Feature(sand_cr,{zone:1}), "zone").clip(sand_cr);
//mask_out

man_benthic = man_benthic.where({
    test: midmaskbenthic.eq(1),
    value: ee.Image(0)
  });
 
 // rbtoSand
 man_benthic = man_benthic.where({
    test: rubbleToSand.eq(1)
                     .and(man_benthic.eq(12)),
    value: ee.Image(11)
  });  


 
 // crtoSand
 man_benthic = man_benthic.where({
    test: coralToSand.eq(1)
                     .and(man_benthic.eq(15)),
    value: ee.Image(11)
  }); 
     
 //cr>sg
 man_benthic = man_benthic.where({
    test: coralToSeaG.eq(1)
                     .and(man_benthic.eq(15)),
    value: ee.Image(14)
  }); 
 
 
 //sand-coral
 man_benthic = man_benthic.where({
    test: sandToCoral.eq(1)
                     .and(man_benthic.eq(15)),
    value: ee.Image(11)
  }); 
 
     
  // Add the manual layer to the map

  var dove_image = ee.Image(region_params.image);
  Map.addLayer(dove_image, {bands: ['b3','b2','b1'], min:0, max:4000, gamma:1.5}, sensor_params.sname + ' low tide', true);
  
  var benthic_clean1 = ee.Image(region_params.benthic_map_clean1);
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false);
  Map.addLayer(geo_clean2.updateMask(geo_clean2.gt(2)), map_palettes.geo, 'Geo clean stage 2', false);
  Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Geo clean stage 3 - MANUAL', true);
  Map.addLayer(benthic_clean1, map_palettes.benthic, 'Benthic clean stage 1', false);
  Map.addLayer(man_benthic, map_palettes.benthic, 'Benthic clean stage 2 - MANUAL', true);
  
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_benthic,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: reef_boundary,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
}

/* ############################
    END OF MANUAL SECTION
############################ */


// 2. Data loads & vis

if (!vars.manual_clean) {

  // load input data
  
  // define raw geo/benthic outputs
  // Run check to see if the region has been split into multiple areas
  
  // geo
  if (ee.List(region_params.geo_map).length().getInfo() > 1) {
    var geo_map_raw = ee.Image(region_params.geo_map[0]).unmask(0, false)
                 .add(ee.Image(region_params.geo_map[1]).unmask(0,false))
                 .selfMask();
  } else {
    var geo_map_raw = ee.Image(region_params.geo_map);
  }
  
  // benthic
  if (ee.List(region_params.benthic_map).length().getInfo() > 1) {
      var benthic_map = ee.Image(region_params.benthic_map[0]).unmask(0, false)
               .add(ee.Image(region_params.benthic_map[1]).unmask(0,false))
               .selfMask();
  } else {
      var benthic_map = ee.Image(region_params.benthic_map);
  }
  
  // set the geo map for further processing
  if (vars.geomorphic && vars.obia_2nd_pass) {
    // if it's 2nd pass, you want to make sure you're loading the latest geo clean map
    var geo_map = ee.Image(region_params.geo_map_clean1);
  } else if (vars.geomorphic) {
    var geo_map = geo_map_raw;
  }
  
  var depth = ee.Image(region_params.pixels).select('depth');
  var low_tide_image = ee.Image(region_params.image);
  
  var display_pal = (vars.geomorphic) ? map_palettes.geo : map_palettes.benthic;
  Map.addLayer(depth, {min:0, max:2500}, 'Depth data', false);
  Map.addLayer(low_tide_image, {bands: ['b3','b2','b1'], min:0, max:3000}, sensor_params.sname + ' low tide', false);
  
  // load for display purposes
  if (vars.geomorphic) {
    Map.addLayer(geo_map_raw, display_pal, 'Geomorphic map RAW', false);
    if (vars.cleanup_stage == 2) Map.addLayer(ee.Image(region_params.geo_map_clean1), display_pal, 'Geomorphic map - stage 1 clean', false);
  }
  if (!vars.geomorphic) {
    // Use the manually cleaned geomorphic map as input for the benthic clean
    var geo_map = ee.Image(region_params.geo_map_clean3);
    Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Final geo map (manual clean - stage 3)', false);
    Map.addLayer(benthic_map, display_pal, 'Benthic map RAW', false);
  }
  
  // 3. Object-based re-classificaiton and cleaning
  
  /* OUTPUT EXTENT
    - to the mapping extent just so it doesn't balloon out
    - to the 'reef boundary' extent for noise/deep removal
  */  
  var class_extent_mask = geo_map.gt(0);
  
  /*
  
  ########
  Initial small object clean
   - this was originally at the end, but we needed to massively reduce the number of objects to 
     iterate through in the OBIA cleaning, so this happens first now
   - future collabs with google might fix this, but need to change the parallel serialisation of vector procesing
   
   - includes a possible special case for:
        - geomorphic to clean up turbid areas over size threshold; fix shallow vs. deep lagoon
        - benthic to allow breaking waves (temporal class) to grow into surrounding class
  ########
  
  */
  
  // ############################
  // START OF CLEAN 1
  // ############################
  
  if (vars.geomorphic && !vars.obia_2nd_pass) {
    
    // make a smooth map with masked area as a value
    var smooth_map = geo_map
                        .focal_mode({
                          radius: vars.smooth_radius, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 2
                        });
    
    //replace small objects with smooth underneath
    var clean_map = geo_map.where({
      test: geo_map.connectedPixelCount(vars.small_object_geo, false).lt(vars.small_object_geo), 
      value: smooth_map
    }).updateMask(class_extent_mask);
    
    // shallow lagoon > 5m == deep lagoon
    clean_map = clean_map.where({
      test: clean_map.eq(11)
                     .and(depth.gt(vars.shallowlag_depth_cutoff)),
      value: ee.Image(12)
    });
    
    // deep water in depth data == deep (s2 + ls8 data should be good enough for this)
    clean_map = clean_map.where({
      test: depth.gt(vars.geo_depth_cutoff),
      value: ee.Image(2)
    });
    
    // LAND mask cleaning
    Map.addLayer(land_dist.lte(vars.dist_to_land), {}, "Land mask (dist to land)", false);
    
    // reef crest close to land -> TRF
    clean_map = clean_map.where({
      test: land_dist.lte(vars.dist_to_land)
                     .and(clean_map.eq(15)),
      value: ee.Image(16)
    });
    
    // TRF far from land -> ORF
    clean_map = clean_map.where({
      test: land_dist.gt(vars.dist_to_land)
                     .and(clean_map.eq(16)),
      value: ee.Image(14)
    });
    
    
  }
  
  
  if (!vars.geomorphic && vars.cleanup_stage == 1) {
    
    // make a smooth map with masked area as a value, and without temporal class (basically breaking waves)
    var smooth_map = benthic_map
                        .focal_mode({
                          radius: vars.smooth_radius, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 1
                        });
    
    //replace small objects with smooth underneath
    var clean_map = benthic_map.where({
      test: benthic_map.connectedPixelCount(vars.small_object_benthic, false).lt(vars.small_object_benthic),
      value: smooth_map
    }).updateMask(class_extent_mask);
    
    
  }
  
  // ############################
  // START OF CLEAN 2
  // ############################
  
  if (vars.geomorphic && vars.obia_2nd_pass) {
    var clean_map = geo_map;
  }
  
  if (vars.obia_clean) {
    
    if (vars.geomorphic && !vars.fast_clean) { 
      
      // FUNCTION that maps over feature colleciton and assigns neighbour percentages
      var set_neighbour_properties = function(f) {
        // make the 1px buffer
        var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5));
        // reduce the classes in the buffer zone
        var diff_classes = ee.Dictionary(
          clean_map.unmask(ee.Image(0)).reduceRegion({
            reducer: ee.Reducer.frequencyHistogram(),
            geometry: diff.geometry(),
            scale: vars.image_data_scale,
            maxPixels: 1e11
          }).get('classification')
        );
        // calculate the percentages
        var diff_sum = diff_classes.toArray().reduce(ee.Reducer.sum(), [0]).get([0]);
        var diff_percs = diff_classes.map(function(k,v){return(ee.Number(v).divide(diff_sum).multiply(100).toUint8())});
        
        /* NOW, we can try to do the class logic right here (see /users/mitchest/global_reefs/obia_dev),
           or we can return the neighbour % and do image logic via (painted) rasters */
        
        return(f.set(diff_percs));
      };
      
      // FUNCTION to reduce the map to vectors and map the neighbour properties function
      var reduce_neighbours = function() {
        // reduce map to vectors
        var map_fc = clean_map
              .updateMask(segment_id).updateMask(clean_map.eq(classn)) // only vectorise class/es of interest
              .reduceToVectors({
                scale: vars.image_data_scale, 
                eightConnected: false,
                bestEffort: true, 
                maxPixels: 1e13,
                tileScale: 1,
                geometry: reef_boundary
              });
        // map the function, calculate neighbour properties
        return(map_fc.map(set_neighbour_properties));
      };
      
      // first make a make size threshold, so we're not vecortising huge objects when we don't have to
      var segment_id = clean_map.connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels');
      //Map.addLayer(segment_id.reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))))
      Map.addLayer(clean_map.updateMask(segment_id).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
      
      // This is where we select the single or group of classes to vectorise for cleaning up
      //var classn = ee.Number(15) // one class
      var classn = clean_map.where({
        test: clean_map.neq(16) //TRF
                .and(clean_map.neq(15)) //RR
                .and(clean_map.neq(14)) //ORF
                .and(clean_map.neq(13)) //IRF
                //.and(clean_map.neq(12)) // deep L
                .and(clean_map.neq(11)), // shallow L 
        value: ee.Image(99) // 99 ensures it's ignored in logic
      });
      
      // Minimum size of object to reclass based on neighbourhood
      var max_size = ee.Number(1000).divide(vars.image_data_scale).pow(2); // the first number is the square dimension of the desired min size;
      // calculate neighbours
      var map_fc_neighbours = reduce_neighbours();
      
      // #########
      // REEF RIM
      // #########
      
      var focus_class = ee.Number(15); //RR
      
      // start the object-based neighbourhood rules
      // paint out to rasters (only paint the layers needed)
      var objsize = ee.Image(30000).paint(map_fc_neighbours, 'count').rename('count');
      //var nb24 = ee.Image().byte().paint(map_fc_neighbours, '24').unmask(0).rename('nb24') //OCL
      var nb22 = ee.Image().byte().paint(map_fc_neighbours, '22').unmask(0).rename('nb22'); //SL ex
      var nb21 = ee.Image().byte().paint(map_fc_neighbours, '21').unmask(0).rename('nb21'); //Sl sh
      var nb16 = ee.Image().byte().paint(map_fc_neighbours, '16').unmask(0).rename('nb16'); //TRF
      var nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15'); //RR
      var nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14'); //ORF
      var nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13'); //IRF
      //var nb3 = ee.Image().byte().paint(map_fc_neighbours, '3').unmask(0).rename('nb3') //Turbid
      
      // RR surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // RR surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // RR surrounded by IRF + ORF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.add(nb14).gt(75)),
        value: ee.Image(13)
      });
      
      // RR with decent border to TRF --> TRF (often dark, probably seagrass)
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(40)),
        value: ee.Image(16)
      });
      
      // RR surrounded by OCL --> OCL
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb24.gt(75)),
        value: ee.Image(24)
      })
      
      // small RR objects touching OCL + stuff --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(objsize.lte(max_size))
                .and(nb13.lte(75).and(nb14.lte(75))) // to ensure we're no re-writing previous rules
                .and(nb24.gt(1)),
        value: ee.Image(14)
      })
      
      // ####
      // ORF
      // ####
      
      focus_class = ee.Number(14); // ORF
      
      // ORF surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // ORF surrounded by TRF --> TRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(75)),
        value: ee.Image(16)
      });
      
      // ORF surrounded by RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb15.gt(85)),
        value: ee.Image(15)
      });
      
      // ORF touching slope and RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb21.gt(0).or(nb22.gt(0)))
                .and(nb15.gt(0)),
        value: ee.Image(15)
      });
      
      // ####
      // IRF
      // ####
      
      focus_class = ee.Number(13); // IRF
      
      // IRF surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // IRF surrounded by TRF --> TRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(75)),
        value: ee.Image(16)
      });
      
      // IRF surrounded by RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb15.gt(85)),
        value: ee.Image(15)
      });
      
      // ####
      // TRF
      // ####
      
      focus_class = ee.Number(16); // TRF
      
      // TRF surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // TRF surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // TRF surrounded by IRF + ORF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.add(nb14).gt(75)),
        value: ee.Image(13)
      });
      
      // ####
      // LAGOONS
      // ####
      
      var nb11 = ee.Image().byte().paint(map_fc_neighbours, '11').unmask(0).rename('nb11'); // shallow lag
      
      // SL sourrounded by DL --> DL
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                .and(nb12.gt(75)),
        value: ee.Image(12)
      })
      
      // DL sourrounded by SL --> SL
      clean_map = clean_map.where({
        test: clean_map.eq(12)
                .and(nb11.gt(75)),
        value: ee.Image(11)
      })
      
      // DL/SL surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(11).or(clean_map.eq(12))
                .and(objsize.lte(max_size))
                .and(nb13.gt(80)),
        value: ee.Image(13)
      })
      
      // SL surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                .and(objsize.lte(max_size))
                .and(nb13.gt(80)),
        value: ee.Image(13)
      });
      
    
    } else if (vars.geomorphic && vars.fast_clean) {
      print("Executing the fast version OBIA");
      
      /* fast version of the geo clean up
        - blanket version assigns the underlying most common in neighbourhood
        - mode OBIA version iterates through objects+buffers but take the mode instead of doing the class percs, to see if that speeds things up
      */
      
      
      // ## Blanket version
      
      // make a very smooth map to capture the broader neighbourhood
      var smooth_map = clean_map
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                            kernelType: 'circle', units: 'pixels', iterations: 2
                          });
      
      // first make a make size threshold, so we're not vectorising huge objects when we don't have t
      // - the unmask(99) captures small no data values/ data gaps
      var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt().multiply(2)).select('labels').pow(2).log().int();
      Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
      
      // replace small objects with smooth underneath
      var clean_map = clean_map.unmask(0).where({
        test: segment_id.gt(0), 
        value: smooth_map
      }).selfMask();
      
      
      // ## mode OBIA version
      
      /* A possible faster plan
            - vectorise one/few class/es at a time, thus only spending resources on what is actually needed to clean up
            - BUT, just assign the mode of the neighbours, so save resouces even further??
      
      // FUNCTION that maps over feature colleciton and assigns neighbour percentages
      var set_neighbour_mode = function(f) {
        // make the 1px buffer
        var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5))
        // reduce the classes in the buffer zone
        var diff_mode = ee.Number(ee.Dictionary(
          clean_map.unmask(ee.Image(0)).reduceRegion({
            reducer: ee.Reducer.mode(),
            geometry: diff.geometry(),
            scale: vars.image_data_scale,
            maxPixels: 1e11
          })).get('classification'))
        
        return(f.set('mode',diff_mode))
      }
      
      // FUNCTION to reduce the map to vectors and map the neighbour properties function
      var reduce_neighbours_mode = function() {
        // reduce map to vectors
        var map_fc = clean_map.unmask(0)
              .updateMask(classn.gt(0)) // only vectorise class/es of interest
              .reduceToVectors({
                scale: vars.image_data_scale, 
                eightConnected: false,
                bestEffort: true, 
                maxPixels: 1e13,
                tileScale: 1,
                geometry: reef_boundary
              })
        // map the function, calculate neighbour properties
        return(map_fc.map(set_neighbour_mode))
      }
      
      // first make a make size threshold, so we're not vecortising huge objects when we don't have to
      var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels')
      Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false)
      
      // This is where we select the single or group of classes to vectorise for cleaning up
      var classn = segment_id.where({
        test: clean_map.neq(16) //TRF
                .and(clean_map.neq(15)) //RR
                .and(clean_map.neq(14)) //ORF
                .and(clean_map.neq(13)) //IRF
                //.and(clean_map.neq(12)) // deep L
                .and(clean_map.neq(11)) // shallow L 
                .and(clean_map.unmask(0).neq(0)), // no data values (want to reclaim the small gaps 
        value: ee.Image(0) // 99 ensures it's ignored in logic
      })
      
      // calculate neighbours
      var map_fc_neighbours = reduce_neighbours_mode()
      
      //print(map_fc_neighbours.limit(10))
      
      var mode_map = ee.Image().byte().paint(map_fc_neighbours, 'mode').unmask(0).rename('mode') // paint out the mode values to an image
      //Map.addLayer(mode_map, display_pal, "mode map", false)
      
      // replace small objects with mode underneath
      var clean_map = clean_map.unmask(0).where({
        test: segment_id.gt(0), 
        value: mode_map
      }).selfMask()
      
      */
      
    } else {
      
      if (vars.cleanup_stage == 1) {
        // BENTHIC CLEAN-UP RULES
        
        // reclaim shallow no data to surrounding class
        var smooth_map = clean_map
                            .focal_mode({
                              radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                              kernelType: 'circle', units: 'pixels', iterations: 2
                            });
        
        var clean_map = clean_map.unmask(0).where({
          test: geo_map.gt(2).and(clean_map.eq(0)), 
          value: smooth_map
        }).selfMask();
        
        // cut benthic off to < 10 - 15 m
        clean_map = clean_map.where({
          test: depth.gt(vars.benthic_depth_cutoff),
          value: ee.Image(0)
        });
        
        // Deep (or land or missing) in geo == masked from benthic
        clean_map = clean_map.where({
          test: geo_map.unmask(0).lte(2),
          value: ee.Image(0)
        });
        
      }
    }
  }
  
  // Final clip to the classified extent and move on
  if (vars.geomorphic) {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  } else {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  }

  
  
  // 4. Export data
  
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  
  if (vars.do_export) {
    print("For export, the image data scale must be set to:", vars.image_data_scale);
    
    Map.addLayer(region_extent, {}, "Export footprint", false);
    
    Export.image.toAsset({
      image: clean_map.set(vars),
      description: output_name,
      assetId: vars.asset_output + 'in_out/' + output_name,
      region: region_extent,
      scale: vars.image_data_scale,
      crs: 'EPSG:4326',
      maxPixels: 1e13,
      pyramidingPolicy: {'.default': 'mode'}
    });
    
  } else {
    if (vars.reproject_display) {
      Map.addLayer(clean_map.reproject(ee.Projection('EPSG:4326').atScale(vars.image_data_scale)), display_pal, output_name, true);
    } else {
      Map.addLayer(clean_map, display_pal, output_name, false);
    }
  }

}

//Generate title
var title = ui.Label({
  value: 'Classes',
  style: {fontWeight: 'bold', fontSize: '12px'}
});

// generate the legend
var geo_legend = pkg_vis.discrete_legend(map_palettes.geo_atlas_names, map_palettes.geo_atlas_cols, 'Geomorphic Zone', false);
var benthic_legend = pkg_vis.discrete_legend(map_palettes.benthic_atlas_names, map_palettes.benthic_atlas_cols, 'Benthic Habitat', false);
//var mask_legend = pkg_vis.discrete_legend(["Low confidence depth","Water conditions"], ["#f7f7f7","#bababa"], 'Confidence Mask reason', false)
var legend = (vars.geomorphic) ? geo_legend : benthic_legend;
pkg_vis.add_lgds([title, legend]);//, mask_legend])
// generate the legend
