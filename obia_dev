/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var map_centre = /* color: #0b4a8b */ee.Geometry.Point([145.79071684038047, -16.366909817391132]),
    map_classification = ee.Image("users/mitchest/gbr_reefs/reef_map_eg");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
// ###### minimal reproducable example to help develop object-based relationship rules
// mitchell.lyons@gmail.com

/*
The goal here is to develop a method to reclassify objects based on their neighbouring map classes, i.e.
    1. define an object as a group of connected pixels of a particular map class
    2. then determine the relative border to that object for the surrounding mapping classes
    3. if some conditions are met, reassign that object
          e.g. if object of class A is 100% surrounded by class B, then assign that object to class B
          e.g. if object of class C is >70% surrounded by class D, then assign that object to class C
*/

Map.centerObject(map_centre, 12)

/*
A crude example of this is to find small objects, and replace with smoothed raster underneath,
but there's lots of classes that a quite small or thin, that shouldn't be removed,
and contextual information is an important underlying premise of OBIA
*/
var smooth_map = map_classification
                    .focal_mode({
                      radius: 10, kernelType: 'octagon', units: 'pixels', iterations: 1
                    })
                    .mask(map_classification.gte(1))

var crude_object_removal = map_classification
                              .updateMask(map_classification.connectedPixelCount(50, false).gte(50))
                              .unmask(smooth_map)


/*
Another option is to target specific classes, e.g.
 - Target class 15 (reef rim, brown colour) and 14 (outer reef flat, orange)
 - Find objects of a certain size, and replace them with what's underneath (that's not the target class)

BUT, this might get onerous, and sequentially doing this may not always make sense,
and sometimes quite large areas can be wrong and need re-assigning
and sometimes small areas of a class are actually ok if they're not sourrounded by particular classes,
  e.g. small areas of class 15 surrounded by class 13/14 (orange/pale yellow) is not OK,
  but it is OK if it borders class 21/22 (purples)
*/

var smooth_map_15 = map_classification.mask(map_classification.neq(15))
                         .focal_mode({
                           radius: 20, kernelType: 'circle', units: 'pixels', iterations: 1
                         })
                         .mask(map_classification.gte(1))
var smooth_map_14 = map_classification.mask(map_classification.neq(14))
                         .focal_mode({
                           radius: 20, kernelType: 'circle', units: 'pixels', iterations: 1
                         })
                         .mask(map_classification.gte(1))

var limit_size_15 = map_classification
                         .updateMask(map_classification.gt(0)
                                        .subtract(map_classification.eq(15).selfMask()
                                                    .connectedPixelCount(300, false).lt(300).unmask(0)
                                                  ) // clunky, sure there's a simpler way...
                                     )
                         .unmask(smooth_map_15)
                         
var limit_size_14 = limit_size_15
                        .updateMask(map_classification.gt(0)
                                        .subtract(map_classification.eq(14).selfMask()
                                                    .connectedPixelCount(300, false).lt(300).unmask(0)
                                                  ) // clunky, sure there's a simpler way...
                                     )
                         .unmask(smooth_map_14)


/*
Another option that similarly targets classes, but this based on border complexity rather than size

This approach is at least less reliant on size, but still ignores class-based logic,
and probably needs to have sequential reductions for the complexity to make sense...?
*/

// for class 15
var border_pixels = map_classification.reduceNeighborhood({
  reducer: ee.Reducer.countDistinct(),
  kernel: ee.Kernel.square(1)
})

var neighbour_pixels = map_classification.rename('classes').addBands(border_pixels)
                            .reduceConnectedComponents(ee.Reducer.max(), 'classes', 2000)

var border_compl_15 = map_classification
                         .updateMask(map_classification.gt(0)
                                        .subtract(
                                          map_classification.eq(15).and(neighbour_pixels.lte(3))
                                          .unmask(0)
                                         )
                                     )
                         .unmask(smooth_map_15)

// for class 14
border_pixels = border_compl_15.reduceNeighborhood({
  reducer: ee.Reducer.countDistinct(),
  kernel: ee.Kernel.square(1)
})

neighbour_pixels = border_compl_15.rename('classes').addBands(border_pixels)
                            .reduceConnectedComponents(ee.Reducer.max(), 'classes', 2000)

var border_compl_14 = border_compl_15
                         .updateMask(map_classification.gt(0)
                                        .subtract(
                                          map_classification.eq(14).and(neighbour_pixels.lte(3))
                                          .unmask(0)
                                         )
                                     )
                         .unmask(smooth_map_14)


/*
Now display it - a colour palette to make it a bit nicer to look at (also gives the raster value keys)
*/
var geo_pal = {
  palette: [  // the benthic classificaiton palette (NB in raster class value order)
    '238b45', // 1 =  Land
    '08306b', // 2 =  Deep
    'ffffff', // 3 =  place-holder
    'ffffff', // 4 =  place-holder
    'ffffff', // 5 =  place-holder
    'ffffff', // 6 =  place-holder
    'ffffff', // 7 =  place-holder
    'ffffff', // 8 =  place-holder
    'ffffff', // 9 =  place-holder
    'ffffff', // 10 = place-holder
    '9ecae1', // 11 = Shallow Lagoon
    '2171b5', // 12 = Deep lagoon
    'ffffd4', // 13 = Inner Reef Flat
    'fe9929', // 14 = Outer Reef Flat
    '993404', // 15 = Reef Rim
    'ffffff', // 16 = place-holder
    'ffffff', // 17 = place-holder
    'ffffff', // 18 = place-holder
    'ffffff', // 19 = place-holder
    'ffffff', // 20 = place-holder
    '9e9ac8', // 21 = Slope Sheltered
    '807dba', // 22 = Slope Exposed
    'bdbdbd', // 23 = Plateau
    '02818a', // 24 = Open Complex Lagoon
    'd9d9d9', // 25 = Patch Reef
    '0570b0', // 26 = Small Reef
    'ffffff', // 27 = place-holder
    'ffffff', // 28 = place-holder
    'ffffff', // 29 = place-holder
    'ffffff'  // 30 = place-holder
  ],
  min: 1, max: 30
}

Map.addLayer(map_classification, geo_pal, 'Map classification', true)
Map.addLayer(crude_object_removal, geo_pal, 'Crude map smooth', false)
Map.addLayer(limit_size_15, geo_pal, 'Removed small class 15 objects', false)
Map.addLayer(limit_size_14, geo_pal, 'Removed small class 14 & 15 objects', false)
Map.addLayer(border_compl_15, geo_pal, 'Removed class 15 w/ complex border', false)
Map.addLayer(border_compl_14, geo_pal, 'Removed class 15 & 14 w/ complex border', false)



