/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var eg_area = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[158.09700006133824, 6.98282032937242],
          [158.09700006133824, 6.954194253230618],
          [158.14678186065464, 6.954194253230618],
          [158.14678186065464, 6.98282032937242]]], null, false),
    export_small = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[157.9950896058224, 7.112454892191871],
          [157.9950896058224, 6.733464175742206],
          [158.4304228577755, 6.733464175742206],
          [158.4304228577755, 7.112454892191871]]], null, false),
    region_extent = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[30.13312558484233, -1.137341931686524],
          [30.13312558484233, -30.595651061601146],
          [51.182930272342325, -30.595651061601146],
          [51.182930272342325, -1.137341931686524]]], null, false),
    wcmc = ee.FeatureCollection("projects/coral_atlas/global_datasets/wcmc_reefs_2018v4_dissolved"),
    mod_land = ee.ImageCollection("MODIS/006/MOD44W"),
    waves = ee.Image("users/danleeharris/reefwave/est_afr_d1"),
    land_dist = ee.Image("projects/coral_atlas/global_datasets/mod44w6_global_distToLand"),
    image = ee.Image("projects/coral_atlas/east_africa/in_out/east_africa_geo-clean2");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
///////////////////////////////
// Global coral atlas project - East Africa
// Contact: mitchell.lyons@gmail.com
// Region Coordinator: Rodney Borrego (rodbio2008@gmail.com)
// Description:
// - Developing a process to combine OBIA and supervised classification
// - This script loads the raw classification data (from *_classification script)
// - Then applied some cleanup and object-based relational rules
///////////////////////////////

// Table of contents
// 1. Setting constants
// 2. Data loads & vis
// 3. OBIA clean up rules
// 4. Export



// Load and libraries needed
var map_palettes = require('users/mitchest/global_reefs:Modules/colour_pals');
var param_module = require('users/mitchest/global_reefs:Modules/reef_params');

// ###########################################
// SENSOR GENERICS
var sensor_params = param_module.dove    ;     //<------------ THIS IS WHERE YOU CHOOSE THE SENSOR
// REGION AND SENSOR SPECIFIC LOAD PATHS
var region_params = param_module.east_africa ; //<------------ THIS IS WHERE YOU CHOOSE THE REGION
//  ^^ all the data paths are in this module ^^
// ###########################################

// 1. Setting constants

// These will get written to the asset metadata 

var vars = {
  
  // analysis type
  geomorphic: true, // map geomorphic zonation (when set to true) or benthic habitat (when set to false)

  // analysis parameters
  image_data_scale: ee.Number(sensor_params.pixel),
  small_object_geo: ee.Number(400).int(), // smallest object szie in pixels (geomorphic)
  small_object_benthic: ee.Number(130).int(), // smallest object szie in pixels (benthic)
  smooth_radius: ee.Number(3), // radius in pixels for initial smooth 
  
  //############
  //############
  /* This is a stop-gap until we figure out how to chain together vectorisations in GEE
  - GEOMORPHIC: for large regions, the first pass does the small object filter, then the second pass does the OBIA clean
  -           : *in an ideal world* for smaller regions, can do both at once, but not handling that at present
              : 1st stage  - obia_2nd_pass + obia_clean set to false (no changes needed ML thinks); 
              : 2nd stage -  obia_2nd_pass + obia_clean set to true (object-based clean-up; review any OBIA rules); 
              : 3rd stage - manual_clean set to true (chop out all non-region-specific code, review final masks and any manual edits)
  - BENTHIC : can do both at once
            : One stage only - should have obia_2nd_pass and obia_clean set to true (so it uses the most recent geo map) */
  
  // CHANGE FOR EACH PASS
  obia_2nd_pass: true,
  obia_clean: true, // run object-based relationship rules + small object clean up
  fast_clean: true, // run a faster (but less precise) version of the OBIA clean; only applies to geomorphic (`obia_clean: true` also)
  smooth_output: false, // run smoother over final output (includes noise removal) (should be false for second pass)
  //############
  dist_to_land: 2000, //distance to land in METERS to disallow reef crest, and convert to terrestrial reef flat
  // apply any manual touch ups
  manual_clean: true,
  
  // results/layers to show
  export_small_area: false,
  show_eg_area: false, // contrain the map add toe the corresponding example_area polygon geomtery (you can change that)
                              // - you can either set this, or have it false and just navigate to the area you want to see (keeping in mind ALL tiles in the zoom area will calcualte)
  reproject_display: true,
  //reproject_res: ee.Number(sensor_params.pixel).pow(2),
  
  // export options
  do_export: true, // export the results?
  geomorph_output_name: region_params.sname + '_geo-clean3-manV2',
  benthic_output_name: region_params.sname + '_benthic-clean',
  asset_output: region_params.asset // asset path

}
;


/*
############################
MANUAL ADDITION
############################
*/


if (vars.manual_clean) {
  
  vars.obia_2nd_pass = true;
  vars.obia_clean = false;
  vars.fast_clean = false;
  vars.smooth_output = false;
  vars.do_export = false;
  
  print("Doing manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer and ignore the 'final' map layer");
  
  var depth = ee.Image(region_params.pixels).select('depth');
  Map.addLayer(depth.lt(1000), {}, "10m depth contour", false);
  
  Map.addLayer(waves.lt(0.25), {}, "0.25m Hs95 threshold", false);
  
  // merged "Rivermouth" and "not reef" extents. Eventually to be moved over to _datagen script, although CR happy to rerun clean up script/assess result and iterate
  //this is a code I generated to merge both masks involving UNEP but its better to clean this up and avoid using UNEP at all

  /*
  var mergedMasks=ee.FeatureCollection(Rivermouth).merge(not_reef)
  var wcmc_buff = wcmc.filterBounds(mergedMasks).geometry(100).buffer(2000)
  print(wcmc_buff)
  Map.addLayer(wcmc_buff, {}, "buffer")
  var not_reef_img = ee.Image().byte().paint(ee.Feature(wcmc_buff, {zone: 1}), "zone").clip(not_reef).unmask(0).uint8()
  print(not_reef_img)
  Map.addLayer(not_reef_img, {}, "buffer2")
*/

/*
//This is waht Paul did he got the script from NC so in my case its not working
 var not_reef1 = ee.Image().byte().paint(ee.Feature(not_reef, {zone: 1}), "zone").clip(not_reef)
 Map.addLayer(not_reef1, {}, 'not_reef', false)
 var Rivermouth1 = ee.Image().byte().paint(ee.Feature(Rivermouth, {zone: 1}), "zone").clip(Rivermouth)
 Map.addLayer(Rivermouth1, {}, 'river_mouth', false)
 */
 
 
 
 var full_mask = ee.Image().byte().paint(ee.Feature(FINAL_MASK_TO_GEOPASS_EA, {zone: 1}), "zone").clip(FINAL_MASK_TO_GEOPASS_EA);
// print (full_mask)

//var full_mask = ee.Image().byte().paint(ee.Feature(not_reef, {zone: 1}), "zone").clip(not_reef)

 Map.addLayer(full_mask, {}, 'FINAL_MASK_TO_GEOPASS_EA', false);
  
  // define the manually edited map - uses the output from the second pass of cleaning
 var man_geo = ee.Image(region_params.geo_map_clean);
  
  // "full mask clean" CLEAN
  // remove
 man_geo = man_geo.where({
   test: full_mask.eq(0),
                  //.and(man_geo.eq(15)),
  value: ee.Image(0)
 })
  ;
   // "Rivermouth" CLEAN
  // remove
  //man_geo = man_geo.where({
 //   test: Rivermouth1.eq(0),
                  //.and(man_geo.eq(15)),
 //   value: ee.Image(0)
 // })
  
  
  
  
  // WAVE clean (to be integrated into RF classifier)
  // remove
  //man_geo = man_geo.where({
   // test: waves.lte(0.25)
    //           .and(man_geo.eq(22)),
   // value: ee.Image(21)
 // })
  
  // LAND mask clean ############# ---> to be moved to first stage clean up
  ////var land_mask = mod_land.select('water_mask').mean().eq(0).clip(region_extent)

  ///var land_mask_buff = ee.Image(1)
   /// .cumulativeCost({
   ///   source: land_mask, 
   ///   maxDistance: 2000,
   //   geodeticDistance: false,
   /// }).lt(2000).unmask(0)
  
  ///Map.addLayer(land_mask_buff, {}, "Land mask", false)
  
  Map.addLayer(land_dist.lte(vars.dist_to_land), {}, "Land mask", false);
  

  // reef crest close to land -> TRF
  clean_map = clean_map.where({
    test: land_dist.lte(vars.dist_to_land)
                   .and(clean_map.eq(15)),
    value: ee.Image(16)
  });
  
  
  // TRF far from land -> ORF
  clean_map = clean_map.where({
    test: land_dist.gt(vars.dist_to_land)
                   .and(clean_map.eq(16)),
    value: ee.Image(14)
  });
  
  // reef crest close to land -> ORF
  //man_geo = man_geo.where({
  //  test: land_mask_buff.eq(1)
      //                  .and(man_geo.eq(15)),
    //value: ee.Image(14)
  //})
  
   // TRF far from land -> ORF
  //man_geo = man_geo.where({
  //  test: land_mask_buff.eq(0)
       //                 .and(man_geo.eq(16)),
  //  value: ee.Image(14)
  
  
  // Add the manual layer to the map
 //Rbtoremembertorevert//Map.addLayer(man_geo, map_palettes.geo, 'Manually cleaned GEO', false)
  // Export
  Export.image.toAsset({
    image: man_geo,
    description: vars.geomorph_output_name,
    assetId: vars.asset_output + 'in_out/' + vars.geomorph_output_name,
    region: reef_boundary,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  })
  ;
  
}
/*
############################
*/

/* TRIAL #######
    Looks like with the sentinel/ls8 depth we can try to retain full resolution,
    because theres more (good) data either side of the depth threshold/marginal areas
  ##############
  
  Used to be --> output resolution (bigger for geomorphic) - relates back to object size and the min mapping unit defined in classification stage
*/
//if (vars.geomorphic) vars.image_data_scale = ee.Number(sensor_params.pixel)//.pow(2)



// 2. Data loads & vis

// load input data
if (vars.obia_2nd_pass) {
  // if it's 2nd pass, you want to make sure you're loading the latest geo clean map
  // - could change the path in reef_params to a list, check if it length is > 1, then take last element??
  
  // OR run a separate operation that joins the east/west clean1 maps via EPSG:3832, load via one ee.Image(), then save here as EPSG:4326
  //var geo_map = geo1.unmask(0, false).add(geo2.unmask(0,false)).selfMask().clip(swp_extent)
  
  var geo_map = ee.Image(region_params.geo_map_clean);
} else {
  //print(ee.List(region_params.geo_map).length())
  if (ee.List(region_params.geo_map).length().getInfo() > 1) {
    var geo_map = ee.Image(region_params.geo_map[0]).unmask(0, false)
             .add(ee.Image(region_params.geo_map[1]).unmask(0,false))
             .selfMask().clip(reef_boundary);
  } else {
    var geo_map = ee.Image(region_params.geo_map).clip(reef_boundary);
  }
}

//var benthic_map = (vars.obia_2nd_pass) ? ee.Image(region_params.benthic_map_clean) : ee.ImageCollection(region_params.benthic_map).mosaic()
//var benthic_map = ee.Image(region_params.benthic_map)

if (ee.List(region_params.benthic_map).length().getInfo() > 1) {
    var benthic_map = ee.Image(region_params.benthic_map[0]).unmask(0, false)
             .add(ee.Image(region_params.benthic_map[1]).unmask(0,false))
             .selfMask().clip(reef_boundary);
} else {
    var benthic_map = ee.Image(region_params.benthic_map);
}


var depth = ee.Image(region_params.pixels).select('depth');
var image = ee.Image(region_params.image);

var display_pal = (vars.geomorphic) ? map_palettes.geo : map_palettes.benthic;
//Map.centerObject(eg_area, 11)
Map.addLayer(depth, {min:0, max:2500}, 'Depth data', false);
Map.addLayer(image, {bands: ['b3','b2','b1'], min:200, max:1200}, 'Dove low tide', false);

if (vars.geomorphic) {
  if (vars.obia_2nd_pass) {
    if (ee.List(region_params.geo_map).length().getInfo() > 1) {
      var geo_map_display = ee.Image(region_params.geo_map[0]).unmask(0, false)
                       .add(ee.Image(region_params.geo_map[1]).unmask(0,false))
                       .selfMask().clip(reef_boundary);
    } else {
    var geo_map_display = ee.Image(region_params.geo_map).clip(reef_boundary);
    }
    Map.addLayer(geo_map_display, display_pal, 'Raw GEO classification', false);
  } else {
    Map.addLayer(geo_map, display_pal, 'Raw GEO classification', false);
  }
}
if (!vars.geomorphic) {
  Map.addLayer(geo_map, map_palettes.geo, 'Clean GEO classification', false);
  Map.addLayer(benthic_map, display_pal, 'Raw BENTHIC classification', false);
}

// 3. Object-based re-classificaiton and cleaning

/*

// if we want to retain the land/waves flags, need to add them in before makign the mask

######## Not that straight forwards - the land and bright masks are a LOT of not land and not breakign waves... =(

// add in land, for geomorphic clean up rules
  geo_map = geo_map.unmask(0).where({
    test: depth.eq(-2).and(globcover.select('landcover').neq(210)),
    value: ee.Image(1)
  })
  
  // change -3 to reef rim, hope that clouds have been handleded by masking
  geo_map = geo_map.unmask(0).where({
    test: depth.eq(-3),
    value: ee.Image(15)
  })
  
  // remask
  geo_map = geo_map.updateMask(geo_map.gt(0))

*/

/* OUTPUT EXTENT
  - to the mapping extent just so it doesn't balloon out
  - to the 'reef boundary' extent for noise/deep removal
*/  
var class_extent_mask = geo_map.gt(0).clip(reef_boundary);


/*

########
Initial small object clean
 - this was originally at the end, but we needed to massively reduce the number of objects to 
   iterate through in the OBIA cleaning, so this happens first now
 - future collabs with google might fix this, but need to change the parallel serialisation of vector procesing
 
 - includes a possible special case for:
      - geomorphic to clean up turbid areas over size threshold; fix shallow vs. deep lagoon
      - benthic to allow breaking waves (temporal class) to grow into surrounding class
########

*/

if (vars.geomorphic && !vars.obia_2nd_pass) {
  
  // make a smooth map with masked area as a value
  var smooth_map = geo_map
                      //.unmask(99)
                      .focal_mode({
                        radius: vars.smooth_radius, // relates to smoothness required
                        kernelType: 'circle', units: 'pixels', iterations: 2
                      });
  //smooth_map = smooth_map.updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)
  
  //replace small objects with smooth underneath
  var clean_map = geo_map.where({
    test: geo_map.connectedPixelCount(vars.small_object_geo, false).lt(vars.small_object_geo), 
    value: smooth_map
  //}).updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)
  }).updateMask(class_extent_mask);
  
  // shallow lagoon > 5m == deep lagoon
  clean_map = clean_map.where({
    test: clean_map.eq(11)
                   .and(depth.gt(500)),
    value: ee.Image(12)
  });
  
  /*// deep lagoon == deep (to hard to differentiate deep water vs. deep lagoon effectively over large areas)
  clean_map = clean_map.where({
    test: clean_map.eq(12),
    value: ee.Image(2)
  })*/
  
  // deep water in depth data == deep (s2 + ls8 data should be good enough for this)
  clean_map = clean_map.where({
    test: depth.gt(2000),
    value: ee.Image(2)
  });
  
  
  /*//CLEAN UP SMALL (but slightly larger) TURBID AREAS
  var smooth_noturbid = clean_map
                          .updateMask(clean_map.neq(3))
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(1.5),
                            kernelType: 'circle', units: 'pixels', iterations: 2
                          })
  
  clean_map = clean_map.where({
    test: clean_map.eq(3).connectedPixelCount(vars.small_object_geo.multiply(10), false).lt(vars.small_object_geo.multiply(10)), 
    value: smooth_noturbid
  }).updateMask(class_extent_mask)*/
}


if (!vars.geomorphic) {
  
  // make a smooth map with masked area as a value, and without temporal class (basically breaking waves)
  var smooth_map = benthic_map
                      //.unmask(99)
                      .focal_mode({
                        radius: vars.smooth_radius, // relates to smoothness required
                        kernelType: 'circle', units: 'pixels', iterations: 1
                      });
  //smooth_map = smooth_map.updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)
  
  //replace small objects with smooth underneath
  var clean_map = benthic_map.where({
    test: benthic_map.connectedPixelCount(vars.small_object_benthic, false).lt(vars.small_object_benthic),
    value: smooth_map
  //}).updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)
  }).updateMask(class_extent_mask);
  
  
  /*// CLEAN UP ALL TEMPORAL AREAS
  var smooth_notemp = benthic_map
                          .updateMask(benthic_map.neq(2))
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(2),
                            kernelType: 'circle', units: 'pixels', iterations: 3
                          })
  
  
  clean_map = clean_map1.where({
    test: benthic_map.eq(2), 
    value: smooth_notemp
  }).updateMask(clean_map1.gte(0))
  
  // this catches any left over unmasked temporal, and assigned it back to temporal
  clean_map = clean_map.where({
    test: clean_map.unmask(99).eq(99).and(clean_map1.eq(2)),
    value: ee.Image(2)
  })*/
  
}



if (vars.geomorphic && vars.obia_2nd_pass) {
  var clean_map = geo_map
}

Map.addLayer(clean_map.reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Initial smooth classification', false)

if (vars.obia_clean) {
  
  if (vars.geomorphic && !vars.fast_clean) { // SHOULD TRY TO PUT THIS OUT TO A MODULE TO KEEP THE RULES THE SAME EVERYWEHRE?
    
    // #########
    // THE PLAN - vectorise one/few class/es at a time, thus only spending resources on what is actually needed to clean up
    // #########
    
    // FUNCTION that maps over feature colleciton and assigns neighbour percentages
    var set_neighbour_properties = function(f) {
      // make the 1px buffer
      var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5));
      // reduce the classes in the buffer zone
      var diff_classes = ee.Dictionary(
        clean_map.unmask(ee.Image(0)).reduceRegion({
          reducer: ee.Reducer.frequencyHistogram(),
          geometry: diff.geometry(),
          scale: vars.image_data_scale,
          maxPixels: 1e11
        }).get('classification')
      );
      // calculate the percentages
      var diff_sum = diff_classes.toArray().reduce(ee.Reducer.sum(), [0]).get([0]);
      var diff_percs = diff_classes.map(function(k,v){return(ee.Number(v).divide(diff_sum).multiply(100).toUint8())});
      
      /* NOW, we can try to do the class logic right here (see /users/mitchest/global_reefs/obia_dev),
         or we can return the neighbour % and do image logic via (painted) rasters */
      
      return(f.set(diff_percs));
    };
    
    // FUNCTION to reduce the map to vectors and map the neighbour properties function
    var reduce_neighbours = function() {
      // reduce map to vectors
      var map_fc = clean_map
            .updateMask(segment_id).updateMask(clean_map.eq(classn)) // only vectorise class/es of interest
            .reduceToVectors({
              scale: vars.image_data_scale, 
              eightConnected: false,
              bestEffort: true, 
              maxPixels: 1e13,
              tileScale: 1,
              geometry: reef_boundary
            });
      // map the function, calculate neighbour properties
      return(map_fc.map(set_neighbour_properties));
    };
    
    // first make a make size threshold, so we're not vecortising huge objects when we don't have to
    var segment_id = clean_map.connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels');
    //Map.addLayer(segment_id.reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))))
    Map.addLayer(clean_map.updateMask(segment_id).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
    // This is where we select the single or group of classes to vectorise for cleaning up
    //var classn = ee.Number(15) // one class
    var classn = clean_map.where({
      test: clean_map.neq(16) //TRF
              .and(clean_map.neq(15)) //RR
              .and(clean_map.neq(14)) //ORF
              .and(clean_map.neq(13)) //IRF
              //.and(clean_map.neq(12)) // deep L
              .and(clean_map.neq(11)), // shallow L 
      value: ee.Image(99) // 99 ensures it's ignored in logic
    });
    
    // Minimum size of object to reclass based on neighbourhood
    var max_size = ee.Number(1000).divide(vars.image_data_scale).pow(2); // the first number is the square dimension of the desired min size
    // calculate neighbours
    var map_fc_neighbours = reduce_neighbours();
    
    // #########
    // REEF RIM
    // #########
    
    var focus_class = ee.Number(15); //RR;
    
    // start the object-based neighbourhood rules
    // paint out to rasters (only paint the layers needed)
    var objsize = ee.Image(30000).paint(map_fc_neighbours, 'count').rename('count');
    //var nb24 = ee.Image().byte().paint(map_fc_neighbours, '24').unmask(0).rename('nb24') //OCL
    var nb22 = ee.Image().byte().paint(map_fc_neighbours, '22').unmask(0).rename('nb22'); //SL ex
    var nb21 = ee.Image().byte().paint(map_fc_neighbours, '21').unmask(0).rename('nb21'); //Sl sh
    var nb16 = ee.Image().byte().paint(map_fc_neighbours, '16').unmask(0).rename('nb16'); //TRF
    var nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15'); //RR
    var nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14'); //ORF
    var nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13'); //IRF
    //var nb3 = ee.Image().byte().paint(map_fc_neighbours, '3').unmask(0).rename('nb3') //Turbid
    
    // RR surrounded by ORF --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb14.gt(75)),
      value: ee.Image(14)
    });
    
    // RR surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.gt(75)),
      value: ee.Image(13)
    });
    
    // RR surrounded by IRF + ORF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.add(nb14).gt(75)),
      value: ee.Image(13)
    });
    
    // RR with decent border to TRF --> TRF (often dark, probably seagrass)
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb16.gt(40)),
      value: ee.Image(16)
    });
    
    /*// RR surrounded by OCL --> OCL
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb24.gt(75)),
      value: ee.Image(24)
    })*/
    
    /* with 2nd/3rd pass method, we don't really need this
    // RR surrounded by IRF + ORF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.lte(75).and(nb14.lte(75))) // to ensure we're no re-writing previous rules
              .and(nb13.add(nb14).gt(75))
              .and(nb21.add(nb22).lte(0)), // to not get rid of complex reef rims (if touching slope, it's probably RR)
      value: ee.Image(13) // could try assigning to a place-holder, then deal with at the end?
    })*/
    
    /*// small RR objects touching OCL + stuff --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(objsize.lte(max_size))
              .and(nb13.lte(75).and(nb14.lte(75))) // to ensure we're no re-writing previous rules
              .and(nb24.gt(1)),
      value: ee.Image(14)
    })*/
    
    // ####
    // ORF
    // ####
    
  focus_class = ee.Number(14); // ORF
    
    //classn = ee.Number(14)
    //map_fc_neighbours = reduce_neighbours()
    //var nb22 = ee.Image().byte().paint(map_fc_neighbours, '22').unmask(0).rename('nb22') //SL ex
    //var nb21 = ee.Image().byte().paint(map_fc_neighbours, '21').unmask(0).rename('nb21') //Sl sh
    //nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15') //RR
    //nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13') //IRF
    //var nb1 = ee.Image().byte().paint(map_fc_neighbours, '1').unmask(0).rename('nb1') //Land
    
 
    // ORF surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.gt(75)),
      value: ee.Image(13)
    });
 
    
    // ORF surrounded by TRF --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb16.gt(75)),
      value: ee.Image(16)
    });
    
    // ORF surrounded by RR --> RR
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb15.gt(85)),
      value: ee.Image(15)
    });
    
    // ORF touching slope and RR --> RR
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb21.gt(0).or(nb22.gt(0)))
              .and(nb15.gt(0)),
      value: ee.Image(15)
    });
    
    /*// ORF touching land --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb1.gt(10)),
      value: ee.Image(16)
    })*/
    
    // ####
    // IRF
    // ####
    
    focus_class = ee.Number(13); // IRF
    
    //classn = ee.Number(13)
    //map_fc_neighbours = reduce_neighbours()
    //nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15') //RR
    //nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14') //ORF
    
    // IRF surrounded by ORF --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb14.gt(75)),
      value: ee.Image(14)
    });
    
    // IRF surrounded by TRF --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb16.gt(75)),
      value: ee.Image(16)
    });
    
    // IRF surrounded by RR --> RR
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb15.gt(85)),
      value: ee.Image(15)
    });
    
    /*// IRF touching land --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb1.gt(10)),
      value: ee.Image(16)
    })*/
    
    // ####
    // TRF
    // ####
    
    focus_class = ee.Number(16); // TRF
    
    //classn = ee.Number(16)
    //map_fc_neighbours = reduce_neighbours()
    //nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15') //RR
    //nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14') //ORF
    //nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13') //IRF
    
    // TRF surrounded by ORF --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb14.gt(75)),
      value: ee.Image(14)
    });
    
    // TRF surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.gt(75)),
      value: ee.Image(13)
    });
    
    // TRF surrounded by IRF + ORF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.add(nb14).gt(75)),
      value: ee.Image(13)
    });
    
    /*// TRF not touching land --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb1.lt(10)),
      value: ee.Image(13)
    })*/
    
    
    // ####
    // LAGOONS
    // ####
    
    var nb11 = ee.Image().byte().paint(map_fc_neighbours, '11').unmask(0).rename('nb11'); // shallow lag
    //var nb12 = ee.Image().byte().paint(map_fc_neighbours, '12').unmask(0).rename('nb12') //deep lag
    
    // DL touching SL --> SL
    /* 
    This is a stop-gap until we have better depth product - below are the rules we want,
    but too much band-aiding is required to make it work, so for the moment just err on the side
    of shallow lagoon when it's mixed.
    */
    /*clean_map = clean_map.where({
      test: clean_map.eq(12)
              .and(nb11.gt(0)),
      value: ee.Image(11)
    })*/
    
    /*// SL sourrounded by DL --> DL
    clean_map = clean_map.where({
      test: clean_map.eq(11)
              .and(nb12.gt(75)),
      value: ee.Image(12)
    })*/
    
    /*// DL sourrounded by SL --> SL
    clean_map = clean_map.where({
      test: clean_map.eq(12)
              .and(nb11.gt(75)),
      value: ee.Image(11)
    })*/
    
    /*// DL/SL surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(11).or(clean_map.eq(12))
              .and(objsize.lte(max_size))
              .and(nb13.gt(80)),
      value: ee.Image(13)
    })*/
    
    // SL surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(11)
              .and(objsize.lte(max_size))
              .and(nb13.gt(80)),
      value: ee.Image(13)
    });
    
    /*// DL/SL touching OCL --> OCL
    clean_map = clean_map.where({
      test: clean_map.eq(11).or(clean_map.eq(12))
              .and(nb24.gt(0)),
      value: ee.Image(24)
    })*/
    
    
    /*// ####
    // Turbid
    // ####
    
    focus_class = ee.Number(3) // turbid
    
    // Turb surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.gt(75)),
      value: ee.Image(13)
    })
    
    // Turb surrounded by ORF --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb14.gt(75)),
      value: ee.Image(14)
    })
    
    // Turb surrounded by TRF --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb16.gt(75)),
      value: ee.Image(16)
    })*/
  
  } else if (vars.geomorphic && vars.fast_clean) {
    print("Executing the fast version OBIA");
    
    /* fast version of the geo clean up
      - blanket version assigns the underlying most common in neighbourhood
      - mode OBIA version iterates through objects+buffers but take the mode instead of doing the class percs, to see if that speeds things up
    */
    
    
    //############
    //# blanket version
    //############
    // make a very smooth map to capture the broader neighbourhood
    var smooth_map = clean_map
                        .focal_mode({
                          radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 2
                        });
                 
    
    // first make a make size threshold, so we're not vectorising huge objects when we don't have t
    // - the unmask(99) captures small no data values/ data gaps
    var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt().multiply(2)).select('labels').pow(2).log().int();
    Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
    
    
    // replace small objects with smooth underneath
    var clean_map = clean_map.unmask(0).where({
      test: segment_id.gt(0), 
      value: smooth_map
    }).selfMask();
    //############
    //############
    
    
    /*    
    //############
    //# mode OBIA version
    //############
    
    // #########
    // THE FASTER PLAN - vectorise one/few class/es at a time, thus only spending resources on what is actually needed to clean up
    //                 - BUT, just assign the mode of the neighbours, so save resouces even further??
    // #########
    
    // FUNCTION that maps over feature colleciton and assigns neighbour percentages
    var set_neighbour_mode = function(f) {
      // make the 1px buffer
      var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5))
      // reduce the classes in the buffer zone
      var diff_mode = ee.Number(ee.Dictionary(
        clean_map.unmask(ee.Image(0)).reduceRegion({
          reducer: ee.Reducer.mode(),
          geometry: diff.geometry(),
          scale: vars.image_data_scale,
          maxPixels: 1e11
        })).get('classification'))
      
      return(f.set('mode',diff_mode))
    }
    
    // FUNCTION to reduce the map to vectors and map the neighbour properties function
    var reduce_neighbours_mode = function() {
      // reduce map to vectors
      var map_fc = clean_map.unmask(0)
            .updateMask(classn.gt(0)) // only vectorise class/es of interest
            .reduceToVectors({
              scale: vars.image_data_scale, 
              eightConnected: false,
              bestEffort: true, 
              maxPixels: 1e13,
              tileScale: 1,
              geometry: reef_boundary
            })
      // map the function, calculate neighbour properties
      return(map_fc.map(set_neighbour_mode))
    }
    
    // first make a make size threshold, so we're not vecortising huge objects when we don't have to
    var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels')
    Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false)
    
    // This is where we select the single or group of classes to vectorise for cleaning up
    var classn = segment_id.where({
      test: clean_map.neq(16) //TRF
              .and(clean_map.neq(15)) //RR
              .and(clean_map.neq(14)) //ORF
              .and(clean_map.neq(13)) //IRF
              //.and(clean_map.neq(12)) // deep L
              .and(clean_map.neq(11)) // shallow L 
              .and(clean_map.unmask(0).neq(0)), // no data values (want to reclaim the small gaps 
      value: ee.Image(0) // 99 ensures it's ignored in logic
    })
    
    // calculate neighbours
    var map_fc_neighbours = reduce_neighbours_mode()
    
    //print(map_fc_neighbours.limit(10))
    
    var mode_map = ee.Image().byte().paint(map_fc_neighbours, 'mode').unmask(0).rename('mode') // paint out the mode values to an image
    //Map.addLayer(mode_map, display_pal, "mode map", false)
    
    // replace small objects with mode underneath
    var clean_map = clean_map.unmask(0).where({
      test: segment_id.gt(0), 
      value: mode_map
    }).selfMask()
    
    //############
    //############
    */
    
  } else {
    
    // BENTHIC CLEAN-UP RULES
    
    
    // reclaim shallow no data to surrounding class
    var smooth_map = clean_map
                        .focal_mode({
                          radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 2
                        });
    
    var clean_map = clean_map.unmask(0).where({
      test: geo_map.gt(2).and(clean_map.eq(0)), 
      value: smooth_map
    }).selfMask();
    
    // cut benthic off to < 10 m
    clean_map = clean_map.where({
      test: depth.gt(1000),
      value: ee.Image(0)
    });
    
    // Deep (or land or missing) in geo == masked from benthic
    clean_map = clean_map.where({
      test: geo_map.unmask(0).lte(2),
      value: ee.Image(0)
    });
    
    // Deep lagoon in geo + coral/algae in benthic == sand in benthic
    clean_map = clean_map.where({
      test: geo_map.eq(12).and(clean_map.eq(15)),
      value: ee.Image(11)
    });
    
    /*// turbid in geo == turbid (temporal - class num 2)
    // ############## ---> need to decide here whether to push geo turbid through regardless of benthic class
    clean_map = clean_map.where({
      test: geo_map.eq(3),
      value: ee.Image(2)
    })*/
    
    /*
    // Ignore in benthic + ORF in geo == rock
    clean_map = clean_map.where({
      test: clean_map.eq(0)
                     .and(geo_map.eq(14)),
      value: ee.Image(13)
    })
    
    // Ignore in benthic + IRF in geo == sand
    clean_map = clean_map.where({
      test: clean_map.eq(0)
                     .and(geo_map.eq(13)),
      value: ee.Image(11)
    })
    
    // Ignore in benthic + TRF in geo == sand
    clean_map = clean_map.where({
      test: clean_map.eq(0)
                     .and(geo_map.eq(16)),
      value: ee.Image(11)
    })
    
    // Ignore in benthic + RR in geo == rock
    */
    
    /*// seagrass in benthic + ORF or RR in geo == coral/algae
    clean_map = clean_map.where({
      test: clean_map.eq(14)
                     .and(geo_map.eq(14).or(geo_map.eq(15)).or(geo_map.eq(21)).or(geo_map.eq(22))),
      value: ee.Image(15)
    })*/
    
    // ####--> CR: "Seagrass neighbouring deep water or no data not shallow a rock or coral algae class"
    
    // coral or algae in benthic + TRF in geo == seagrass
    clean_map = clean_map.where({
      test: clean_map.eq(16)
                     .and(geo_map.eq(16)),
      value: ee.Image(14)
    });
    
    // BMA in benthic and slope/plat in geo == sand
    clean_map = clean_map.where({
      test: clean_map.eq(18)
                     .and(geo_map.eq(2).or(geo_map.eq(12)).or(geo_map.eq(21)).or(geo_map.eq(22)).or(geo_map.eq(23))),
      value: ee.Image(11)
    });
    
    
  }
  
/*  // ####
  // Final small object clean (safety net for oddities with scaling and border buffers??)
  // ####
  
  var clean_size = (vars.geomorphic) ? vars.small_object_geo : vars.small_object_benthic
  
  var map_vsmooth = clean_map
                        .focal_mode({
                          radius: 10, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 1
                        })
                        .updateMask(class_extent_mask)
  
  clean_map = clean_map.where({
    test: clean_map.connectedPixelCount(clean_size, false).lt(clean_size), 
    value: map_vsmooth
  })*/

}

// final smooth
if (vars.smooth_output) {
  // smooth the output lightly to make nice edges, and get rid of noise
  var noise_smooth = clean_map.unmask(99) // unmasking to a value allows us to include masked areas in the smooth, then re-mask after
                        .focal_mode({
                          radius: 2, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 2
                        });
  clean_map = clean_map.updateMask(noise_smooth.neq(99)).updateMask(clean_map.gt(1)) ;// this ignores 0/land; make it .gt(2) if you want to mask deep too
} else {
  // just clip to the classified extent and move on
  if (vars.geomorphic) {
    clean_map = clean_map.updateMask(clean_map.gt(1)) ;// this ignores 0/land; make it .gt(2) if you want to mask deep too
  } else {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  }
  
}


// 4. Export data

var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;


if (vars.do_export) {
  print("For export, the image data scale must be set to:", vars.image_data_scale);
  
  if (vars.export_small_area) {
    var export_convhull = export_small;
  } else {
    //var export_convhull = clean_map.gt(2).reduceToVectors({scale: 1000, maxPixels: 1e13, bestEffort: true, geometry: region_extent, crs: "EPSG:4326"}).geometry().convexHull({maxError: 100})
    var export_convhull = reef_boundary;
  }
  Map.addLayer(export_convhull, {}, "Export footprint", true);
  Export.image.toAsset({
    image: clean_map.set(vars),
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: export_convhull,
    //scale: vars.image_data_scale,
    scale: 5,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  /*Export.image.toCloudStorage({
    image: clean_map,//.set(vars),
    description: 'swp_geo_clean',
    bucket: 'mitchest_unet_bucket',
    fileNamePrefix: 'swp_geo_clean',
    region: export_convhull,
    scale: 25,
    crs: 'EPSG:4326',
    maxPixels: 1e13
  })*/
  
  
} else {
  if (vars.show_eg_area) {
    if (vars.reproject_display) {
     Map.addLayer(clean_map.clip(eg_area).reproject(ee.Projection('EPSG:4326').atScale(vars.image_data_scale)), display_pal, output_name + '_final', false);
    } else {
     Map.addLayer(clean_map.clip(eg_area), display_pal, output_name + '_final', false);
    }
  } else {
    if (vars.reproject_display) {
      Map.addLayer(clean_map.reproject(ee.Projection('EPSG:4326').atScale(vars.image_data_scale)), display_pal, output_name + '_final', false);
    } else {
      Map.addLayer(clean_map, display_pal, output_name + '_final', false);
    }
  }
}
