/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var map_centre = /* color: #d63000 */ee.Geometry.Point([-77.14244768345269, 24.079294121145775]),
    eg_area = 
    /* color: #d63000 */
    /* displayProperties: [
      {
        "type": "rectangle"
      },
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.MultiPolygon(
        [[[[178.1914966082618, -19.126850353489502],
           [178.1914966082618, -19.126850353489502],
           [178.1914966082618, -19.126850353489502],
           [178.1914966082618, -19.126850353489502]]],
         [[[178.1896083331153, -19.126039427046837],
           [178.1896083331153, -19.156203209515112],
           [178.24265169859382, -19.156203209515112],
           [178.24265169859382, -19.126039427046837]]]], null, false),
    rgb_vis = {"opacity":1,"bands":["b3","b2","b1"],"min":2643.4286587190527,"max":4022.9989507085565,"gamma":1},
    region_extent = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-85.98308517718672, 29.977841924871946],
          [-85.98308517718672, 16.51411805544282],
          [-70.33855392718672, 16.51411805544282],
          [-70.33855392718672, 29.977841924871946]]], null, false),
    bahamas = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-83.13294571684324, 24.970918291047816],
          [-83.59785865947877, 24.559976686509692],
          [-80.48872780010377, 23.445974326192655],
          [-79.45601295635377, 23.123046023422937],
          [-78.57710670635377, 22.738557476432998],
          [-77.91792701885377, 22.51546228942888],
          [-77.61030983135377, 22.210660879130547],
          [-76.46773170635377, 21.660351181705895],
          [-74.18257545635377, 20.656289024274205],
          [-71.12837623760377, 20.450549238411714],
          [-70.13960670635377, 20.162050606841838],
          [-68.88716530010377, 19.417758605711274],
          [-68.05220436260377, 19.624854549563434],
          [-68.49165748760377, 21.47644422847084],
          [-75.52290748760377, 25.63445708440291],
          [-77.21480201885377, 27.4233298038994],
          [-79.96909780900535, 27.624729542512103],
          [-80.41153059243044, 28.58496559512943],
          [-81.15456023131104, 30.239913137495215],
          [-85.48957332068215, 30.1838689551361],
          [-85.64131569072877, 29.557080914173955],
          [-84.89038116740669, 29.46813287853176],
          [-83.93812847399992, 29.80139499443965],
          [-83.0789281651522, 28.815210030228403],
          [-83.17336000590824, 28.24526978115051],
          [-82.83980201885377, 27.23789093364772],
          [-81.41157936260377, 25.05859415544099]]]),
    caribbean = 
    /* color: #0b4a8b */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-85.31570111732977, 21.71372888937999],
          [-84.68367789930886, 20.717002139051697],
          [-82.66219352430886, 17.56227184050665],
          [-75.98250602430886, 16.68032806153099],
          [-71.93953727430886, 16.76450178324257],
          [-69.21492789930886, 17.016798878132406],
          [-64.29305289930886, 16.76450178324257],
          [-63.54598258680886, 18.481623847910917],
          [-66.33650993055886, 19.147175030435292],
          [-67.91854118055886, 19.167930835325677],
          [-69.20394157118386, 19.44787744813654],
          [-70.23665641493386, 19.954693212970003],
          [-72.63899635479127, 20.257417608575057],
          [-74.42976783916627, 20.607450924988996],
          [-75.38557838604127, 21.02848189221677],
          [-76.05574440166627, 21.346036014599175],
          [-76.90169166729127, 21.713946676482358],
          [-77.46199440166627, 21.968888847986857],
          [-77.54439186260377, 22.154708435657763],
          [-77.74214576885377, 22.304712399820232],
          [-78.01680397197877, 22.505313008152807],
          [-78.35738014385377, 22.616914072824592],
          [-79.07149147197877, 22.839844391751853],
          [-80.18111061260377, 23.244235885385596],
          [-81.38960670635377, 23.587008338894],
          [-83.78462623760377, 23.203851465160604],
          [-85.21284889385377, 22.39362180655535]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
///////////////////////////////
// Global coral atlas project - north caribbean & bahamas region
// Contact: mitchell.lyons@gmail.com
// Description:
// - Developing a process to combine OBIA and supervised classification
// - This script loads the pixel-based and segmentation data and applies a mchaine learning classifier
// - Corresponding '_datagen' script performs the data gathering/segmentation, '_calval' generates the trianing samples
///////////////////////////////

// Table of contents
// 1. Setting constants
// 2. Data loads & vis
// 3. Divide into potential mapping zones (not utilised yet really)
// 4. Train and fit models
// 5. Export data

// Load and libraries needed
var map_palettes = require('users/mitchest/global_reefs:Modules/colour_pals')
var param_module = require('users/mitchest/global_reefs:Modules/reef_params')
var slider_module = require('users/mitchest/global_reefs:Modules/threshold_sliders')

// ###########################################
// SENSOR GENERICS
var sensor_params = param_module.dove         //<------------ THIS IS WHERE YOU CHOOSE THE SENSOR
// REGION AND SENSOR SPECIFIC LOAD PATHS
var region_params = param_module.nth_cari  //<------------ THIS IS WHERE YOU CHOOSE THE REGION
//  ^^ all the data paths are in this module ^^
// ###########################################

// 1. Setting constants

// These will get written to the asset metadata 

var vars = {
  
  // analysis type
  geomorphic: true, // map geomorphic zonation (when set to true) or benthic habitat (when set to false)
  use_benthic_points: false, // true = use benthic field points instead of map
  thresholding: false, // should all the thresholdable layers be added to the map?
  threshold_pixels: true, // whether the thresholding should be on the pixel or segment data
  
  // analysis parameters
  image_data_scale: sensor_params.pixel, // pixel size of the image data
  
  /*
  Choose whether pixels, segments or both should be used to train the classifier. Choose from,
  
  pixel data:
  ['b1_p', 'b2_p', 'b3_p', 'b4_p', 'depth_p', 'depth_stdDev_p', 'red_stdDev_p', 'depth_maxent_p', 'b1_savg_p', 'b2_savg_p', 'rb_p', 'gb_p', 'rg_p']
  
  object data:
  ['b1_s', 'b2_s', 'b3_s', 'b4_s', 'depth_s', 'rb_s', 'gb_s', 'rg_s']
    */
  input_bands: ['b1_p', 'b2_p', 'b3_p', 'b4_p', 'depth_p', 'red_stdDev_p', 'b1_s', 'b2_s', 'b3_s', 'b4_s', 'depth_s', 'rb_s', 'gb_s', 'rg_s'],
  blue_nir_bands: (sensor_params.sname == 'dove') ? ['b1','b4'] : ['B2','B5'], // only handles Landsat/Sentinel-2/Dove
  blue_band: (sensor_params.sname == 'dove') ? 'b1' : 'B2', // only handles Landsat/Sentinel-2/Dove
  class_field: 'class_num', // the field in the training data that stores the class integer
  //small_object_filter: 50, // size in pixels (output scale) for small object removal
  
  /*// add relative band brightness to predictor variables?
  use_brightness: true, <<----- now done in the *_datagen script */
  
  // zone thresholds
  //reef_top_depth: 4.5, // areas above this depth will be split into 'reef top'
  
  // classification params
  rf_trees: 15, // number of random forest trees (per class)
  rf_minLeafPop: 1, // minimum leaf population for random forest
  rf_varPerSplit: 0, // default sqrt(n(k))
  set_seed: 42, // set a seed so results are repeatable

  // class information for classification, sampling and reporting
  local_epsg: region_params.epsg,
  // trim input data
  trim_training_data: false, // if true, will trim the training data set by the % below
  trim_training_perc: 0.80,
  // split into sub-regions
  // runs classificaiton for this sub-region (grom need to be added to dictionary `region_dic` below)
  // set to 'none' (or any string that is not a sub-region)
  split_region: 'bahamas', 
  
  // results/layers to show
  show_intermediates: false, // show separate intermediate layers (e.g. reef top, reef crest etc.)
  show_eg_area: false, // contrain the map add to the corresponding example_area polygon geomtery (you can change that)
                              // - you can either set this, or have it false and just navigate to the area you want to see (keeping in mind ALL tiles in the zoom area will calcualte)
  /*
  Use test mode?
  This pars down the training computation
  to test (in real-time in the map viewer)
  whether classification output is working
  */
  test_mode: true,
  
  // export options
  do_export: false, // export the results?
  export_scale: sensor_params.pixel, // pixel size to export at
  geomorph_output_name: region_params.sname + '_' + 'geo',
  benthic_output_name: region_params.sname + '_' + 'benthic',
  asset_output: region_params.asset, // asset path

}

// dictionary to control sub-region geometries (add new ones)
var region_dic = ee.Dictionary({bahamas: bahamas, caribbean: caribbean}) // <- include all splits here
var region_idx = ee.Number(region_dic.keys().indexOf(ee.String(vars.split_region))).getInfo()

if (region_idx > -1) {
  var subregion_clip = ee.Geometry(region_dic.get(vars.split_region))
}

// if running in test mode, over-write the trianing params
if (vars.test_mode) {
  vars.rf_trees = 10
  vars.trim_training_data = true
  vars.trim_training_perc = 0.2
}


// 2. Data loads & vis

// load input data
var pixsegs = ee.ImageCollection(region_params.pixels).mosaic().regexpRename('(^.*$)','$1_p')
                  .addBands(
              ee.ImageCollection(region_params.segments).mosaic().regexpRename('(^.*$)','$1_s')  
                           )
                  .select(vars.input_bands)
var geomorph = ee.FeatureCollection(region_params.geo_train_library)
var benthic = ee.FeatureCollection(region_params.benthic_train_library)
if (vars.use_benthic_points) var benthic_pts = ee.FeatureCollection(region_params.benthic_pts)

// Load training data samples (from '*_calval' script)

//classes_mapped_geo:       [ 2,  11,  12,  13,   14,   15,  16,  21,  22,  23,  24  ], // classes to map
//classes_mapped_names_geo: ['D','SL','DL','IRF','ORF','RR','TRF','SS','SE','PL','OCL'],
//classes_mapped_benthic:       [ 3,    4,    11,   12,   13,   14,   15,   16,  17], // classes to map
//classes_mapped_names_benthic: ['MAN','MU', 'SA', 'RU', 'RO', 'SG', 'CA', 'CO', 'AL'],

var training_data = (vars.geomorphic) ? geomorph : benthic // Set the training points to either geomorphic or benthic
// trim the data (randomly) if needed
if (vars.trim_training_data) {
  training_data = training_data.randomColumn("random")
  training_data = training_data.filter(ee.Filter.lte("random", vars.trim_training_perc))
}


// trim the image and training data to sub-region, if desired
if (region_idx > -1) {
  pixsegs = ee.Image(pixsegs.clip(subregion_clip))
  training_data = ee.FeatureCollection(training_data.filterBounds(subregion_clip))
}

print("Number of training samples:", training_data.size())

Map.centerObject(map_centre, 14)
Map.addLayer(pixsegs, {min: 100, max: 2000}, 'segments + pixels', false)


// ################################################
// Add the threshold slider layers
// ################################################

if (vars.thresholding) {
  
  var thresh_dat = (vars.threshold_pixels) ? pixels : segments
  
  var bw_pal = {'palette': '000000,ffffff','min':-9999, 'max': -9999}
  var red_pal = {'palette': '000000,f03b20','min':-9999, 'max': -9999}
  
  // N.B. these are all generic and come from mitchest/global_reefs/Modules/threshold_sliders
  slider_module.add_depth(thresh_dat)
  slider_module.add_waves(thresh_dat)
  slider_module.add_slope(thresh_dat)
  slider_module.add_b1(thresh_dat)
  slider_module.add_b2(thresh_dat)
  slider_module.add_b3(thresh_dat)
  slider_module.add_b4(thresh_dat)
  if (sensor_params.sname != 'dove') slider_module.add_b5(thresh_dat)
  slider_module.add_depthsd(thresh_dat)
  slider_module.add_redsd(thresh_dat)
  slider_module.add_ndwi(thresh_dat)
  slider_module.add_idm(thresh_dat)
  slider_module.add_depth_depthvar(thresh_dat)
  
}
  
// ################################################
// End of adding threshold slider layers
// ################################################


// 3. Divide into potential mapping zones

/*

var reef_top = pixels.select('depth').gt(vars.reef_top_depth)

if (vars.show_intermediates) {
  Map.addLayer(reef_top, {}, "reef top", false)
}

*/


// 4. Train and fit models

// filter nulls
training_data = training_data.filter(ee.Filter.notNull(vars.input_bands))
print('Number of sampels after null filter', training_data.size())

// parameterise and train the classifier (random forest in this case)
var rf_classifier = ee.Classifier.randomForest({
  numberOfTrees: vars.rf_trees,
  minLeafPopulation: vars.rf_minLeafPop,
  variablesPerSplit: vars.rf_varPerSplit,
  seed: vars.set_seed
}).train(training_data, vars.class_field, vars.input_bands)
// fit the classificaiton model
var raw_classification = pixsegs.classify(rf_classifier).toUint8()



// 5. Export data

var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name
var display_pal = (vars.geomorphic) ? map_palettes.geo : map_palettes.benthic

/*var export_classification = function () {
  //var export_convhull = pixels.select(vars.blue_band).gt(0).reduceToVectors({scale: 1000, maxPixels: 1e13, bestEffort: true, geometry: pixels.select(vars.blue_band).geometry().bounds(100), crs: "EPSG:4326"}).geometry().convexHull({maxError: 100})
  Map.addLayer(export_geom, {}, "Export footprint", true)
  Export.image.toAsset({
    image: raw_classification.set(vars),
    description: output_name,
    assetId: vars.asset_output + output_name,
    region: export_geom,
    scale: vars.export_scale,
    crs: vars.local_epsg,
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  })
}*/

if (vars.do_export) {
  //export_classification() // export if wanted
  
  //var export_geom = ee.Geometry.Rectangle(-168.034,-24.0093,162.7417,-7.3087)
  if (region_idx > -1) {
    var export_geom = subregion_clip
  } else {
    var export_geom = pixsegs.select(1).gt(0).reduceToVectors({scale: 1000, maxPixels: 1e13, bestEffort: true, geometry: region_extent, crs: "EPSG:4326"}).geometry().convexHull({maxError: 100})
  }
  Map.addLayer(export_geom, {}, "export footprint", true)
  
  Export.image.toAsset({
    image: raw_classification.set(vars),
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    scale: vars.export_scale,
    region: export_geom,
    maxPixels: 1e13,
    pyramidingPolicy:{'.default': 'mode'},
  })
  
  
  /*
  
  // add raster flag for either side of dateline
  var latlong = ee.Image.pixelLonLat().select('longitude').clip(export_geom)
  var export_stack_east = raw_classification.set(vars).updateMask(latlong.lte(0))
  var export_stack_west = raw_classification.set(vars).updateMask(latlong.gt(0))
  
  var export_geom_east = ee.Geometry.Rectangle(-179.99998,-24.0093,-168.034,-8.081)
  var export_geom_west = ee.Geometry.Rectangle(162.7417,-23.0584,179.99998,-7.3087)
  
  Map.addLayer(export_geom_east, {}, "export footprint east", true)
  Map.addLayer(export_geom_west, {}, "export footprint west", true)
  
  Export.image.toAsset({
    image: export_stack_east,
    description: output_name + '_east',
    assetId: vars.asset_output + 'in_out/' + output_name + '_east',
    scale: vars.export_scale,
    region: export_geom_east,
    maxPixels: 1e13,
    pyramidingPolicy:{'.default': 'mode'},
  })
  
  Export.image.toAsset({
    image: export_stack_west,
    description: output_name + '_west',
    assetId: vars.asset_output + 'in_out/' + output_name + '_west',
    scale: vars.export_scale,
    region: export_geom_west,
    maxPixels: 1e13,
    pyramidingPolicy:{'.default': 'mode'},
  })
  
  */
  
} else {
  if (vars.show_eg_area) {
    Map.addLayer(raw_classification.clip(eg_area), display_pal, output_name + '_raw', false)
  } else {
    Map.addLayer(raw_classification, display_pal, output_name + '_raw', false)
  }
}

// last so it sits on top
Map.addLayer(training_data, {}, "Training point distribution", false) // Training data points
if (vars.use_benthic_points) Map.addLayer(benthic_pts, {}, "Training field point distribution", false) // Training data points