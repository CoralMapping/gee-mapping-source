/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var eg_area = 
    /* color: #d63000 */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[158.09700006133824, 6.98282032937242],
          [158.09700006133824, 6.954194253230618],
          [158.14678186065464, 6.954194253230618],
          [158.14678186065464, 6.98282032937242]]], null, false),
    export_small = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[157.9950896058224, 7.112454892191871],
          [157.9950896058224, 6.733464175742206],
          [158.4304228577755, 6.733464175742206],
          [158.4304228577755, 7.112454892191871]]], null, false),
    region_extent = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-85.98308517718672, 29.977841924871946],
          [-85.98308517718672, 16.51411805544282],
          [-70.33855392718672, 16.51411805544282],
          [-70.33855392718672, 29.977841924871946]]], null, false),
    reef_boundary = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-85.98308517718672, 29.977841924871946],
          [-85.98308517718672, 16.51411805544282],
          [-70.33855392718672, 16.51411805544282],
          [-70.33855392718672, 29.977841924871946]]], null, false),
    land_dist = ee.Image("projects/coral_atlas/global_datasets/mod44w6_global_distToLand"),
    west = 
    /* color: #ef3dff */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-170.05421307096222, 16.6451400858547],
          [-169.26319744596222, 16.276379337331182],
          [-166.52210857877472, 22.956876785083164],
          [-161.24867107877472, 21.900749850607188],
          [-159.88636639127472, 23.118638908420024],
          [-168.41175701627472, 25.956563835498525],
          [-172.8005727562403, 27.17740555675168],
          [-178.03578045377466, 29.409455643699086],
          [-179.88075843416314, 29.138941969116722],
          [-179.21131756314966, 27.701525535727267],
          [-174.21253826627472, 25.084107254287407],
          [-168.27992107877472, 23.48189007138448]]]),
    east = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-160.10125396109765, 22.64228527575897],
          [-161.24383208609765, 21.675686283465996],
          [-155.13543364859765, 17.913808970579183],
          [-153.16888091422265, 20.074384925080125],
          [-159.26629302359765, 23.138220615639327]]]),
    rivermouth = /* color: #d63000 */ee.Geometry.MultiPolygon(
        [[[[-157.24561225226518, 21.08670903118609],
           [-157.24355231574174, 21.083505668270888],
           [-157.23720084479447, 21.081903960918915],
           [-157.22672950080033, 21.081583617377095],
           [-157.21763144782182, 21.082224303770264],
           [-157.20366534239312, 21.08526752641976],
           [-157.19336565977594, 21.08686919751912],
           [-157.1803193951275, 21.08462685314612],
           [-157.1696763897564, 21.085587862020766],
           [-157.15302523619195, 21.08670903118609],
           [-157.13809069639703, 21.08799035701618],
           [-157.1279626751568, 21.091674107224158],
           [-157.11337145811578, 21.09455697845126],
           [-157.10616168028375, 21.09920148662003],
           [-157.1037584210064, 21.106087903752318],
           [-157.10736330992242, 21.111372611871857],
           [-157.14942034727594, 21.10448643990089],
           [-157.18855914122125, 21.100963158615865],
           [-157.22821291929742, 21.09615854939994],
           [-157.24675234800836, 21.09135378474521],
           [-157.24675234800836, 21.089431835366884]]],
         [[[-156.99570724105507, 20.91916342061558],
           [-156.9318492088285, 20.906976603823075],
           [-156.8927104148832, 20.894628424266415],
           [-156.85082503890663, 20.871853792575678],
           [-156.84498855209023, 20.88163768427958],
           [-156.8139178428617, 20.88548690960389],
           [-156.81597777938515, 20.896873623408602],
           [-156.82284423446328, 20.917078903760917],
           [-156.82662078475624, 20.932631907531576],
           [-156.83074065780312, 20.949946754127104],
           [-156.8355471763578, 20.955878231701035],
           [-156.8633563194242, 20.957000376682267],
           [-156.8901354942289, 20.951389567610114],
           [-156.911764827725, 20.945778548150578],
           [-156.93717071151406, 20.942572156874576],
           [-156.98300429916054, 20.941449903703226],
           [-156.99793883895546, 20.938243419718876],
           [-157.0080668601957, 20.931509579864603],
           [-157.00532027816445, 20.92429441552101]]],
         [[[-156.82850905990273, 20.7749428799643],
           [-156.78800447581116, 20.787939322661675],
           [-156.78251131174866, 20.800296261084448],
           [-156.77804811594788, 20.823723520406357],
           [-156.78096635935609, 20.844740769075823],
           [-156.79126604197327, 20.848751360957856],
           [-156.80860384104554, 20.84907220369007],
           [-156.81478365061585, 20.84329692982963],
           [-156.82096346018616, 20.83736100073135],
           [-156.83160646555726, 20.812331266893775],
           [-156.83555467722718, 20.78376662142259]]],
         [[[-157.9354798103508, 21.633825912798965],
           [-157.92432182084886, 21.63063449001586],
           [-157.91659705888597, 21.630315343860264],
           [-157.89719932329027, 21.63669813302479],
           [-157.89805763017503, 21.65329206474841],
           [-157.90131919633714, 21.671638902725718],
           [-157.90595405351488, 21.688388324930262],
           [-157.92775504838792, 21.721721854704157],
           [-157.94783942949144, 21.73160878512591],
           [-157.96878211747972, 21.733043928191787],
           [-157.99573295366136, 21.731289862498738],
           [-158.00774925004808, 21.72682487142811],
           [-158.0391632820305, 21.70226494260899],
           [-158.06805544037596, 21.672448173661273],
           [-158.08590822357908, 21.644528302898415],
           [-158.07475023407713, 21.63782673019225],
           [-158.0646222128369, 21.635433236004445]]],
         [[[-159.7371470529943, 21.99324243229499],
           [-159.77800246070913, 21.9868755198193],
           [-159.7975718576818, 21.980189954259444],
           [-159.81061812233023, 21.969365037678955],
           [-159.81748457740835, 21.94834960925195],
           [-159.6887385446935, 21.87668276916244],
           [-159.63655348609976, 21.862026444978387],
           [-159.59226485084585, 21.869036179071152],
           [-159.58848830055288, 21.887514737046253],
           [-159.59157820533804, 21.90758356174716]]],
         [[[-160.15383266963985, 21.930907072196526],
           [-160.15314602413204, 21.93966495246362],
           [-160.15168690242794, 21.94619320334275],
           [-160.15529179134396, 21.961636896171242],
           [-160.1599266485217, 21.96235331541617],
           [-160.17074131526974, 21.95956722028372],
           [-160.1811268285754, 21.94953682553811],
           [-160.18859409847286, 21.936878412674925],
           [-160.17142796077755, 21.92238752604182]]]]),
    noreefmask = /* color: #0dff09 */ee.Geometry.MultiPolygon(
        [[[[-155.75950064387715, 20.11176724970261],
           [-155.4326573821584, 19.946617631774327],
           [-155.2019444915334, 19.817474101263812],
           [-155.11130728450215, 19.79938561625032],
           [-155.00144400325215, 19.812306172586883],
           [-154.9602452727834, 19.882059025130957],
           [-155.30906119075215, 20.168497274571106],
           [-155.5919591399709, 20.28447167295894],
           [-155.7897130462209, 20.390061765147262],
           [-155.8995763274709, 20.292200221431955],
           [-155.92978872981465, 20.258707062473384],
           [-155.9380284759084, 20.17623159019767],
           [-155.8885899993459, 20.16334085108873]]],
         [[[-155.3118077727834, 19.398330895725163],
           [-155.63315787043965, 19.107918804938297],
           [-155.58921255793965, 19.030042835869057],
           [-155.4546300384084, 18.985896898558423],
           [-155.24314322200215, 19.139058936972752],
           [-154.9767247649709, 19.185758121592972],
           [-154.79270376887715, 19.362057545913377],
           [-154.69931997981465, 19.429415904347064],
           [-154.72129263606465, 19.600276923919328],
           [-154.8723546477834, 19.719254774662904],
           [-154.9602452727834, 19.690811582904196],
           [-154.97947134700215, 19.732181825783826],
           [-155.08384146418965, 19.633910043421125]]],
         [[[-155.7128087493459, 19.496746342096507],
           [-156.0423985930959, 19.406102705030435],
           [-156.0423985930959, 19.30763239073769],
           [-156.05613150325215, 19.074177044353597],
           [-155.9215489837209, 18.858587312170002],
           [-155.68259634700215, 18.736383172070568],
           [-155.68808951106465, 19.058601605612775]]],
         [[[-156.41981433622445, 20.61019750052318],
           [-156.4500267385682, 20.44943843829302],
           [-156.26463245145882, 20.424988293163704],
           [-156.09983752958382, 20.509903655565786],
           [-155.7908470510682, 20.6885864665451],
           [-155.85951160184945, 20.832408263229773],
           [-156.02567981474007, 20.977375097482916],
           [-156.1863548635682, 21.067107138843895],
           [-156.28111194364632, 21.063262588218304],
           [-156.35526965849007, 21.056854783061258],
           [-156.34291003934945, 20.911964936182187]]],
         [[[-156.54947901523835, 20.620597381453944],
           [-156.6875052826296, 20.68122245561185],
           [-156.8921256439577, 20.484521719681513],
           [-156.81796792911396, 20.390581907708473],
           [-156.6394400970827, 20.37384688471071],
           [-156.48700479434834, 20.42018557413537],
           [-156.4622855560671, 20.449783547115807],
           [-156.5007377045046, 20.582260972436806]]],
         [[[-157.0435631111516, 20.898135832350654],
           [-157.18501208576097, 20.885305778496836],
           [-157.1589195564641, 20.823706268669046],
           [-157.09986804279222, 20.69914707509469],
           [-157.0325767830266, 20.631045665331353],
           [-156.93507312091722, 20.614336886412087],
           [-156.78263781818285, 20.669597383049346],
           [-156.84306262287035, 20.772354092177274]]],
         [[[-156.972495301093, 21.315166733973502],
           [-156.97043536456957, 21.156441677113254],
           [-156.88666461261644, 21.143633832499944],
           [-156.77886126788988, 21.14427425103497],
           [-156.70470355304613, 21.1506782841081],
           [-156.598960144843, 21.15131867218619],
           [-156.59621356281176, 21.261424163519425],
           [-156.68547747882738, 21.27550149684102],
           [-156.96562884601488, 21.32220299640468]]],
         [[[-157.24515661099863, 21.16366498640197],
           [-157.22867711881113, 21.193757589780102],
           [-157.24618657926035, 21.21200224852229],
           [-157.26335271695567, 21.250404685129944],
           [-157.29459508756113, 21.299993019564656],
           [-157.33888372281504, 21.301592364927615],
           [-157.37218602994395, 21.276000750979783],
           [-157.4573300729127, 21.215202833428418],
           [-157.43123754361582, 21.11210918563888],
           [-157.33579381802988, 21.102820831591774],
           [-157.30592473844004, 21.102180234026704]]]]),
    imageVisParam = {"opacity":1,"bands":["depth"],"min":1500,"max":2500,"gamma":1};
/***** End of imports. If edited, may not auto-convert in the playground. *****/
///////////////////////////////
// Global coral atlas project - Hawaii
// Contact: mitchell.lyons@gmail.com
// Region coordinator: Paul Tudman (tuddy117@gmail.com)
// Description:
// - Developing a process to combine OBIA and supervised classification
// - This script loads the raw classification data (from *_classification script)
// - Then applied some cleanup and object-based relational rules
///////////////////////////////

// Table of contents
// 1. Setting constants
// 2. Data loads & vis
// 3. OBIA clean up rules
// 4. Export

// Load and libraries needed
var map_palettes = require('users/mitchest/global_reefs:Modules/colour_pals');
var pkg_vis = require('users/mitchest/global_reefs:Modules/pkg_vis');
var param_module = require('users/mitchest/global_reefs:Modules/reef_params');

// ###########################################
// SENSOR GENERICS
var sensor_params = param_module.dove         //<------------ THIS IS WHERE YOU CHOOSE THE SENSOR
// REGION AND SENSOR SPECIFIC LOAD PATHS
var region_params = param_module.hawaii  //<------------ THIS IS WHERE YOU CHOOSE THE REGION
//  ^^ all the data paths are in this module ^^
// ###########################################

// 1. Setting constants

// These will get written to the asset metadata 

var vars = {
  
  // analysis type
  geomorphic: true, // map geomorphic zonation (when set to true) or benthic habitat (when set to false)

  // analysis parameters
  image_data_scale: sensor_params.pixel,
  small_object_geo: ee.Number(400).int(), // smallest object szie in pixels (geomorphic)
  small_object_benthic: ee.Number(130).int(), // smallest object szie in pixels (benthic)
  smooth_radius: ee.Number(3), // radius in pixels for initial smooth 
  dist_to_land: 2000, //distance to land in meters to disallow reef crest, and convert to terrestrial reef flat
  wave_height: 0.4, //cut off height for waves in metres, Hs95 threshold
  
  //############
  /* This is a stop-gap until we figure out how to chain together vectorisations in GEE
  - GEOMORPHIC: for large regions, the first pass does the small object filter, then the second pass does the OBIA clean
  -           : *in an ideal world* for smaller regions, can do both at once, but not handling that at present
  -           : 1st pass - obia_2nd_pass + obia_clean set to false (fast clean not used in this pass, can be left as true)
  -           : 2nd pass - obia_2nd_pass + obia_clean set to true (review any OBIA rules)
  -           : 3rd pass - manual_clean set to true 
  - BENTHIC : can do both at once
            : production run should have obia_2nd_pass and obia_clean set to true (so it uses best geo map) */
  obia_2nd_pass: false,
  obia_clean: false, // run object-based relationship rules + small object clean up
  fast_clean: true, // run a faster (but less precise) version of the OBIA clean; only applies to geomorphic (`obia_clean: true` also)
  smooth_output: false, // run smoother over final output (includes noise removal) (should be false for second pass)
  //############
  
  // apply any manual touch ups
  manual_clean: false,
  
  // results/layers to show
  export_small_area: false,
  show_eg_area: false, // constrain the map add to the corresponding example_area polygon geomtery (you can change that)
                              // - you can either set this, or have it false and just navigate to the area you want to see (keeping in mind ALL tiles in the zoom area will calcualte)
  reproject_display: true,
  //reproject_res: ee.Number(sensor_params.pixel).pow(2),
  
  // export options
  do_export: true, // export the results?
  geomorph_output_name: region_params.sname + '_geo_clean',
  benthic_output_name: region_params.sname + '_benthic_clean',
  asset_output: region_params.asset // asset path

}

/*
############################
MANUAL ADDITION
############################
*/

// This can be hand drawn or imported from elsewhere, or could just be a big box
// Reef_boundary defines export extent and can be used to clip out unwanted areas
reef_boundary = ee.FeatureCollection([ee.Feature(east),ee.Feature(west)]).geometry()
Map.addLayer(reef_boundary, {}, "Manual reef outline", false)

if (vars.manual_clean) {
  
  vars.obia_2nd_pass = true
  vars.obia_clean = false
  vars.fast_clean = false
  vars.smooth_output = false
  vars.do_export = false
  
  print("Doing manual clean ups - make sure this is what you want to do")
  print("Export the manual map, check 'manual' layer and ignore the 'final' map layer")
  
  var depth = ee.Image(region_params.pixels).select('depth')
  var depth_cont = depth.lt(900)
  Map.addLayer(depth_cont, {}, "depth contour", false)
  
// update these values based on inspection of the layer
  //Map.addLayer(waves.lt(vars.wave_height), {}, vars.wave_height + "m Hs95 threshold", false)
  
  // merged "Rivermouth" and "not reef" extents. Eventually to be moved over to _datagen script, although CR happy to rerun clean up script/assess result and iterate
  //var mergedMasks = ee.FeatureCollection(rivermouth).merge(noreefmask)
  //var mergedMasksFlat = mergedMasks.flatten()
  //var not_reef_img = ee.Image().byte().paint(ee.Feature(mergedMasksFlat, {zone: 0}), "zone").clip(mergedMasksFlat)
  var not_reef = ee.Image().byte().paint(ee.Feature(noreefmask, {zone: 1}), "zone").clip(noreefmask)
  var river = ee.Image().byte().paint(ee.Feature(rivermouth, {zone: 1}), "zone").clip(rivermouth)
  
  
  // define the manually edited map - uses the output from the second pass of cleaning
  var man_geo = ee.Image(region_params.geo_map_clean_p2)
  
  // "NOT REEF" CLEAN
  // remove
  man_geo = man_geo.where({
    test: not_reef.eq(0),
                  //.and(man_geo.eq(15)),
    value: ee.Image(0)
  })
  
   // "Rivermouth" CLEAN
  // remove
  man_geo = man_geo.where({
    test: river.eq(0),
                  //.and(man_geo.eq(15)),
    value: ee.Image(0)
  })
  
  /*// WAVE clean ############# ---> (to be integrated into RF classifier when feasible)
  // remove
  man_geo = man_geo.where({
    test: waves.lte(vars.wave_height)
               .and(man_geo.eq(22)),
    value: ee.Image(21)
  })
  
  //BAHAMAS clean (can delete all these - see East AFrica for examples)
  // deep -> deep lagoon
  man_geo = man_geo.where({
    test: baha_extent.eq(1)
                     .and(depth_cont)
                     .and(man_geo.eq(2).or(man_geo.eq(23))),
    value: ee.Image(12)
  })
  
  // deep -> deep lagoon
  man_geo = man_geo.where({
    test: baha_extent.eq(1)
                     .and(baha_img.eq(1))
                     .and(man_geo.eq(2).or(man_geo.eq(23))),
    value: ee.Image(12)
  })
  
  // slope -> shallow lagoon
  man_geo = man_geo.where({
    test: baha_extent.eq(1)
                     .and(depth_cont)
                     .and(man_geo.eq(21).or(man_geo.eq(22)).or(man_geo.eq(24))),
    value: ee.Image(11)
  })
  
  // slope -> shallow lagoon
  man_geo = man_geo.where({
    test: baha_extent.eq(1)
                     .and(baha_img.eq(1))
                     .and(man_geo.eq(21).or(man_geo.eq(22)).or(man_geo.eq(24))),
    value: ee.Image(11)
  })
  
  // reef crest -> TRF
  man_geo = man_geo.where({
    test: baha_img.eq(1)
                  .and(man_geo.eq(15)),
    value: ee.Image(16)
  })
  

  // CUBA WEST CLEAN
  // deep classes -> deep lagoon
  man_geo = man_geo.where({
    test: cuba_west.eq(1)
                   .and(depth_cont)
                   .and(man_geo.eq(2).or(man_geo.eq(23))),
    value: ee.Image(12)
  })
  
  // shallow classes -> shallow lagoon
  man_geo = man_geo.where({
    test: cuba_west.eq(1)
                   .and(depth_cont)
                   .and(man_geo.eq(21).or(man_geo.eq(22)).or(man_geo.eq(24)).or(man_geo.eq(13)).or(man_geo.eq(14))),
    value: ee.Image(11)
  })
  
  // reef crest -> TRF
  man_geo = man_geo.where({
    test: cuba_west.eq(1)
                  .and(man_geo.eq(15)),
    value: ee.Image(16)
  })
  
  // CUBA WEST 2 CLEAN
  // deep classes -> deep lagoon
  man_geo = man_geo.where({
    test: cuba_west2.eq(1)
                   .and(depth_cont)
                   .and(man_geo.eq(2).or(man_geo.eq(23))),
    value: ee.Image(12)
  })
  
  // shallow classes -> shallow lagoon
  man_geo = man_geo.where({
    test: cuba_west2.eq(1)
                   .and(depth_cont)
                   .and(man_geo.eq(21).or(man_geo.eq(22)).or(man_geo.eq(24))),
    value: ee.Image(11)
  })
  
  // deep classes -> deep lagoon
  man_geo = man_geo.where({
    test: cuba_west2x.eq(1)
                   //.and(depth_cont)
                   .and(man_geo.eq(2).or(man_geo.eq(23))),
    value: ee.Image(12)
  });
  
  // shallow classes -> shallow lagoon
  man_geo = man_geo.where({
    test: cuba_west2x.eq(1)
                   //.and(depth_cont)
                   .and(man_geo.eq(21).or(man_geo.eq(22)).or(man_geo.eq(24))),
    value: ee.Image(11)
  });
  
  
  //CUBA EAST
  // deep classes -> deep lagoon
  man_geo = man_geo.where({
    test: cuba_east.eq(1)
                   //.and(depth_cont)
                   .and(man_geo.eq(2).or(man_geo.eq(23))),
    value: ee.Image(12)
  });
  
  // shallow classes -> shallow lagoon
  man_geo = man_geo.where({
    test: cuba_east.eq(1)
                   //.and(depth_cont)
                   .and(man_geo.eq(21).or(man_geo.eq(22)).or(man_geo.eq(24)).or(man_geo.eq(13)).or(man_geo.eq(14))),
    value: ee.Image(11)
  });
  
  // reef crest -> TRF
  man_geo = man_geo.where({
    test: cuba_east.eq(1)
                  .and(man_geo.eq(15)),
    value: ee.Image(16)
  });*/
  
  
  /*// LAND mask clean ############# ---> to be moved to first stage clean up
  var land_mask = mod_land.select('water_mask').mean().eq(0)

  var land_mask_buff = ee.Image(1)
    .cumulativeCost({
      source: land_mask, 
      maxDistance: 2000,
      geodeticDistance: false,
    }).lt(2000).unmask(0)
  
  Map.addLayer(land_mask_buff, {}, "Land mask", false)
  
  // reef crest close to land -> ORF
  man_geo = man_geo.where({
    test: land_mask_buff.eq(1)
                        .and(man_geo.eq(15)),
    value: ee.Image(14)
  })*/
  
  
  // Add the manual layer to the map
  var image = ee.Image(region_params.image);
  Map.addLayer(image, {bands: ['b3','b2','b1'], min:200, max:1200}, 'Dove low tide', true);
  Map.addLayer(man_geo, map_palettes.geo, 'Manually cleaned GEO', false);
  var output_name = (vars.manual_clean) ? vars.geomorph_output_name + "-man" : output_name;
  // Export
  Export.image.toAsset({
    image: man_geo,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: reef_boundary,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
  
}
/*
############################
*/

/* TRIAL #######
    Looks like with the sentinel/ls8 depth we can try to retain full resolution,
    because theres more (good) data either side of the depth threshold/marginal areas
  ##############
  
  Used to be --> output resolution (bigger for geomorphic) - relates back to object size and the min mapping unit defined in classification stage
*/
//if (vars.geomorphic) vars.image_data_scale = ee.Number(sensor_params.pixel)//.pow(2)



// 2. Data loads & vis

// load input data
if (vars.obia_2nd_pass) {
  // if it's 2nd pass, you want to make sure you're loading the latest geo clean map
  // - could change the path in reef_params to a list, check if it length is > 1, then take last element??
  
  // OR run a separate operation that joins the east/west clean1 maps via EPSG:3832, load via one ee.Image(), then save here as EPSG:4326
  //var geo_map = geo1.unmask(0, false).add(geo2.unmask(0,false)).selfMask().clip(swp_extent)
  
  var geo_map = ee.Image(region_params.geo_map_clean);
} else {
  //print(ee.List(region_params.geo_map).length())
  // Run check to see if the region has been split into multiple areas
  if (ee.List(region_params.geo_map).length().getInfo() > 1) {
    var geo_map = ee.Image(region_params.geo_map[0]).unmask(0, false)
             .add(ee.Image(region_params.geo_map[1]).unmask(0,false))
             .selfMask();
  } else {
    var geo_map = ee.Image(region_params.geo_map);
  }
}

//var benthic_map = (vars.obia_2nd_pass) ? ee.Image(region_params.benthic_map_clean) : ee.ImageCollection(region_params.benthic_map).mosaic()
//var benthic_map = ee.Image(region_params.benthic_map)

// Run check to see if the region has been split into multiple areas
if (ee.List(region_params.benthic_map).length().getInfo() > 1) {
    var benthic_map = ee.Image(region_params.benthic_map[0]).unmask(0, false)
             .add(ee.Image(region_params.benthic_map[1]).unmask(0,false))
             .selfMask();
} else {
    var benthic_map = ee.Image(region_params.benthic_map);
}


var depth = ee.Image(region_params.pixels).select('depth');
var image = ee.Image(region_params.image);

var display_pal = (vars.geomorphic) ? map_palettes.geo : map_palettes.benthic;
//Map.centerObject(eg_area, 11)
Map.addLayer(depth, {min:0, max:2500}, 'Depth data', false);
Map.addLayer(image, {bands: ['b3','b2','b1'], min:200, max:1200}, 'Dove low tide', false);

if (vars.geomorphic) {
  if (vars.obia_2nd_pass) {
    if (ee.List(region_params.geo_map).length().getInfo() > 1) {
      var geo_map_display = ee.Image(region_params.geo_map[0]).unmask(0, false)
                       .add(ee.Image(region_params.geo_map[1]).unmask(0,false))
                       .selfMask();
    } else {
    var geo_map_display = ee.Image(region_params.geo_map);
    }
    Map.addLayer(geo_map_display, display_pal, 'Raw GEO classification', false);
  } else {
    Map.addLayer(geo_map, display_pal, 'Raw GEO classification', false);
  }
}
if (!vars.geomorphic) {
  Map.addLayer(geo_map, map_palettes.geo, 'Clean GEO classification', false);
  Map.addLayer(benthic_map, display_pal, 'Raw BENTHIC classification', false);
}

// 3. Object-based re-classificaiton and cleaning

/*

// if we want to retain the land/waves flags, need to add them in before makign the mask

######## Not that straight forwards - the land and bright masks are a LOT of not land and not breakign waves... =(

// add in land, for geomorphic clean up rules
  geo_map = geo_map.unmask(0).where({
    test: depth.eq(-2).and(globcover.select('landcover').neq(210)),
    value: ee.Image(1)
  })
  
  // change -3 to reef rim, hope that clouds have been handleded by masking
  geo_map = geo_map.unmask(0).where({
    test: depth.eq(-3),
    value: ee.Image(15)
  })
  
  // remask
  geo_map = geo_map.updateMask(geo_map.gt(0))

*/

/* OUTPUT EXTENT
  - to the mapping extent just so it doesn't balloon out
  - to the 'reef boundary' extent for noise/deep removal
*/  
var class_extent_mask = geo_map.gt(0)


/*

########
Initial small object clean
 - this was originally at the end, but we needed to massively reduce the number of objects to 
   iterate through in the OBIA cleaning, so this happens first now
 - future collabs with google might fix this, but need to change the parallel serialisation of vector procesing
 
 - includes a possible special case for:
      - geomorphic to clean up turbid areas over size threshold; fix shallow vs. deep lagoon
      - benthic to allow breaking waves (temporal class) to grow into surrounding class
########

*/

if (vars.geomorphic && !vars.obia_2nd_pass) {
  
  // make a smooth map with masked area as a value
  var smooth_map = geo_map
                      //.unmask(99)
                      .focal_mode({
                        radius: vars.smooth_radius, // relates to smoothness required
                        kernelType: 'circle', units: 'pixels', iterations: 2
                      })
  //smooth_map = smooth_map.updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)
  
  //replace small objects with smooth underneath
  var clean_map = geo_map.where({
    test: geo_map.connectedPixelCount(vars.small_object_geo, false).lt(vars.small_object_geo), 
    value: smooth_map
  //}).updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)
  }).updateMask(class_extent_mask)
  
  // shallow lagoon > 5m == deep lagoon
  clean_map = clean_map.where({
    test: clean_map.eq(11)
                   .and(depth.gt(500)),
    value: ee.Image(12)
  })
  
  /*// deep lagoon == deep (to hard to differentiate deep water vs. deep lagoon effectively over large areas)
  clean_map = clean_map.where({
    test: clean_map.eq(12),
    value: ee.Image(2)
  })*/
  
  // deep water in depth data == deep (s2 + ls8 data should be good enough for this)
  clean_map = clean_map.where({
    test: depth.gt(1000),
    value: ee.Image(2)
  })
  
  
  // LAND mask cleaning
  Map.addLayer(land_dist.lte(vars.dist_to_land), {}, "Land mask", false)
  
  // reef crest close to land -> TRF
  clean_map = clean_map.where({
    test: land_dist.lte(vars.dist_to_land)
                   .and(clean_map.eq(15)),
    value: ee.Image(16)
  })
  
  // TRF far from land -> ORF
  clean_map = clean_map.where({
    test: land_dist.gt(vars.dist_to_land)
                   .and(clean_map.eq(16)),
    value: ee.Image(14)
  })
  
  
  
  /*//CLEAN UP SMALL (but slightly larger) TURBID AREAS
  var smooth_noturbid = clean_map
                          .updateMask(clean_map.neq(3))
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(1.5),
                            kernelType: 'circle', units: 'pixels', iterations: 2
                          })
  
  clean_map = clean_map.where({
    test: clean_map.eq(3).connectedPixelCount(vars.small_object_geo.multiply(10), false).lt(vars.small_object_geo.multiply(10)), 
    value: smooth_noturbid
  }).updateMask(class_extent_mask)*/
}


if (!vars.geomorphic) {
  
  // make a smooth map with masked area as a value, and without temporal class (basically breaking waves)
  var smooth_map = benthic_map
                      //.unmask(99)
                      .focal_mode({
                        radius: vars.smooth_radius, // relates to smoothness required
                        kernelType: 'circle', units: 'pixels', iterations: 1
                      })
  //smooth_map = smooth_map.updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)
  
  //replace small objects with smooth underneath
  var clean_map = benthic_map.where({
    test: benthic_map.connectedPixelCount(vars.small_object_benthic, false).lt(vars.small_object_benthic),
    value: smooth_map
  //}).updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)
  }).updateMask(class_extent_mask)
  
  
  /*// CLEAN UP ALL TEMPORAL AREAS
  var smooth_notemp = benthic_map
                          .updateMask(benthic_map.neq(2))
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(2),
                            kernelType: 'circle', units: 'pixels', iterations: 3
                          })
  
  
  clean_map = clean_map1.where({
    test: benthic_map.eq(2), 
    value: smooth_notemp
  }).updateMask(clean_map1.gte(0))
  
  // this catches any left over unmasked temporal, and assigned it back to temporal
  clean_map = clean_map.where({
    test: clean_map.unmask(99).eq(99).and(clean_map1.eq(2)),
    value: ee.Image(2)
  })*/
  
}



if (vars.geomorphic && vars.obia_2nd_pass) {
  var clean_map = geo_map
}

Map.addLayer(clean_map, display_pal, 'Clean map - init smooth/loaded', false)

if (vars.obia_clean) {
  
  if (vars.geomorphic && !vars.fast_clean) { // SHOULD TRY TO PUT THIS OUT TO A MODULE TO KEEP THE RULES THE SAME EVERYWEHRE?
    
    // #########
    // THE PLAN - vectorise one/few class/es at a time, thus only spending resources on what is actually needed to clean up
    // #########
    
    // FUNCTION that maps over feature colleciton and assigns neighbour percentages
    var set_neighbour_properties = function(f) {
      // make the 1px buffer
      var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5))
      // reduce the classes in the buffer zone
      var diff_classes = ee.Dictionary(
        clean_map.unmask(ee.Image(0)).reduceRegion({
          reducer: ee.Reducer.frequencyHistogram(),
          geometry: diff.geometry(),
          scale: vars.image_data_scale,
          maxPixels: 1e11
        }).get('classification')
      )
      // calculate the percentages
      var diff_sum = diff_classes.toArray().reduce(ee.Reducer.sum(), [0]).get([0])
      var diff_percs = diff_classes.map(function(k,v){return(ee.Number(v).divide(diff_sum).multiply(100).toUint8())})
      
      /* NOW, we can try to do the class logic right here (see /users/mitchest/global_reefs/obia_dev),
         or we can return the neighbour % and do image logic via (painted) rasters */
      
      return(f.set(diff_percs))
    }
    
    // FUNCTION to reduce the map to vectors and map the neighbour properties function
    var reduce_neighbours = function() {
      // reduce map to vectors
      var map_fc = clean_map
            .updateMask(segment_id).updateMask(clean_map.eq(classn)) // only vectorise class/es of interest
            .reduceToVectors({
              scale: vars.image_data_scale, 
              eightConnected: false,
              bestEffort: true, 
              maxPixels: 1e13,
              tileScale: 1,
              geometry: reef_boundary
            })
      // map the function, calculate neighbour properties
      return(map_fc.map(set_neighbour_properties))
    }
    
    // first make a make size threshold, so we're not vecortising huge objects when we don't have to
    var segment_id = clean_map.connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels')
    //Map.addLayer(segment_id.reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))))
    Map.addLayer(clean_map.updateMask(segment_id).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false)
    
    // This is where we select the single or group of classes to vectorise for cleaning up
    //var classn = ee.Number(15) // one class
    var classn = clean_map.where({
      test: clean_map.neq(16) //TRF
              .and(clean_map.neq(15)) //RR
              .and(clean_map.neq(14)) //ORF
              .and(clean_map.neq(13)) //IRF
              //.and(clean_map.neq(12)) // deep L
              .and(clean_map.neq(11)), // shallow L 
      value: ee.Image(99) // 99 ensures it's ignored in logic
    })
    
    // Minimum size of object to reclass based on neighbourhood
    var max_size = ee.Number(1000).divide(vars.image_data_scale).pow(2) // the first number is the square dimension of the desired min size
    // calculate neighbours
    var map_fc_neighbours = reduce_neighbours()
    
    // #########
    // REEF RIM
    // #########
    
    var focus_class = ee.Number(15); //RR
    
    // start the object-based neighbourhood rules
    // paint out to rasters (only paint the layers needed)
    var objsize = ee.Image(30000).paint(map_fc_neighbours, 'count').rename('count');
    //var nb24 = ee.Image().byte().paint(map_fc_neighbours, '24').unmask(0).rename('nb24') //OCL
    var nb22 = ee.Image().byte().paint(map_fc_neighbours, '22').unmask(0).rename('nb22'); //SL ex
    var nb21 = ee.Image().byte().paint(map_fc_neighbours, '21').unmask(0).rename('nb21'); //Sl sh
    var nb16 = ee.Image().byte().paint(map_fc_neighbours, '16').unmask(0).rename('nb16'); //TRF
    var nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15'); //RR
    var nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14'); //ORF
    var nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13'); //IRF
    //var nb3 = ee.Image().byte().paint(map_fc_neighbours, '3').unmask(0).rename('nb3') //Turbid
    
    // RR surrounded by ORF --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb14.gt(75)),
      value: ee.Image(14)
    });
    
    // RR surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.gt(75)),
      value: ee.Image(13)
    });
    
    // RR surrounded by IRF + ORF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.add(nb14).gt(75)),
      value: ee.Image(13)
    });
    
    // RR with decent border to TRF --> TRF (often dark, probably seagrass)
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb16.gt(40)),
      value: ee.Image(16)
    });
    
    /*// RR surrounded by OCL --> OCL
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb24.gt(75)),
      value: ee.Image(24)
    })*/
    
    /* with 2nd/3rd pass method, we don't really need this
    // RR surrounded by IRF + ORF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.lte(75).and(nb14.lte(75))) // to ensure we're no re-writing previous rules
              .and(nb13.add(nb14).gt(75))
              .and(nb21.add(nb22).lte(0)), // to not get rid of complex reef rims (if touching slope, it's probably RR)
      value: ee.Image(13) // could try assigning to a place-holder, then deal with at the end?
    })*/
    
    /*// small RR objects touching OCL + stuff --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(objsize.lte(max_size))
              .and(nb13.lte(75).and(nb14.lte(75))) // to ensure we're no re-writing previous rules
              .and(nb24.gt(1)),
      value: ee.Image(14)
    })*/
    
    // ####
    // ORF
    // ####
    
    focus_class = ee.Number(14); // ORF
    
    //classn = ee.Number(14)
    //map_fc_neighbours = reduce_neighbours()
    //var nb22 = ee.Image().byte().paint(map_fc_neighbours, '22').unmask(0).rename('nb22') //SL ex
    //var nb21 = ee.Image().byte().paint(map_fc_neighbours, '21').unmask(0).rename('nb21') //Sl sh
    //nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15') //RR
    //nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13') //IRF
    //var nb1 = ee.Image().byte().paint(map_fc_neighbours, '1').unmask(0).rename('nb1') //Land
    
    // ORF surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.gt(75)),
      value: ee.Image(13)
    });
    
    // ORF surrounded by TRF --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb16.gt(75)),
      value: ee.Image(16)
    });
    
    // ORF surrounded by RR --> RR
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb15.gt(85)),
      value: ee.Image(15)
    })
    
    // ORF touching slope and RR --> RR
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb21.gt(0).or(nb22.gt(0)))
              .and(nb15.gt(0)),
      value: ee.Image(15)
    })
    
    /*// ORF touching land --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb1.gt(10)),
      value: ee.Image(16)
    })*/
    
    // ####
    // IRF
    // ####
    
    focus_class = ee.Number(13) // IRF
    
    //classn = ee.Number(13)
    //map_fc_neighbours = reduce_neighbours()
    //nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15') //RR
    //nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14') //ORF
    
    // IRF surrounded by ORF --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb14.gt(75)),
      value: ee.Image(14)
    })
    
    // IRF surrounded by TRF --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb16.gt(75)),
      value: ee.Image(16)
    })
    
    // IRF surrounded by RR --> RR
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb15.gt(85)),
      value: ee.Image(15)
    })
    
    /*// IRF touching land --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb1.gt(10)),
      value: ee.Image(16)
    })*/
    
    // ####
    // TRF
    // ####
    
    focus_class = ee.Number(16) // TRF
    
    //classn = ee.Number(16)
    //map_fc_neighbours = reduce_neighbours()
    //nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15') //RR
    //nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14') //ORF
    //nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13') //IRF
    
    // TRF surrounded by ORF --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb14.gt(75)),
      value: ee.Image(14)
    })
    
    // TRF surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.gt(75)),
      value: ee.Image(13)
    })
    
    // TRF surrounded by IRF + ORF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.add(nb14).gt(75)),
      value: ee.Image(13)
    })
    
    /*// TRF not touching land --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb1.lt(10)),
      value: ee.Image(13)
    })*/
    
    
    // ####
    // LAGOONS
    // ####
    
    var nb11 = ee.Image().byte().paint(map_fc_neighbours, '11').unmask(0).rename('nb11') // shallow lag
    //var nb12 = ee.Image().byte().paint(map_fc_neighbours, '12').unmask(0).rename('nb12') //deep lag
    
    // DL touching SL --> SL
    /* 
    This is a stop-gap until we have better depth product - below are the rules we want,
    but too much band-aiding is required to make it work, so for the moment just err on the side
    of shallow lagoon when it's mixed.
    */
    /*clean_map = clean_map.where({
      test: clean_map.eq(12)
              .and(nb11.gt(0)),
      value: ee.Image(11)
    })*/
    
    /*// SL sourrounded by DL --> DL
    clean_map = clean_map.where({
      test: clean_map.eq(11)
              .and(nb12.gt(75)),
      value: ee.Image(12)
    })*/
    
    /*// DL sourrounded by SL --> SL
    clean_map = clean_map.where({
      test: clean_map.eq(12)
              .and(nb11.gt(75)),
      value: ee.Image(11)
    })*/
    
    /*// DL/SL surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(11).or(clean_map.eq(12))
              .and(objsize.lte(max_size))
              .and(nb13.gt(80)),
      value: ee.Image(13)
    })*/
    
    // SL surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(11)
              .and(objsize.lte(max_size))
              .and(nb13.gt(80)),
      value: ee.Image(13)
    });
    
    /*// DL/SL touching OCL --> OCL
    clean_map = clean_map.where({
      test: clean_map.eq(11).or(clean_map.eq(12))
              .and(nb24.gt(0)),
      value: ee.Image(24)
    })*/
    
    
    /*// ####
    // Turbid
    // ####
    
    focus_class = ee.Number(3) // turbid
    
    // Turb surrounded by IRF --> IRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb13.gt(75)),
      value: ee.Image(13)
    })
    
    // Turb surrounded by ORF --> ORF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb14.gt(75)),
      value: ee.Image(14)
    })
    
    // Turb surrounded by TRF --> TRF
    clean_map = clean_map.where({
      test: clean_map.eq(focus_class)
              .and(nb16.gt(75)),
      value: ee.Image(16)
    })*/
  
  } else if (vars.geomorphic && vars.fast_clean) {
    print("Executing the fast version OBIA");
    
    /* fast version of the geo clean up
      - blanket version assigns the underlying most common in neighbourhood
      - mode OBIA version iterates through objects+buffers but take the mode instead of doing the class percs, to see if that speeds things up
    */
    
    
    //############
    //# blanket version
    //############
    // make a very smooth map to capture the broader neighbourhood
    var smooth_map = clean_map
                        .focal_mode({
                          radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 2
                        })
    
    
    // first make a make size threshold, so we're not vectorising huge objects when we don't have t
    // - the unmask(99) captures small no data values/ data gaps
    var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt().multiply(2)).select('labels').pow(2).log().int()
    Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false)
    
    
    // replace small objects with smooth underneath
    var clean_map = clean_map.unmask(0).where({
      test: segment_id.gt(0), 
      value: smooth_map
    }).selfMask()
    //############
    //############
    
    
    /*    
    //############
    //# mode OBIA version
    //############
    
    // #########
    // THE FASTER PLAN - vectorise one/few class/es at a time, thus only spending resources on what is actually needed to clean up
    //                 - BUT, just assign the mode of the neighbours, so save resouces even further??
    // #########
    
    // FUNCTION that maps over feature colleciton and assigns neighbour percentages
    var set_neighbour_mode = function(f) {
      // make the 1px buffer
      var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5))
      // reduce the classes in the buffer zone
      var diff_mode = ee.Number(ee.Dictionary(
        clean_map.unmask(ee.Image(0)).reduceRegion({
          reducer: ee.Reducer.mode(),
          geometry: diff.geometry(),
          scale: vars.image_data_scale,
          maxPixels: 1e11
        })).get('classification'))
      
      return(f.set('mode',diff_mode))
    }
    
    // FUNCTION to reduce the map to vectors and map the neighbour properties function
    var reduce_neighbours_mode = function() {
      // reduce map to vectors
      var map_fc = clean_map.unmask(0)
            .updateMask(classn.gt(0)) // only vectorise class/es of interest
            .reduceToVectors({
              scale: vars.image_data_scale, 
              eightConnected: false,
              bestEffort: true, 
              maxPixels: 1e13,
              tileScale: 1,
              geometry: reef_boundary
            })
      // map the function, calculate neighbour properties
      return(map_fc.map(set_neighbour_mode))
    }
    
    // first make a make size threshold, so we're not vecortising huge objects when we don't have to
    var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels')
    Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false)
    
    // This is where we select the single or group of classes to vectorise for cleaning up
    var classn = segment_id.where({
      test: clean_map.neq(16) //TRF
              .and(clean_map.neq(15)) //RR
              .and(clean_map.neq(14)) //ORF
              .and(clean_map.neq(13)) //IRF
              //.and(clean_map.neq(12)) // deep L
              .and(clean_map.neq(11)) // shallow L 
              .and(clean_map.unmask(0).neq(0)), // no data values (want to reclaim the small gaps 
      value: ee.Image(0) // 99 ensures it's ignored in logic
    })
    
    // calculate neighbours
    var map_fc_neighbours = reduce_neighbours_mode()
    
    //print(map_fc_neighbours.limit(10))
    
    var mode_map = ee.Image().byte().paint(map_fc_neighbours, 'mode').unmask(0).rename('mode') // paint out the mode values to an image
    //Map.addLayer(mode_map, display_pal, "mode map", false)
    
    // replace small objects with mode underneath
    var clean_map = clean_map.unmask(0).where({
      test: segment_id.gt(0), 
      value: mode_map
    }).selfMask()
    
    //############
    //############
    */
    
  } else {
    
    // BENTHIC CLEAN-UP RULES
    
    // reclaim shallow no data to surrounding class
    var smooth_map = clean_map
                        .focal_mode({
                          radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 2
                        })
    
    var clean_map = clean_map.unmask(0).where({
      test: geo_map.gt(2).and(clean_map.eq(0)), 
      value: smooth_map
    }).selfMask()
    
    // cut benthic off to < 10 - 15 m
    clean_map = clean_map.where({
      test: depth.gt(1500),
      value: ee.Image(0)
    })
    
    // Deep (or land or missing) in geo == masked from benthic
    clean_map = clean_map.where({
      test: geo_map.unmask(0).lte(2),
      value: ee.Image(0)
    })
    
    /*// Deep lagoon in geo == masked from benthic
    clean_map = clean_map.where({
      test: geo_map.eq(12),
      value: ee.Image(0)
    })*/
    
    // Deep/shallow lagoon in geo && rock in benthic == seagrass
    clean_map = clean_map.where({
      test: geo_map.eq(11).or(geo_map.eq(12))
                   .and(clean_map.eq(13)),
      value: ee.Image(14)
    })
    
    // Deep/shallow lagoon in geo && coral in benthic == sand
    clean_map = clean_map.where({
      test: geo_map.eq(11).or(geo_map.eq(12))
                   .and(clean_map.eq(15)),
      value: ee.Image(11)
    })
    
    /*// turbid in geo == turbid (temporal - class num 2)
    // ############## ---> need to decide here whether to push geo turbid through regardless of benthic class
    clean_map = clean_map.where({
      test: geo_map.eq(3),
      value: ee.Image(2)
    })*/
    
    /*
    // Ignore in benthic + ORF in geo == rock
    clean_map = clean_map.where({
      test: clean_map.eq(0)
                     .and(geo_map.eq(14)),
      value: ee.Image(13)
    })
    
    // Ignore in benthic + IRF in geo == sand
    clean_map = clean_map.where({
      test: clean_map.eq(0)
                     .and(geo_map.eq(13)),
      value: ee.Image(11)
    })
    
    // Ignore in benthic + TRF in geo == sand
    clean_map = clean_map.where({
      test: clean_map.eq(0)
                     .and(geo_map.eq(16)),
      value: ee.Image(11)
    })
    
    // Ignore in benthic + RR in geo == rock
    */
    
    /*// seagrass in benthic + ORF/RR/slope in geo == coral/algae
    clean_map = clean_map.where({
      test: clean_map.eq(14)
                     .and(geo_map.eq(14).or(geo_map.eq(15)).or(geo_map.eq(21)).or(geo_map.eq(22))),
      value: ee.Image(15)
    })*/
    
    // ####--> CR: "Seagrass neighbouring deep water or no data not shallow a rock or coral algae class"
    
    // coral or algae in benthic + TRF in geo == seagrass
    clean_map = clean_map.where({
      test: clean_map.eq(15)
                     .and(geo_map.eq(16)),
      value: ee.Image(14)
    })
    
    // rock in benthic + TRF in geo == sand
    clean_map = clean_map.where({
      test: clean_map.eq(13)
                     .and(geo_map.eq(16)),
      value: ee.Image(11)
    })
    
    // seagrass in benthic and slope in geo == coral
    clean_map = clean_map.where({
      test: clean_map.eq(14)
                     .and(geo_map.eq(21).or(geo_map.eq(22))),
      value: ee.Image(15)
    })
    
    // coral or algae in benthic + plat in geo == seagrass
    clean_map = clean_map.where({
      test: clean_map.eq(15)
                     .and(geo_map.eq(23)),
      value: ee.Image(14)
    })
    
    /*// BMA in benthic and slope/plat in geo == sand
    clean_map = clean_map.where({
      test: clean_map.eq(18)
                     .and(geo_map.eq(2).or(geo_map.eq(12)).or(geo_map.eq(21)).or(geo_map.eq(22)).or(geo_map.eq(23))),
      value: ee.Image(11)
    })*/
    
  }
  
/*  // ####
  // Final small object clean (safety net for oddities with scaling and border buffers??)
  // ####
  
  var clean_size = (vars.geomorphic) ? vars.small_object_geo : vars.small_object_benthic
  
  var map_vsmooth = clean_map
                        .focal_mode({
                          radius: 10, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 1
                        })
                        .updateMask(class_extent_mask)
  
  clean_map = clean_map.where({
    test: clean_map.connectedPixelCount(clean_size, false).lt(clean_size), 
    value: map_vsmooth
  })*/

}

// final smooth
if (vars.smooth_output) {
  // smooth the output lightly to make nice edges, and get rid of noise
  var noise_smooth = clean_map.unmask(99) // unmasking to a value allows us to include masked areas in the smooth, then re-mask after
                        .focal_mode({
                          radius: 2, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 2
                        })
  clean_map = clean_map.updateMask(noise_smooth.neq(99)).updateMask(clean_map.gt(1)) // this ignores 0/land; make it .gt(2) if you want to mask deep too
} else {
  // just clip to the classified extent and move on
  if (vars.geomorphic) {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  } else {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  }
}

// 4. Export data

var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;

if (vars.do_export) {
  print("For export, the image data scale must be set to:", vars.image_data_scale);
  
  if (vars.export_small_area) {
    var export_convhull = export_small;
  } else {
    //var export_convhull = clean_map.gt(2).reduceToVectors({scale: 1000, maxPixels: 1e13, bestEffort: true, geometry: region_extent, crs: "EPSG:4326"}).geometry().convexHull({maxError: 100})
    var export_convhull = reef_boundary;
  }
  Map.addLayer(export_convhull, {}, "Export footprint", true);
  var output_name = (vars.obia_2nd_pass) ? output_name + "-p2" : output_name;
  Export.image.toAsset({
    image: clean_map.set(vars),
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: export_convhull,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  /*Export.image.toCloudStorage({
    image: clean_map,//.set(vars),
    description: 'swp_geo_clean',
    bucket: 'mitchest_unet_bucket',
    fileNamePrefix: 'swp_geo_clean',
    region: export_convhull,
    scale: 25,
    crs: 'EPSG:4326',
    maxPixels: 1e13
  })*/
  
} else {
  if (vars.show_eg_area) {
    if (vars.reproject_display) {
      Map.addLayer(clean_map.clip(eg_area).reproject(ee.Projection('EPSG:4326').atScale(vars.image_data_scale)), display_pal, output_name + '_final', false);
    } else {
      Map.addLayer(clean_map.clip(eg_area), display_pal, output_name + '_final', false);
    }
  } else {
    if (vars.reproject_display) {
      Map.addLayer(clean_map.reproject(ee.Projection('EPSG:4326').atScale(vars.image_data_scale)), display_pal, output_name + '_final', false);
    } else {
      Map.addLayer(clean_map, display_pal, output_name + '_final', false);
    }
  }
}

//Generate title
var title = ui.Label({
  value: 'Classes',
  style: {fontWeight: 'bold', fontSize: '12px'}
});

// generate the legend
var geo_legend = pkg_vis.discrete_legend(map_palettes.geo_atlas_names, map_palettes.geo_atlas_cols, 'Geomorphic Zone', false);
var benthic_legend = pkg_vis.discrete_legend(map_palettes.benthic_atlas_names, map_palettes.benthic_atlas_cols, 'Benthic Habitat', false);
//var mask_legend = pkg_vis.discrete_legend(["Low confidence depth","Water conditions"], ["#f7f7f7","#bababa"], 'Confidence Mask reason', false)
var legend = (vars.geomorphic) ? geo_legend : benthic_legend;
pkg_vis.add_lgds([title, legend]);//, mask_legend])
// generate the legend