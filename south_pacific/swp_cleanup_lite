/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var eg_area = /* color: #d63000 */ee.Geometry.Polygon(
        [[[178.11792537642418, -19.163235696114032],
          [178.11912700606285, -19.160641289483575],
          [178.1160371012777, -19.1590197646103],
          [178.1149213023275, -19.161452045940777]]]),
    export_small = 
    /* color: #d63000 */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[179.83152435737827, -16.760307422251895],
          [179.83152435737827, -16.816841987280164],
          [179.93280456978061, -16.816841987280164],
          [179.93280456978061, -16.760307422251895]]], null, false),
    swp_extent = 
    /* color: #d63000 */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[161.99244048631044, -7.029171821347217],
          [161.99244048631044, -24.50136375705747],
          [192.84204986131044, -24.50136375705747],
          [192.84204986131044, -7.029171821347217]]], null, false),
    geo1 = ee.Image("projects/coral_atlas/sw_pacific/in_out/swp_geo_east"),
    geo2 = ee.Image("projects/coral_atlas/sw_pacific/in_out/swp_geo_west");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
///////////////////////////////
// Global coral atlas project - SWP region
// Contact: mitchell.lyons@gmail.com
// Description:
// - Developing a process to combine OBIA and supervised classification
// - This script loads the raw classification data (from *_classification script)
// - Then applied some cleanup and object-based relational rules
///////////////////////////////

// Table of contents
// 1. Setting constants
// 2. Data loads & vis
// 3. OBIA clean up rules
// 4. Export

// Load and libraries needed
var map_palettes = require('users/mitchest/global_reefs:Modules/colour_pals')
var param_module = require('users/mitchest/global_reefs:Modules/reef_params')

// ###########################################
// SENSOR GENERICS
var sensor_params = param_module.dove         //<------------ THIS IS WHERE YOU CHOOSE THE SENSOR
// REGION AND SENSOR SPECIFIC LOAD PATHS
var region_params = param_module.swpac  //<------------ THIS IS WHERE YOU CHOOSE THE REGION
//  ^^ all the data paths are in this module ^^
// ###########################################


var geo_map = ee.ImageCollection(region_params.geo_map).mosaic()
var depth = ee.Image(region_params.depth)
var class_extent_mask = geo_map.gt(0) // just so it doesn't balloon out


var smooth_map = geo_map
                    .unmask(99)
                    .focal_mode({
                      radius: 5, // relates to smoothness required
                      kernelType: 'circle', units: 'pixels', iterations: 1
                    })
//smooth_map = smooth_map.updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)

//replace small objects with smooth underneath
var clean_map = geo_map.where({
  test: geo_map.connectedPixelCount(60, false).lt(60), 
  value: smooth_map
}).updateMask(smooth_map.neq(99)).updateMask(class_extent_mask)

// shallow lagoon > 10m == deep lagoon
clean_map = clean_map.where({
  test: clean_map.eq(11)
                 .and(depth.gt(1000)),
  value: ee.Image(12)
})

// deep lagoon == deep (to ignore - decided Dove just cannot handle deep water classes effectively over large areas)
clean_map = clean_map.where({
  test: clean_map.eq(12),
  value: ee.Image(2)
})




/*// final smooth
if (vars.smooth_output) {
  // smooth the output lightly to make nice edges, and get rid of noise
  var noise_smooth = clean_map.unmask(99) // unmasking to a value allows us to include masked areas in the smooth, then re-mask after
                        .focal_mode({
                          radius: 3, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 2
                        })
  clean_map = clean_map.updateMask(noise_smooth.neq(99)).updateMask(geo_map.gt(2))
} else {
  // just clip to the classified extent and move on
  clean_map = clean_map.updateMask(geo_map.gt(2))
}
*/

// 4. Export data

var export_convhull = export_small
//var export_convhull = clean_map.gt(2).reduceToVectors({scale: 1000, maxPixels: 1e13, bestEffort: true, geometry: swp_extent, crs: "EPSG:4326"}).geometry().convexHull({maxError: 100})

Map.addLayer(export_convhull, {}, "Export footprint", true)
Map.addLayer(clean_map, map_palettes.geo, "out map", false)

Export.image.toAsset({
  image: clean_map,
  description: 'swp_geo_clean',
  assetId: 'sw_pacific/in_out/swp_geo_clean',
  region: export_convhull,
  scale: 25,
  crs: 'EPSG:4326',
  maxPixels: 1e13,
  pyramidingPolicy: {'.default': 'mode'}
})

