/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var imageVisParam = {"opacity":1,"bands":["depth"],"min":1500,"max":2500,"gamma":1},
    imageVisParam2 = {"opacity":1,"bands":["b3","b2","b1"],"min":44.94,"max":2202.06,"gamma":1},
    waves = ee.Image("projects/coral_atlas/coral_sea/in_out/cosea_waves"),
    wavespng = ee.Image("projects/coral_atlas/png_solomons/in_out/pns_waves"),
    wcmc = ee.FeatureCollection("projects/coral_atlas/global_datasets/wcmc_reefs_2018v4_dissolved"),
    fill_inSand = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry({
      "type": "GeometryCollection",
      "geometries": [
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                -66.74061880965272,
                11.792670336580802
              ],
              [
                -66.69804678816834,
                11.766455124222423
              ],
              [
                -66.68809042830506,
                11.762757905936008
              ],
              [
                -66.65839370111127,
                11.763933577110144
              ],
              [
                -66.62285910506287,
                11.782251769661983
              ],
              [
                -66.61633597273865,
                11.80913758717407
              ],
              [
                -66.61564932723084,
                11.835684743762886
              ],
              [
                -66.62251578230897,
                11.861221348103054
              ],
              [
                -66.64036856551209,
                11.870628968492857
              ],
              [
                -66.65890799422303,
                11.861221348103054
              ],
              [
                -66.69255362410584,
                11.848453344406582
              ],
              [
                -66.7289458360199,
                11.842405134265736
              ],
              [
                -66.78868399519959,
                11.843077164227081
              ],
              [
                -66.83125601668397,
                11.8464372892388
              ],
              [
                -66.84498892684022,
                11.823587624634808
              ],
              [
                -66.85116873641053,
                11.798047506715022
              ],
              [
                -66.87863455672303,
                11.770488396584954
              ],
              [
                -66.86146841902772,
                11.753682704999855
              ],
              [
                -66.83125601668397,
                11.747632404865472
              ],
              [
                -66.79692374129334,
                11.758388402093782
              ],
              [
                -66.74130545516053,
                11.784604383843108
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                -66.59299002547303,
                11.916150539728235
              ],
              [
                -66.60157309432068,
                11.915142764566312
              ],
              [
                -66.60019980330506,
                11.907080428644857
              ],
              [
                -66.60431967635193,
                11.90170540511712
              ],
              [
                -66.60500632185975,
                11.894650525458932
              ],
              [
                -66.60740958113709,
                11.88625162063055
              ],
              [
                -66.60706625838318,
                11.881884087692619
              ],
              [
                -66.61118613143006,
                11.876172592773058
              ],
              [
                -66.60054312605897,
                11.863405288903705
              ],
              [
                -66.59539328475037,
                11.854669420810465
              ],
              [
                -66.5916167344574,
                11.84022102547717
              ],
              [
                -66.58303366560975,
                11.821067324163797
              ],
              [
                -66.57994376082459,
                11.804600790297993
              ],
              [
                -66.58269034285584,
                11.782755902968642
              ],
              [
                -66.58749686141053,
                11.776706242230672
              ],
              [
                -66.58646689314881,
                11.773345262049006
              ],
              [
                -66.57719717879334,
                11.784436340641351
              ],
              [
                -66.56861410994568,
                11.808297445270048
              ],
              [
                -66.56277762312928,
                11.840557043350062
              ],
              [
                -66.56346426863709,
                11.865085231466539
              ],
              [
                -66.57136069197693,
                11.88793142233378
              ],
              [
                -66.57788382430115,
                11.897674067723905
              ],
              [
                -66.58372031111756,
                11.907416364085545
              ]
            ]
          ],
          "evenOdd": true
        }
      ],
      "coordinates": []
    }),
    coral_sand = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.MultiPolygon(
        [[[[-74.19551221839951, 11.269753822643308],
           [-74.19542638771104, 11.267228540620984],
           [-74.19422475807237, 11.26394564084247],
           [-74.1889890860753, 11.264534882023232],
           [-74.19036237709092, 11.266555128336542],
           [-74.19147817604112, 11.268659536489745],
           [-74.19319478981065, 11.269753822643308]]],
         [[[-74.14509609198214, 11.301158862873043],
           [-74.15033176397921, 11.30141136223512],
           [-74.15119007086398, 11.29871802424232],
           [-74.15333583807589, 11.297118842840083],
           [-74.15273502325655, 11.29535131617955],
           [-74.14947345709444, 11.295940492943252],
           [-74.14629772162081, 11.299223027042988]]],
         [[[-74.11667818521566, 11.331032763941211],
           [-74.11830896829672, 11.329644158357933],
           [-74.11800856088705, 11.327119403659273],
           [-74.1167211005599, 11.32682484749268],
           [-74.1150474021346, 11.327035244785476],
           [-74.11483282541342, 11.327413959522541],
           [-74.11461824869222, 11.32775059442341],
           [-74.11375994180746, 11.328297625292283],
           [-74.1149615648535, 11.329854552168111]]],
         [[[-74.13985247110433, 11.328550100724998],
           [-74.1412686774642, 11.329223367455972],
           [-74.14311403726644, 11.328129308213281],
           [-74.14341444467611, 11.324931264893605],
           [-74.14023870920248, 11.324468387240769],
           [-74.13972372507162, 11.32556246048599],
           [-74.13912291025228, 11.32606741595718],
           [-74.13847918008871, 11.326361972903733],
           [-74.13706297372885, 11.327035244785476],
           [-74.13762087320394, 11.327918911725254]]],
         [[[-74.09500593637533, 11.32867633835779],
           [-74.09852499460287, 11.327413959522541],
           [-74.10109991525717, 11.324131748477422],
           [-74.09758085702963, 11.317398890046192],
           [-74.0841054389388, 11.312854121083918],
           [-74.07303328012533, 11.315799812895797],
           [-74.07303328012533, 11.322448548719553],
           [-74.08067221139974, 11.326740688532219]]],
         [[[-74.06015867685385, 11.333809954876068],
           [-74.06196112131185, 11.333136698944948],
           [-74.06496519540853, 11.330022869640295],
           [-74.04900068735189, 11.323542629688488],
           [-74.0493440101058, 11.329181288331721],
           [-74.05140394662924, 11.330864448472079],
           [-74.05251974557943, 11.3319584972503]]],
         [[[-59.64785187601957, 13.276755068674543],
           [-59.648109368085, 13.278300491161225],
           [-59.64871018290434, 13.27946999353129],
           [-59.649525574444866, 13.279428225686514],
           [-59.65042679667387, 13.279637064838537],
           [-59.65210049509916, 13.279177618466939],
           [-59.65334504008207, 13.27721451963049],
           [-59.652787140606975, 13.272954122878913],
           [-59.65184300303373, 13.267941795732481],
           [-59.64948265910063, 13.260840821954897],
           [-59.64737980723295, 13.25561938537905],
           [-59.64725106120024, 13.252653559483559],
           [-59.645577362774944, 13.25319660073212],
           [-59.64566319346342, 13.253572551655623],
           [-59.64562027811918, 13.25419913523696],
           [-59.64549153208647, 13.254825717204266],
           [-59.64540570139799, 13.25582824499461],
           [-59.64523404002104, 13.256413050963967],
           [-59.645276955365276, 13.257666201877335],
           [-59.644761971234416, 13.2590864317725],
           [-59.64467614054594, 13.25958768740206],
           [-59.64467614054594, 13.260966135054943],
           [-59.64416115641508, 13.261425615869136],
           [-59.64416115641508, 13.262762282390721],
           [-59.644075325726604, 13.264057171074441],
           [-59.64471905589018, 13.264307793893849],
           [-59.64471905589018, 13.265101431117108],
           [-59.645062378644084, 13.265727984989061],
           [-59.645534447430705, 13.266187456801848],
           [-59.64583485484037, 13.266354537245684],
           [-59.64536278605375, 13.26698108788689],
           [-59.64549153208647, 13.267357017496215],
           [-59.64600651621733, 13.267607636912645],
           [-59.64617817759428, 13.268651881698789],
           [-59.64600651621733, 13.269612582938288],
           [-59.646521500348186, 13.26973789151555],
           [-59.646564415692424, 13.270656819107293],
           [-59.646821907757854, 13.271408666369688],
           [-59.64746563792143, 13.27182635828775],
           [-59.647208145856, 13.27236935670747],
           [-59.647036484479045, 13.273037660788477],
           [-59.647551468609905, 13.273622425350931],
           [-59.64798062205229, 13.274499569554793],
           [-59.64733689188871, 13.27508433059739],
           [-59.647551468609905, 13.276003237962318]]],
         [[[-59.648180973911856, 13.251167174411833],
           [-59.6491251114851, 13.248744345426353],
           [-59.64805222787914, 13.245444246453017],
           [-59.64865304269848, 13.232953593396864],
           [-59.64607812164134, 13.233172927259346],
           [-59.64513398351438, 13.232974490972857],
           [-59.644189846897696, 13.232744714154677],
           [-59.64384652414379, 13.232786490017439],
           [-59.64311696329174, 13.233663781480884],
           [-59.64303113260326, 13.234791723006431],
           [-59.64388943948803, 13.235167702354463],
           [-59.64457608499584, 13.235961434627988],
           [-59.64410401620922, 13.236838714658163],
           [-59.64491940774975, 13.237172915743324],
           [-59.64552022256908, 13.238008416450025],
           [-59.64560605325756, 13.239011013514748],
           [-59.64534856119213, 13.239386986349933],
           [-59.64624978342113, 13.240222479461025],
           [-59.64676476755199, 13.240932646351622],
           [-59.64624978342113, 13.241893457083348],
           [-59.64504815378246, 13.242060554214877],
           [-59.64457608499584, 13.242979586388424],
           [-59.64474774637279, 13.24431635426599],
           [-59.64530564584789, 13.244399902014614],
           [-59.64586354532299, 13.245068282971348],
           [-59.64582062997875, 13.24648858641076],
           [-59.64513398447094, 13.247867108293642],
           [-59.644962323093985, 13.24999753584459],
           [-59.64526273050365, 13.250916538049333],
           [-59.645434391880606, 13.251751991586934],
           [-59.64560605325756, 13.252670987164736],
           [-59.645734799290274, 13.2531304836518],
           [-59.647193920994376, 13.252462124838239]]],
         [[[-59.64023692615356, 13.190233842129457],
           [-59.6408377409729, 13.190254733700334],
           [-59.64126689441528, 13.190212950556798],
           [-59.64193208189614, 13.190223397975833],
           [-59.64224321810497, 13.190207729138583],
           [-59.64311225421753, 13.190400974646476],
           [-59.64354140765991, 13.189001236287835],
           [-59.64373452670898, 13.186347978900702],
           [-59.643391203955076, 13.182232239222676],
           [-59.641137179046154, 13.179119273369105],
           [-59.641094263701916, 13.17903570327006],
           [-59.64081614819463, 13.179891483176275],
           [-59.64012950268682, 13.179682558534545],
           [-59.639957841309865, 13.180163084943826],
           [-59.64038699475225, 13.179912375630636],
           [-59.640451367768605, 13.180163084943826],
           [-59.6401080450147, 13.180580933228226],
           [-59.6406659444898, 13.181186811973005],
           [-59.640687402161916, 13.18145841230254],
           [-59.64040845242437, 13.182189642460237],
           [-59.639979298981984, 13.182189642460237],
           [-59.639464314851125, 13.18191804294252],
           [-59.63942139950689, 13.182523918375747],
           [-59.63987201062139, 13.182607487283263],
           [-59.64002221432622, 13.183568527667513],
           [-59.63976472226079, 13.184007262239735],
           [-59.63905661908086, 13.184550456334023],
           [-59.63890641537603, 13.184822052928784],
           [-59.639249738129934, 13.18536524521345],
           [-59.63935702649053, 13.185615948937937],
           [-59.63912099209722, 13.185824868512002],
           [-59.63888495770391, 13.185720408747283],
           [-59.63886350003179, 13.186451626163363],
           [-59.63867038098272, 13.187057490366062],
           [-59.638498719605764, 13.187621569481244],
           [-59.63856309262212, 13.188394564673775],
           [-59.638219769868215, 13.188540806732592],
           [-59.63860600796636, 13.189209340744714],
           [-59.63912099209722, 13.189543607065266],
           [-59.639442857179006, 13.18989876453008],
           [-59.63978617993291, 13.1902748130481]]]]),
    benthic_mask = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry.MultiPolygon(
        [[[[-72.3127864666104, 11.868508611789084],
           [-72.49200094414947, 11.781139001543389],
           [-72.47552145196197, 11.746183363671546],
           [-72.31141317559478, 11.821466902751299],
           [-72.29768026543853, 11.849020886654596]]],
         [[[-59.62862968853468, 13.110573686817565],
           [-59.63008881023878, 13.109633258861464],
           [-59.63116169384474, 13.10915259429568],
           [-59.63339329174513, 13.106331283348398],
           [-59.6335434674766, 13.101848459097273],
           [-59.62880134991163, 13.100333277793316],
           [-59.625990394864026, 13.105787916043736],
           [-59.62489605358595, 13.106059599846036],
           [-59.62496042660231, 13.107668797756103],
           [-59.626011852536145, 13.109800446316395],
           [-59.62712765148634, 13.110991653644112]]]]),
    sg_sand = 
    /* color: #0b4a8b */
    /* shown: false */
    ee.Geometry.MultiPolygon(
        [[[[-67.02525825973082, 18.510982886203763],
           [-67.0297214555316, 18.508703949624042],
           [-67.02023716445494, 18.50695403129695],
           [-67.02045174117613, 18.509843421707224]]],
         [[[-71.21094326052344, 19.864139109697476],
           [-71.21849636110937, 19.86478489915778],
           [-71.22742275271094, 19.8337840399446],
           [-71.219869652125, 19.830877399028708],
           [-71.20854000124609, 19.836044723887813],
           [-71.20854000124609, 19.8518686103813],
           [-71.20716671023047, 19.859941414108583]]],
         [[[-59.44958129012291, 13.166014249404897],
           [-59.436620856162946, 13.169190062038512],
           [-59.4437448033065, 13.18264502168952],
           [-59.46623244368736, 13.191503162585612],
           [-59.4836560734481, 13.196767754635218],
           [-59.485372687217634, 13.197519829955317],
           [-59.52159323775474, 13.225428542596273],
           [-59.538018705110495, 13.238995437675518],
           [-59.54311480470197, 13.231841143915194],
           [-59.535796874721946, 13.212184615021432],
           [-59.487861777183454, 13.186572727532344],
           [-59.47095313155357, 13.179636523495745],
           [-59.45679106795494, 13.169775075663141]]],
         [[[-59.561817682380195, 13.065887598538572],
           [-59.56542257129621, 13.060954642145346],
           [-59.54096082508039, 13.048245554909414],
           [-59.53641179859113, 13.037459040667839],
           [-59.53400853931379, 13.034114289561092],
           [-59.5262837773509, 13.032358277134644],
           [-59.5112634068675, 13.037626277036432],
           [-59.49701551258039, 13.044399254960508],
           [-59.494612253303046, 13.051590114920558],
           [-59.49401143848371, 13.057359374563472],
           [-59.487659967536445, 13.059282431174758],
           [-59.48276761829328, 13.06438263923812],
           [-59.48971990405988, 13.071322097403355],
           [-59.51941732227277, 13.058279099158389],
           [-59.5526337987132, 13.072325376416265]]],
         [[[-59.6431544470692, 13.32356431639109],
           [-59.64993507145885, 13.316924346744539],
           [-59.65336829899791, 13.311662354637335],
           [-59.654269521226915, 13.306859642986847],
           [-59.65045005558971, 13.306776116724372],
           [-59.64208156346324, 13.309741281405369],
           [-59.638819997301134, 13.319805865382458],
           [-59.64010745762828, 13.322979672290812]]],
         [[[-59.64344972830952, 13.227177403567467],
           [-59.64535946112812, 13.22609120380953],
           [-59.644093458473094, 13.22427389723864],
           [-59.64312786322773, 13.222937019389605],
           [-59.642054979621776, 13.222498354748279],
           [-59.641539995490916, 13.223062351999316],
           [-59.64211935263813, 13.225213885087282],
           [-59.64272016745747, 13.226028538291207],
           [-59.64310640555561, 13.226801411891271]]],
         [[[-59.65057710963911, 13.307315954292372],
           [-59.6528087075395, 13.305645426717534],
           [-59.65302328426069, 13.304141942051558],
           [-59.652679961506784, 13.298503791473369],
           [-59.65220789272016, 13.291320180022515],
           [-59.651907485310495, 13.28789536012371],
           [-59.65109209376997, 13.286475298668543],
           [-59.64761595088667, 13.286099398656837],
           [-59.64547018367475, 13.29971496080724]]]]),
    fill_inCorals = 
    /* color: #ffc82d */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-59.627784323900265, 13.114247265225053],
          [-59.62895376703076, 13.114424898560143],
          [-59.62940437814526, 13.114017386600981],
          [-59.6298442604237, 13.113108319028132],
          [-59.63046653291516, 13.112836643009423],
          [-59.6304558040791, 13.112094756968233],
          [-59.630294871538204, 13.111843978082097],
          [-59.628546071260494, 13.111676792015961],
          [-59.62692065555892, 13.11259631174672],
          [-59.62733371278576, 13.114080080792487]]]),
    mid_mask = 
    /* color: #00ffff */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-66.76070586032537, 11.757750151521908],
          [-66.7155589181867, 11.771698741770084],
          [-66.72002211398748, 11.773547297028017],
          [-66.72603026218084, 11.77489169304431],
          [-66.73221007175115, 11.776068034164506],
          [-66.73590080541996, 11.777076379378402],
          [-66.74371138400701, 11.774723643901861],
          [-66.74920454806951, 11.771698741770084],
          [-66.7569293100324, 11.766657164263913],
          [-66.76413908786444, 11.761951608550449]]]),
    trf_sand = 
    /* color: #bf04c2 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[-66.62578001804022, 11.787999209489582],
          [-66.66371718234686, 11.76850575341455],
          [-66.65084257907537, 11.755397307573784],
          [-66.62578001804022, 11.76749743359991],
          [-66.6218318063703, 11.778084607227719]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/

///////////////////////////////
// Global coral atlas project - SEC 
// Contact: mitchell.lyons@gmail.com
// Region coordinator: Rodney Borrego (rodbio2008@gmail.com)...Note: previous geometries for geo 3 are in version saved 21/04 15:58. I removed geoms as the script crashed.
// Description:
// - Developing a process to combine OBIA and supervised classification
// - This script loads the raw classification data (from *_classification script)
// - Then applied some cleanup and object-based relational rules
///////////////////////////////

// Table of contents
// 1. Setting constants
// 2. Data loads & vis
// 3. OBIA clean up rules
// 4. Export

// Load and libraries needed
var map_palettes = require('users/mitchest/global_reefs_modules:colour_pals');
var pkg_vis = require('users/mitchest/global_reefs_modules:pkg_vis');
var param_module = require('users/mitchest/global_reefs_modules:reef_params');

// ###########################################
// SENSOR GENERICS
var sensor_params = param_module.dove;         //<------------ THIS IS WHERE YOU CHOOSE THE SENSOR
// REGION AND SENSOR SPECIFIC LOAD PATHS
var region_params = param_module.se_caribbean;  //<------------ THIS IS WHERE YOU CHOOSE THE REGION
//  ^^ all the data paths are in this module ^^
// ###########################################

// 1. Setting constants

// These will get written to the asset metadata 

//Map.centerObject(geometry, 7)

var vars = {
  
  // analysis type
  geomorphic: true, // map geomorphic zonation (when set to true) or benthic habitat (when set to false)

  // analysis parameters
  image_data_scale: sensor_params.pixel,
  small_object_geo: ee.Number(400).int(), // smallest object szie in pixels (geomorphic)
  small_object_benthic: ee.Number(130).int(), // smallest object szie in pixels (benthic)
  smooth_radius: ee.Number(3), // radius in pixels for initial smooth 
  dist_to_land_ORF: 8000, //distance to land in meters to convert terrestrial reef flat to ORF
  dist_to_land_RC: 500, //distance to land in meters to convert reef crest to TRF - not used for Indo
  wave_height: 0.4, //cut off height for waves in metres, Hs95 threshold
  geo_depth_cutoff: 1200, //depth in centimetres
  shallowlag_depth_cutoff: 500, //depth in centimetres
  benthic_depth_cutoff: 750, //depth in centimetres
  
  // should the global extent + depth cleanup be applied?
  global_extent_clean: true,
  global_depth_thresh: 500, // this is the depth limit for ADDING to the global extent (i.e. 5 = everything <5m will be added to the global extent layer)
  global_land_dist: -1, // [-1 (don't apply) OR +ve distance in meters] WITHIN this distance, the global extent/depth mask will be applied
  global_not_applied: false, // true = EXCLUDE reefs within 'global_not_applied' geometry polygons - mutually exclusive to land distance rule
  
  
  
  
  //############
  // Clean-up stage selection
  cleanup_stage: 3, // set to 1, 2 or 3
  geo_refinement: false, // set to true to apply the refinement_mask (the other stage 3 masks will still run)
  
  /*
  - GEOMORPHIC 1: The first pass does a small object filter, just to generally clean noise and reduce the amount of cleaning needed
  -            2: The second pass runs the OBIA cleanup rules
  -            3: The third pass is the MANUAL cleanup stage, which includes AT LEAST the no_reef masking
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY

  - BENTHIC 1: This is the main benthic stge - it does noise removal, no data reclaim and OBIA rules - review those if needed
            2: The second mas is the MANUAL stage - it's optional, but shuold include ALL region specific stuff
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY
  */
  
  // DON'T TOUCH --->
  obia_2nd_pass: null,
  obia_clean: null, // run object-based relationship rules + small object clean up
  fast_clean: null, // run a faster (but less precise) version of the OBIA clean; only applies to geomorphic (`obia_clean: true` also)
  manual_clean: false, // apply manual touch ups
  // --------------<
  //############
  
  reproject_display: false,
  
  // export options
  do_export: true, // export the results?
  geomorph_output_name: region_params.sname + '_geo_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  benthic_output_name: region_params.sname + '_benthic_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  asset_output: region_params.asset // asset path

};


// Clean up stage auto-parameterisation (DON'T TOUCH) --->

if (vars.geomorphic) {
  var temp_outname = vars.geomorph_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.obia_2nd_pass = true;
    vars.obia_clean = true;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '2';
  } else if (vars.cleanup_stage == 3) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = false;
    vars.do_export = false;
    vars.geomorph_output_name = temp_outname + '3';
  }
}

if (!vars.geomorphic) {
  var temp_outname = vars.benthic_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = true,
    vars.obia_clean = true, 
    vars.fast_clean = false, 
    vars.manual_clean = false;
    vars.benthic_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false,
    vars.obia_clean = false, 
    vars.fast_clean = false,
    vars.do_export = false;
    vars.benthic_output_name = temp_outname + '2';
  }
}

//Region extent is created in map viewer and exported to GEE asset
var region_extent = ee.FeatureCollection(region_params.extent_mask).geometry();
Map.addLayer(region_extent, {}, "Manual reef outline", false);
// -----------------------------------------<

//################################################################################################
//START OF CLEAN 3 - Manual Cleanup
//Review everything in this section
//This is the section to add/remove manual cleanups
//You MUST review it for each region

//###############################################################################################

if (vars.manual_clean && vars.geomorphic) {
  
  print("Doing GEOMORPHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.pixels).select('depth');
  
  // define the manually edited map - uses the output from the second pass of cleaning
  
  var man_geo1 = ee.Image(region_params.geo_map_clean3); //previous clean 3 without the global extent rule
  var man_geo = ee.Image(region_params.geo_map_clean3); ///depart from geo3 to apply global extent rule
  
  
  // the "GLOBAL MASK" clean
  // currently uses GCRMN extent + bathymetry threhold < vars.global_depth_thresh
  if (vars.global_extent_clean) {
    var blanket_mask = ee.Image([param_module.global_extent_mask.gcrmn]).unmask(0, false)
              .eq(1) // extent according to global extent layer
              .add(depth.lt(vars.global_depth_thresh)) // combine with areas less than depth thrshold
              .eq(0) // get leftovers
              .selfMask().connectedPixelCount(25, true).gte(25)
    
    if (vars.global_land_dist > 0) {
      var distToLand = ee.Image(region_params.distToLand);
      man_geo = man_geo.where({
        test: blanket_mask.eq(1)
                          .and(distToLand.lte(vars.global_land_dist)),
        value: ee.Image(0)
      });
    } else if (vars.global_not_applied) {
      var global_not_applied_i = ee.Image().byte().paint(ee.Feature(global_not_applied, {zone: 1}), 'zone').unmask(0, false)
      man_geo = man_geo.where({
        test: blanket_mask.eq(1)
                          .and(global_not_applied_i.eq(0)),
        value: ee.Image(0)
      });
    } else {
      man_geo = man_geo.where({
        test: blanket_mask.eq(1),
        value: ee.Image(0)
      });
    }
  }
  
  
  // import the mid mask from asset ****only use ee.FC if mid_mask created in map viewer****
  //var mid_mask = ee.FeatureCollection(region_params.mid_mask).geometry();
  //Map.addLayer(mid_mask, {color: 'red'}, "mid mask import", true, 0.4);
  var midmask = ee.Image().byte().paint(ee.Feature(mid_mask.dissolve(),{zone: 1}), "zone").clip(mid_mask.dissolve());
  
  // the "MID MASK" CLEAN
 man_geo = man_geo.where({
  test: midmask.eq(1),
 value: ee.Image(0)
  });
  
 var trf_Sand = ee.Image().byte().paint(ee.Feature(trf_sand.dissolve(),{zone: 1}), "zone").clip(trf_sand.dissolve());
   
man_geo = man_geo.where({
  test: trf_Sand.eq(1)
  .and(man_geo.eq(16)),
 value: ee.Image(13)
  });  
  
  
  
  /*
  // the "REEF MASK" CLEAN
  
  // Define a kernel for reef mask Morphological Operations
  var kernel_rm = ee.Kernel.circle({radius: vars.smooth_radius.multiply(5)});

  // Create reef mask to clean areas inside the reef - Perform an dilation of deepwater
  var reef_mask = man_geo.eq(2)
            .focal_max({kernel: kernel_rm, iterations: 2});
  var global_reef_mask = ee.Image(region_params.global_reef_mask);
  

  // Reef crest, slope, sheltered slope (within reef mask) -> Inner reef flat
  man_geo = man_geo.where({
    test: reef_mask.eq(0)
                    .and(man_geo.eq(15).or(man_geo.eq(21)).or(man_geo.eq(22))),
    value: ee.Image(13)
  });
  
  // the "DEEP WATER" CLEAN
  
  // Define a kernel for deep water Morphological Operations
  var kernel_dw = ee.Kernel.circle({radius: vars.smooth_radius.multiply(5)});

  // Create mask to clean deepwater areas - Perform an dilation of deepwater followed by a erosion
  var deepwater = man_geo.eq(2)
            .focal_max({kernel: kernel_dw, iterations: 2})
            .focal_min({kernel: kernel_dw, iterations: 2});
    
  
    // Deep lagoon (outside reef mask and global mask) -> deepwater 
  man_geo = man_geo.where({
    test: deepwater.eq(1)
                    .and(man_geo.eq(12)),
                    //.and(global_reef_mask.eq(2)),
    value: ee.Image(2)
  });
  
 
  // Reef classes in deepwater -> deepwater
  man_geo = man_geo.where({
    test: deepwater.eq(1)
                    .and(man_geo.eq(15).or(man_geo.eq(21)).or(man_geo.eq(22)).or(man_geo.eq(24))),
    value: ee.Image(2)
  });
  
  */ 

  
  
  
  
/*
  // WAVE clean (un-comment this sectio nbased on whether you have waves or not)
  
  var waves = ee.Image(region_params.waves)
  Map.addLayer(waves.lt(vars.wave_height), {}, vars.wave_height + "m Hs95 threshold", false)
  
  man_geo = man_geo.where({
    test: waves.lte(vars.wave_height)
               .and(man_geo.eq(22)),
    value: ee.Image(21)
  })
 
*/ 
  
  
/*
  ##############
  
  The rest of the manual geometry paintings and rules should go here
      - make the geom, paint the layer, use it in a rule
      - consult previous regions *_cleanup script for ideas/hints/existing rules etc.
  e.g. 
  var notreefcrest = ee.Image().byte().paint(ee.Feature(not_reef_crest, {zone: 1}), "zone").clip(not_reef_crest);
  var notdeepwater = ee.Image().byte().paint(ee.Feature(not_deep_water, {zone: 1}), "zone").clip(not_deep_water);
  
*/
/*
var mid_Mask = ee.Image().byte().paint(ee.Feature(midMask, {zone: 1}), "zone").clip(midMask);

man_geo = man_geo.where({
  test: mid_Mask.eq(1),
  value: ee.Image (0),
})

*/
  //This session is after feedback
 // var midmask = ee.Image().byte().paint(ee.Feature(mid_mask.dissolve(),{zone: 1}), "zone").clip(mid_mask.dissolve());
  
  // the "MID MASK" CLEAN
 // man_geo = man_geo.where({
 // test: midmask.eq(1),
// value: ee.Image(0)
 // });  

/*  
var Rs_BRS = ee.Image().byte().paint(ee.Feature(rs_brs, {zone:1}), "zone")
var Rc_Rs = ee.Image().byte().paint(ee.Feature(rc_rs, {zone:1}), "zone")
var fill_in = ee.Image().byte().paint(ee.Feature(fill_inCorals, {zone:1}), "zone")
var fill_in2 = ee.Image().byte().paint(ee.Feature(fill_inCoral2_Sl, {zone:1}), "zone")


man_geo = man_geo.where({
   test: Rs_BRS.eq(1)
                   .and(man_geo.eq(22)),
  value: ee.Image(24)
  })
  
man_geo = man_geo.where({
   test: Rc_Rs.eq(1)
                   .and(man_geo.eq(15)),
  value: ee.Image(22)
  }) 
 
 
man_geo = man_geo.where({
   test: fill_in.eq(1)
                   .and(man_geo.neq(22).and(man_geo.neq(11))),
  value: ee.Image(13)
  }) 

man_geo = man_geo.where({
   test: fill_in2.eq(1)
                   .and(man_geo.neq(12).and(man_geo.neq(13))),
  value: ee.Image(11)
  })     

/*
var Brs_Sl = ee.Image().byte().paint(ee.Feature(brs_sl, {zone: 1}), "zone").clip(brs_sl);

var Dl_SRS_Pr_toRs = ee.Image().byte().paint(ee.Feature(Dl_SRS_Pr_to_rs, {zone: 1}), "zone").clip(Dl_SRS_Pr_to_rs);
var Rs_Sl = ee.Image().byte().paint(ee.Feature(rs_sl, {zone:1}), "zone").clip(rs_sl)

var Sl_Brs = ee.Image().byte().paint(ee.Feature(sl_brs, {zone: 1}), "zone").clip(sl_brs);
var Rs_Brs = ee.Image().byte().paint(ee.Feature(rs_brs, {zone: 1}), "zone").clip(rs_brs);
var Rs_Dl_Sl_SRS_toBrs= ee.Image().byte().paint(ee.Feature(rs_dl_sl_srs_tobrs, {zone:1}), "zone").clip(rs_dl_sl_srs_tobrs);
var SRS_toBrs = ee.Image().byte().paint(ee.Feature(srs_brs, {zone: 1}), "zone").clip(srs_brs);
var Rs_mask = ee.Image().byte().paint(ee.Feature(rs_mask, {zone: 1}), "zone").clip(rs_mask);
var Sl_mask = ee.Image().byte().paint(ee.Feature(sl_mask, {zone: 1}), "zone").clip(sl_mask);
var Srs_rs = ee.Image().byte().paint(ee.Feature(srs_rs, {zone:1}), "zone").clip(srs_rs)
var Srs_tomask = ee.Image().byte().paint(ee.Feature(srs_tomask, {zone:1}), "zone").clip(srs_tomask)
var Dl_SRS_Pr_toRs = ee.Image().byte().paint(ee.Feature(Dl_SRS_Pr_to_rs, {zone: 1}), "zone").clip(Dl_SRS_Pr_to_rs);

var Orf_irf_rs_brs_totrf= ee.Image().byte().paint(ee.Feature(orf_irf_rs_brs_totrf, {zone:1}), "zone").clip(orf_irf_rs_brs_totrf);


var Brs_rs = ee.Image().byte().paint(ee.Feature(brs_rs, {zone: 1}), "zone").clip(brs_rs)
var BrsDl_srs = ee.Image().byte().paint(ee.Feature(brsdl_srs, {zone: 1}), "zone").clip(brsdl_srs)
var Sl_srs = ee.Image().byte().paint(ee.Feature(sl_srs, {zone:1}),"zone").clip(sl_srs) 
var Sl_rs = ee.Image().byte().paint(ee.Feature(sl_rs, {zone:1}),"zone").clip(sl_rs)  


//var Brs_mask = ee.Image().byte().paint(ee.Feature(brsdl_mask, {zone:1}),"zone").clip(brsdl_mask)  
 
 //var Srs_Brs = ee.Image().byte().paint(ee.Feature(srs_brs, {zone: 1}), "zone").clip(srs_brs)
 //var All_Brs = ee.Image().byte().paint(ee.Feature(all_brs, {zone:1}), "zone").clip(all_brs)
 // var Srs_Orf = ee.Image().byte().paint(ee.Feature(srs_orf, {zone: 1}), "zone").clip(srs_orf)  
  
  // Back reef slope -> shallow lagoon (inside the reef)


  man_geo = man_geo.where({
   test: Brs_Sl.eq(1)
                   .and(man_geo.eq(24)).or(man_geo.eq(12)),
    value: ee.Image(11)
  });
  



  

  // deep laggon, sheltered r s and patch reefs into reef slope
  
  man_geo = man_geo.where({
    test: Dl_SRS_Pr_toRs.eq(1)
                            .and(man_geo.eq(12)).or(man_geo.eq(25)).or(man_geo.eq(21)),
    value: ee.Image(22)
  });
  
  //reef slope to shallow lagoon
  
  man_geo = man_geo.where({
   test: Rs_Sl.eq(1)
                   .and(man_geo.eq(22)),
  value: ee.Image(11)
  })
  

   // Shallow lagoon and deep lagoon > back reef slope (inside the reef)
  man_geo = man_geo.where({
    test:  Sl_Brs.eq(1)
                     .and(man_geo.eq(11).or(man_geo.eq(12))),
    value: ee.Image(24)
  });
  
  // reef slope > back reef slope (outside the reef)
  man_geo = man_geo.where({
    test: Rs_Brs.eq(1)
                     .and(man_geo.eq(22)),
    value: ee.Image(24)
  });
  
   // deep laggon, sheltered r s and patch reefs into reef slope
  
  
  man_geo = man_geo.where({
    test: Dl_SRS_Pr_toRs.eq(1)
                            .and(man_geo.eq(12)).or(man_geo.eq(25)).or(man_geo.eq(21)),
    value: ee.Image(22)
  });
  
  

  man_geo = man_geo.where({
    test: Rs_Dl_Sl_SRS_toBrs.eq(1)
                      .and(man_geo.eq(22)).or(man_geo.eq(12)).or(man_geo.eq(11)).or(man_geo.eq(21)),
    value: ee.Image(24)
  })
  
   //sheltered reef slope > back reef slope (inside the reef)
  man_geo = man_geo.where({
    test:  SRS_toBrs.eq(1)
                     .and(man_geo.eq(21)),
    value: ee.Image(24)
  });
  
  //mask out rs
  man_geo = man_geo.where({
  test: Rs_mask.eq(1)
        .and(man_geo.eq(22)),
  value: ee.Image (0),
})

//mask out shallow lagoon
  man_geo = man_geo.where({
  test: Sl_mask.eq(1)
        .and(man_geo.eq(11)),
  value: ee.Image (0),
})


//srs to rs
  man_geo = man_geo.where({
  test: Srs_rs.eq(1)
        .and(man_geo.eq(21)),
  value: ee.Image (22),
})


//srs to mask
  man_geo = man_geo.where({
  test: Srs_tomask.eq(1)
        .and(man_geo.eq(21)),
  value: ee.Image (0),
})

  man_geo = man_geo.where({
    test: Orf_irf_rs_brs_totrf.eq(1)
                      .and(man_geo.eq(14)).or(man_geo.eq(13)).or(man_geo.eq(22)).or(man_geo.eq(24)),
    value: ee.Image(16)
  })
  
  
  /*
  
  man_geo = man_geo.where({
    test: Brs_rs.eq(1)
          .and(man_geo.eq(24)),
    value: ee.Image(22)
  })
  
  
  man_geo = man_geo.where({
    test: BrsDl_srs.eq(1)
          .and(man_geo.eq(24)).or(man_geo.eq(12)),
    value: ee.Image(21)
  })
  
  
   man_geo = man_geo.where({
    test: Sl_srs.eq(1)
          .and(man_geo.eq(11)),
    value: ee.Image(21)
  })
  
  man_geo = man_geo.where({
    test: Sl_rs.eq(1)
          .and(man_geo.eq(11)),
    value: ee.Image(22)
  })
  

  man_geo = man_geo.where({
    test: Brs_mask.eq(1)
         .and(man_geo.eq(24)).or(man_geo.eq(12)),
    value: ee.Image(0)
  }) 
  
  
  var refine = ee.Image().byte().paint(ee.Feature(refinement_mask, {zone: 1}), "zone").clip(refinement_mask);
    // apply
    man_geo = man_geo.where({
      test: refine.eq(1),
      value: ee.Image(0)
    });

/*
 //Back reef slope > reef slope (outside the reef)
  man_geo = man_geo.where({rock
    test:  Brs_Rs.eq(1)
                     .and(man_geo.eq(24)),
    value: ee.Image(22)
  });
  
  //reef crest > Back reef slope (outside the reef)
 // man_geo = man_geo.where({
   // test:  Rc_Brs.eq(1)
   //                  .and(man_geo.eq(15)),
  //  value: ee.Image(24)
  //});
   
  //sheltered reef slope > Back reef slope (outside the reef)
  man_geo = man_geo.where({
    test:  Srs_Brs.eq(1)
                     .and(man_geo.eq(21)),
    value: ee.Image(24)
  });
    
  //sheltered reef slope > outer reef falt (inside the reef)
 // man_geo = man_geo.where({
   // test:  Srs_Orf.eq(1)
     //                .and(man_geo.eq(21)),
   // value: ee.Image(14)
  //}); 
  
  man_geo = man_geo.where({
    test: All_Brs.eq(1)
            .and(man_geo.eq(11)).or(man_geo.eq(12))
            .or(man_geo.eq(13)).or(man_geo.eq(15))
            .or(man_geo.eq(16)).or(man_geo.eq(21)).or(man_geo.eq(22))
            .or(man_geo.eq(23)),
    
    value: ee.Image(24)
  });
*/
/*
var Dl_Null = ee.Image().byte().paint(ee.Feature(dl_null, {zone: 1}), "zone").clip(dl_null);

var Dl_SRS_toRs = ee.Image().byte().paint(ee.Feature(Dl_SRS_trf_to_rs, {zone: 1}), "zone").clip(Dl_SRS_trf_to_rs);

var Dl_SRS_TRF_toRs = ee.Image().byte().paint(ee.Feature(Dl_SRS_trf_to_rs, {zone: 1}), "zone").clip(Dl_SRS_trf_to_rs);

var trf_rs =ee.Image().byte().paint(ee.Feature(trf_tors, {zone:1}), "zone").clip(trf_tors);

var Srs_tomask = ee.Image().byte().paint(ee.Feature(SRS_tomask, {zone:1}), "zone").clip(SRS_tomask)

var Rc_rs = ee.Image().byte().paint(ee.Feature(rc_rs, {zone: 1}), "zone").clip(rc_rs)

var RC_Null = ee.Image().byte().paint(ee.Feature(rc_null, {zone: 1}), "zone").clip(rc_null);

var TRF_srs = ee.Image().byte().paint(ee.Feature(trf_srs, {zone: 1}), "zone").clip(trf_srs)

var Orf_irf_rs_brs_totrf= ee.Image().byte().paint(ee.Feature(orf_irf_rs_brs_totrf, {zone:1}), "zone").clip(orf_irf_rs_brs_totrf);

var Pl_brs = ee.Image().byte().paint(ee.Feature(pl_brs, {zone: 1}), "zone").clip(pl_brs)

var ORF_irf_rs_brs_tors= ee.Image().byte().paint(ee.Feature(orf_irf_rs_brs_tors, {zone:1}), "zone").clip(orf_irf_rs_brs_tors);

var TRF_Null = ee.Image().byte().paint(ee.Feature(trf_null, {zone: 1}), "zone").clip(trf_null);

var RS_srs = ee.Image().byte().paint(ee.Feature(rs_srs, {zone: 1}), "zone").clip(rs_srs);

var RS_Null = ee.Image().byte().paint(ee.Feature(rs_null, {zone: 1}), "zone").clip(rs_null);


var Sl_pl_dl_brs = ee.Image().byte().paint(ee.Feature(sl_pl_dl_brs, {zone: 1}), "zone").clip(sl_pl_dl_brs);

var pr_Null = ee.Image().byte().paint(ee.Feature(Pr_null, {zone: 1}), "zone").clip(Pr_null);

var Sl_rs = ee.Image().byte().paint(ee.Feature(sl_rs, {zone: 1}), "zone").clip(sl_rs);

man_geo=man_geo.where({
  test: Dl_Null.eq(1).and(man_geo.eq(12)),
  value: ee.Image(0)
})

man_geo = man_geo.where({
    test: Dl_SRS_TRF_toRs.eq(1)
                            .and(man_geo.eq(12)).or(man_geo.eq(16)).or(man_geo.eq(21)),
    value: ee.Image(22)
  });
  
man_geo=man_geo.where({
  test: trf_rs.eq(1)
                    .and(man_geo.eq(16)),
 value: ee.Image(22)
});

man_geo=man_geo.where({
  test: Srs_tomask.eq(1)
         .and(man_geo.eq(21)),
  value:ee.Image(0)

})

man_geo=man_geo.where({
  test: Rc_rs.eq(1)
        .and(man_geo.eq(15)),
  value: ee.Image(22)
})

man_geo=man_geo.where({
  test: RC_Null.eq(1).and(man_geo.eq(15)),
  value: ee.Image(0)
})
 
 man_geo=man_geo.where({
  test: TRF_srs.eq(1)
        .and(man_geo.eq(16)),
  value: ee.Image(21)
})

  man_geo = man_geo.where({
    test: Orf_irf_rs_brs_totrf.eq(1)
                      .and(man_geo.eq(14)).or(man_geo.eq(13)).or(man_geo.eq(22)).or(man_geo.eq(24)),
    value: ee.Image(16)
  })
  
  man_geo=man_geo.where({
  test: Pl_brs.eq(1)
        .and(man_geo.eq(23)),
  value: ee.Image(24)
})


 man_geo = man_geo.where({
    test: ORF_irf_rs_brs_tors.eq(1)
                      .and(man_geo.eq(14)).or(man_geo.eq(13)).or(man_geo.eq(22)).or(man_geo.eq(24)),
    value: ee.Image(22)
  })

man_geo=man_geo.where({
  test: TRF_Null.eq(1)
         .and(man_geo.eq(16)),
  value:ee.Image(0)

})

man_geo=man_geo.where({
  test: RS_srs.eq(1)
        .and(man_geo.eq(22)),
  value: ee.Image(21)
})

man_geo=man_geo.where({
  test: RS_Null.eq(1)
        .and(man_geo.eq(22)),
  value: ee.Image(0)
})

man_geo = man_geo.where({
    test: Sl_pl_dl_brs.eq(1)
                            .and(man_geo.eq(23)).or(man_geo.eq(11)).or(man_geo.eq(12)),
    value: ee.Image(24)
  });

man_geo=man_geo.where({
  test: pr_Null.eq(1)
         .and(man_geo.eq(25)),
  value:ee.Image(0)

 });
 
 man_geo=man_geo.where({
  test: Sl_rs.eq(1)
         .and(man_geo.eq(11)),
  value:ee.Image(22)
 });
 
 
 
 
 var Dl_SRS_TRF_toRs = ee.Image().byte().paint(ee.Feature(Dl_SRS_trf_to_rs, {zone: 1}), "zone").clip(Dl_SRS_trf_to_rs);

 var INF_Sl = ee.Image().byte().paint(ee.Feature(irf_sl, {zone:1}), "zone").clip(irf_sl)
 var Dl_Null = ee.Image().byte().paint(ee.Feature(dl_null, {zone: 1}), "zone").clip(dl_null);
 
 man_geo = man_geo.where({
    test: Dl_SRS_TRF_toRs.eq(1)
                            .and(man_geo.eq(12)).or(man_geo.eq(16)).or(man_geo.eq(21)),
    value: ee.Image(22)
  });
  
  
man_geo = man_geo.where({
  test: INF_Sl.eq(1)
              .and(man_geo.eq(13)),
  value:ee.Image(11)
});
 
 man_geo=man_geo.where({
  test: Dl_Null.eq(1).and(man_geo.eq(12)),
  value: ee.Image(0)
})

*/
 
  if (vars.geo_refinement) {
    // make the mask image layer
    var refine = ee.Image().byte().paint(ee.Feature(refinement_mask, {zone: 1}), "zone").clip(refinement_mask);
    // apply
    man_geo = man_geo.where({
      test: refine.eq(1),
      value: ee.Image(0)
    });
  }
  
  // Add data + the manual layer to the map
  var lowtide_image = ee.ImageCollection(region_params.pixels).mosaic();
  var imageVisParam3 = {"opacity":1,"bands":["b3","b2","b1"],"min":94.7,"max":852.3,"gamma":1};
  //this session was included as I saw errors in the initial noReefMask
 // var cutErrorsinSR = ee.Image().byte().paint(ee.Feature(noReef2.dissolve(),{zone: 1}), "zone").clip(noReef2.dissolve());
  //lowtide_image = lowtide_image.where({
 // test: cutErrorsinSR.eq(1),
 //value: ee.Image(0)
 // });  
  Map.addLayer(lowtide_image.updateMask(lowtide_image.gt(0)), imageVisParam3, sensor_params.sname + ' low tide', false);
  var notreef_mask = ee.FeatureCollection(region_params.notreef_mask).geometry();
  Map.addLayer(notreef_mask, {}, "noReefmask", false);
  //var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  //Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false); I removed this asset by mistake
  var geo_clean2 = ee.Image(region_params.geo_map_clean2_mid);
  Map.addLayer(geo_clean2.updateMask(geo_clean2.gt(2)), map_palettes.geo, 'Geo clean stage 2', false);
  Map.addLayer(man_geo.updateMask(man_geo.gt(2)), map_palettes.geo, 'Geo clean stage 3 with gcrmn', false);
  Map.addLayer(man_geo1.updateMask(man_geo1.gt(2)), map_palettes.geo, 'Geo clean stage 3 without gcrmn', false); ///for CR to check
  var unepClipped= wcmc.filterBounds(region_extent)
  Map.addLayer(unepClipped, {color:'#FFFF33'}, 'UNEP_layer', false)
  
 // Map.addLayer(waves, {}, 'waves', false);
 // Map.addLayer(wavespng, {}, 'wavespng', false);
  
  //Map.addLayer(man_geo.updateMask(man_geo.gt(2)), map_palettes.geo, 'Geo clean stage 3 - no DW', false);
 // Map.addLayer(global_reef_mask.updateMask(global_reef_mask.eq(1)), {palette: ['F8FF23'], opacity: 0.4}, 'global_reef_mask - land', false);
  //Map.addLayer(global_reef_mask.updateMask(global_reef_mask.eq(3)), {palette: ['0000ff'], opacity: 0.4}, 'global_reef_mask - reef', false);
  //Map.addLayer(global_reef_mask.updateMask(global_reef_mask.eq(2)), {palette: ['FF0000'], opacity: 0.4}, 'global_reef_mask - water', false);

  // display distance to land mask for assessing cut-off distances
  var distToLand = ee.Image(region_params.distToLand);
    
  //Map.addLayer(distToLand.lte(vars.dist_to_land_RC), {}, 'RC to TRF ' + vars.dist_to_land_RC + 'm', false);
 // Map.addLayer(distToLand.unmask(100000, false).lte(vars.dist_to_land_ORF), {}, 'TRF to ORF ' + vars.dist_to_land_ORF + 'm', false);
  
  // display distance to water mask
  var distToWater = ee.Image(region_params.distToWater);
    
  //Map.addLayer(distToWater.unmask(100000, false).lte(vars.dist_to_land_ORF), {}, 'distToWater ' + vars.dist_to_land_ORF + 'm', false);
  
  
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_geo,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: region_extent,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
} 

if (vars.manual_clean && !vars.geomorphic) {
  
  print("Doing BENTHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.pixels).select('depth');
  
  // define the final geomorphic map (the manually edited geo map - stage 3)
  var geo_map = ee.Image(region_params.geo_map_clean3);
  
  // define the clean benthic map to apply 2nd stage rules to
  var man_benthic = ee.Image(region_params.benthic_map_clean1);
  
  
  /*
  **Generic benthic rules**
    - should be generally applicable, but still review
  */
  
  // BMA on inner RF, outer RF,reef crest, reef slope -> rubble 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(18)
                     .and(geo_map.eq(13).or(geo_map.eq(14)).or(geo_map.eq(15)).or(geo_map.eq(22))),
    value: ee.Image(12)
  });
  
  // Rubble on Outer reef flat and Reef crest -> rock 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(12)
                     .and(geo_map.eq(14).or(geo_map.eq(15))),
    value: ee.Image(13)
  });
    
  // Seagrass on Back reef slope -> Sand 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(14)
                     .and(geo_map.eq(24)),
    value: ee.Image(11)
  });  
  
    
  /*
  
  **Manual polygon guided rules**
   - same as per geomorphic clean section
   - add a geometry, paint the layer, create a rule
   
   */
var benthic_Mask = ee.Image().byte().paint(ee.Feature(benthic_mask, {zone: 1}), "zone");  

man_benthic = man_benthic.where({
    test: benthic_Mask.eq(1),
    value: ee.Image(0)
  });     
   
 ///fill in sand in shallow lagoon

var fill_insand = ee.Image().byte().paint(ee.Feature(fill_inSand, {zone: 1}), "zone");

man_benthic = man_benthic.unmask(0, false).where({
test:  fill_insand.eq(1)
                  .and(man_benthic.unmask(0, false)).eq(0),
value: ee.Image(11)
}).selfMask();
 
var fill_incoral = ee.Image().byte().paint(ee.Feature(fill_inCorals, {zone: 1}), "zone");

man_benthic = man_benthic.unmask(0, false).where({
test:  fill_incoral.eq(1)
                  .and(man_benthic.unmask(0, false)).eq(0),
value: ee.Image(15)
}).selfMask();
 








 var coral_Sand = ee.Image().byte().paint(ee.Feature(coral_sand, {zone: 1}), "zone");
 
 man_benthic = man_benthic.where({
    test: coral_Sand.eq(1)
                     .and(man_benthic.eq(15)),
    value: ee.Image(11)
  });  
 
 var SG_coral = ee.Image().byte().paint(ee.Feature(sg_sand, {zone: 1}), "zone"); 
 
 man_benthic = man_benthic.where({
    test: SG_coral.eq(1)
                     .and(man_benthic.eq(14)),
    value: ee.Image(11)
  });  
 
  
  
  // Add the manual layer to the map
  var lowtide_image = ee.ImageCollection(region_params.pixels).mosaic();
  var imageVisParam3 = {"opacity":1,"bands":["b3","b2","b1"],"min":94.7,"max":852.3,"gamma":1};
  Map.addLayer(lowtide_image.updateMask(lowtide_image.gt(0)), imageVisParam3, sensor_params.sname + ' low tide', false);
  var benthic_clean1 = ee.Image(region_params.benthic_map_clean1);
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false);
   Map.addLayer(geo_clean2.updateMask(geo_clean2.gt(2)), map_palettes.geo, 'Geo clean stage 2', false);
  // Map.addLayer(geo_clean2, map_palettes.geo, 'Geo clean stage 2', false);
  //Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Geo clean stage 3 - MANUAL', true);
  Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Geo clean stage 3 - MANUAL', false);
  Map.addLayer(benthic_clean1.updateMask(geo_map.gt(0)), map_palettes.benthic, 'Benthic clean stage 1', false);
  //Map.addLayer(man_benthic.updateMask(man_benthic.gt(0)), map_palettes.benthic, 'Benthic clean stage 2 - MANUAL', true);
  Map.addLayer(man_benthic.updateMask(man_benthic.gt(0)), map_palettes.benthic, 'Benthic clean stage 2 ', true);
  //Map.addLayer(man_benthic10.updateMask(man_benthic10.gt(0)), map_palettes.benthic, 'Benthic clean stage 2 - MANUAL10_radius', true);
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_benthic,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: region_extent,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
}

// #################################################################################################
// END OF MANUAL SECTION
// #################################################################################################


// 2. Data loads & vis

if (!vars.manual_clean) {

  // load input data
  
  // define raw geo/benthic outputs
  // Run check to see if the region has been split into multiple areas
  
  // geo
  if (ee.List(region_params.geo_map).length().getInfo() > 1) {
    var geo_map_raw = ee.Image(region_params.geo_map[0]).unmask(0, false)
                 .add(ee.Image(region_params.geo_map[1]).unmask(0,false))
                 .selfMask();
  } else {
    var geo_map_raw = ee.Image(region_params.geo_map);
  }
  
  // benthic
  if (ee.List(region_params.benthic_map).length().getInfo() > 1) {
      var benthic_map = ee.Image(region_params.benthic_map[0]).unmask(0, false)
               .add(ee.Image(region_params.benthic_map[1]).unmask(0,false))
               .selfMask();
  } else {
      var benthic_map = ee.Image(region_params.benthic_map);
  }
  
  // set the geo map for further processing
  if (vars.geomorphic && vars.obia_2nd_pass) {
    // if it's 2nd pass, you want to make sure you're loading the latest geo clean map
    var geo_map = ee.Image(region_params.geo_map_clean1);
  } else if (vars.geomorphic) {
    var geo_map = geo_map_raw;
  }
  
  var depth = ee.Image(region_params.pixels).select('depth');
  var low_tide_image = ee.Image(region_params.image);
  
  var display_pal = (vars.geomorphic) ? map_palettes.geo : map_palettes.benthic;
  Map.addLayer(depth, {min:0, max:2500}, 'Depth data', false);
  Map.addLayer(low_tide_image, {bands: ['b3','b2','b1'], min:0, max:3000}, sensor_params.sname + ' low tide', false);
  
  // load for display purposes
  if (vars.geomorphic) {
    Map.addLayer(geo_map_raw, display_pal, 'Geomorphic map RAW', false);
    if (vars.cleanup_stage == 2) Map.addLayer(ee.Image(region_params.geo_map_clean1), display_pal, 'Geo clean stage 1', false);
  }
  if (!vars.geomorphic) {
    // Use the manually cleaned geomorphic map as input for the benthic clean
    var geo_map = ee.Image(region_params.geo_map_clean3);
    Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Geo clean stage 3', false);
    Map.addLayer(benthic_map, display_pal, 'Benthic map RAW', false);
  }
  
  // 3. Object-based re-classificaiton and cleaning
  
  /* OUTPUT EXTENT
    - to the mapping extent just so it doesn't balloon out
    - to the 'reef boundary' extent for noise/deep removal
  */  
  var class_extent_mask = geo_map.gt(0);
  
  /*
  
  ########
  Initial small object clean
   - this was originally at the end, but we needed to massively reduce the number of objects to 
     iterate through in the OBIA cleaning, so this happens first now
   - future collabs with google might fix this, but need to change the parallel serialisation of vector procesing
   
   - includes a possible special case for:
        - geomorphic to clean up turbid areas over size threshold; fix shallow vs. deep lagoon
        - benthic to allow breaking waves (temporal class) to grow into surrounding class
  ########
  
  */
  
  // ##############################################################################################
  // START OF CLEAN 1
  // ##############################################################################################
  
  if (vars.geomorphic && !vars.obia_2nd_pass) {
    
    // shallow lagoon > 5m == deep lagoon//this rule is making mini deep laggoons witin BRS 
    //so I will generate another clean up1 with shallow lagoons instead (comenting this up)
    
    // = geo_map.where({
     // test: geo_map.eq(11)
                    //.and(depth.gt(vars.shallowlag_depth_cutoff)),
      //value: ee.Image(12)
    //});
    
    // deep water in depth data == deep (s2 + ls8 data should be good enough for this)
    geo_map = geo_map.where({
      test: depth.gt(vars.geo_depth_cutoff),
      value: ee.Image(2)
    });
    
    // make a smooth map with masked area as a value - *** Change to ee.kernal*** see reef mask in clean 3
    var smooth_map = geo_map
                        .focal_mode({
                          radius: vars.smooth_radius, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 2
                        });
    
    // replace small objects with smooth underneath
    var clean_map = geo_map.where({
      test: geo_map.connectedPixelCount(vars.small_object_geo, false).lt(vars.small_object_geo), 
      value: smooth_map
    }).updateMask(class_extent_mask);
    
    // display distance to land mask for assessing cut-off distances
    var distToLand = ee.Image(region_params.distToLand);
    
    Map.addLayer(distToLand.lte(vars.dist_to_land_RC), {}, 'RC to TRF ' + vars.dist_to_land_RC + 'm', false);
    Map.addLayer(distToLand.unmask(100000, false).lte(vars.dist_to_land_ORF), {}, 'TRF to ORF ' + vars.dist_to_land_ORF + 'm', false);

    // // reef crest close to land -> TRF - Not need when using .focal masks (reef mask) as this will take care of RC inside the reef
    // clean_map = clean_map.where({
    //   test: distToLand.lte(vars.dist_to_land_RC)
    //                 .and(clean_map.eq(15)),
    //   value: ee.Image(16)
    // });
    
    // TRF outside of specified distance from land -> ORF
    clean_map = clean_map.where({
      test: distToLand.unmask(100000, false).gt(vars.dist_to_land_ORF)
                       .and(clean_map.eq(16)),
      value: ee.Image(14)
    });
  }
  
  if (!vars.geomorphic && vars.cleanup_stage == 1) {
    
    // make a smooth map with masked area as a value, and without temporal class (basically breaking waves)
    var smooth_map = benthic_map
                        .focal_mode({
                          radius: vars.smooth_radius, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 1
                        });
    
    //replace small objects with smooth underneath
    var clean_map = benthic_map.where({
      test: benthic_map.connectedPixelCount(vars.small_object_benthic, false).lt(vars.small_object_benthic),
      value: smooth_map
    }).updateMask(class_extent_mask);
    
  }
  
  // ##############################################################################################
  // START OF CLEAN 2
  // ##############################################################################################
  
  if (vars.geomorphic && vars.obia_2nd_pass) {
    var clean_map = geo_map;
  }
  
  if (vars.obia_clean) {
    
    if (vars.geomorphic && !vars.fast_clean) { 
      
      // FUNCTION that maps over feature colleciton and assigns neighbour percentages
      var set_neighbour_properties = function(f) {
        // make the 1px buffer
        var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5));
        // reduce the classes in the buffer zone
        var diff_classes = ee.Dictionary(
          clean_map.unmask(ee.Image(0)).reduceRegion({
            reducer: ee.Reducer.frequencyHistogram(),
            geometry: diff.geometry(),
            scale: vars.image_data_scale,
            maxPixels: 1e11
          }).get('classification')
        );
        // calculate the percentages
        var diff_sum = diff_classes.toArray().reduce(ee.Reducer.sum(), [0]).get([0]);
        var diff_percs = diff_classes.map(function(k,v){return(ee.Number(v).divide(diff_sum).multiply(100).toUint8())});
        
        /* NOW, we can try to do the class logic right here (see /users/mitchest/global_reefs/obia_dev),
           or we can return the neighbour % and do image logic via (painted) rasters */
        
        return(f.set(diff_percs));
      };
      
      // FUNCTION to reduce the map to vectors and map the neighbour properties function
      var reduce_neighbours = function() {
        // reduce map to vectors
        var map_fc = clean_map
              .updateMask(segment_id).updateMask(clean_map.eq(classn)) // only vectorise class/es of interest
              .reduceToVectors({
                scale: vars.image_data_scale, 
                eightConnected: false,
                bestEffort: true, 
                maxPixels: 1e13,
                tileScale: 1,
                geometry: region_extent
              });
        // map the function, calculate neighbour properties
        return(map_fc.map(set_neighbour_properties));
      };
      
      // first make a make size threshold, so we're not vecortising huge objects when we don't have to
      var segment_id = clean_map.connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels');
      //Map.addLayer(segment_id.reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))))
      Map.addLayer(clean_map.updateMask(segment_id).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
      
      // This is where we select the single or group of classes to vectorise for cleaning up
      //var classn = ee.Number(15) // one class
      var classn = clean_map.where({
        test: clean_map.neq(16) //TRF
                .and(clean_map.neq(15)) //RR
                .and(clean_map.neq(14)) //ORF
                .and(clean_map.neq(13)) //IRF
                //.and(clean_map.neq(12)) // deep L
                .and(clean_map.neq(11)), // shallow L 
        value: ee.Image(99) // 99 ensures it's ignored in logic
      });
      
      // Minimum size of object to reclass based on neighbourhood
      var max_size = ee.Number(1000).divide(vars.image_data_scale).pow(2); // the first number is the square dimension of the desired min size;
      // calculate neighbours
      var map_fc_neighbours = reduce_neighbours();
      
      // #########
      // REEF RIM
      // #########
      
      var focus_class = ee.Number(15); //RR
      
      // start the object-based neighbourhood rules
      // paint out to rasters (only paint the layers needed)
      var objsize = ee.Image(30000).paint(map_fc_neighbours, 'count').rename('count');
      //var nb24 = ee.Image().byte().paint(map_fc_neighbours, '24').unmask(0).rename('nb24') //OCL
      var nb22 = ee.Image().byte().paint(map_fc_neighbours, '22').unmask(0).rename('nb22'); //SL ex
      var nb21 = ee.Image().byte().paint(map_fc_neighbours, '21').unmask(0).rename('nb21'); //Sl sh
      var nb16 = ee.Image().byte().paint(map_fc_neighbours, '16').unmask(0).rename('nb16'); //TRF
      var nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15'); //RR
      var nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14'); //ORF
      var nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13'); //IRF
      //var nb3 = ee.Image().byte().paint(map_fc_neighbours, '3').unmask(0).rename('nb3') //Turbid
      
      // RR surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // RR surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // RR surrounded by IRF + ORF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.add(nb14).gt(75)),
        value: ee.Image(13)
      });
      
      // RR with decent border to TRF --> TRF (often dark, probably seagrass)
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(40)),
        value: ee.Image(16)
      });
      
      // RR surrounded by OCL --> OCL
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb24.gt(75)),
        value: ee.Image(24)
      })
      
      // small RR objects touching OCL + stuff --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(objsize.lte(max_size))
                .and(nb13.lte(75).and(nb14.lte(75))) // to ensure we're no re-writing previous rules
                .and(nb24.gt(1)),
        value: ee.Image(14)
      })
      
      // ####
      // ORF
      // ####
      
      focus_class = ee.Number(14); // ORF
      
      // ORF surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // ORF surrounded by TRF --> TRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(75)),
        value: ee.Image(16)
      });
      
      // ORF surrounded by RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb15.gt(85)),
        value: ee.Image(15)
      });
      
      // ORF touching slope and RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb21.gt(0).or(nb22.gt(0)))
                .and(nb15.gt(0)),
        value: ee.Image(15)
      });
      
      // ####
      // IRF
      // ####
      
      focus_class = ee.Number(13); // IRF
      
      // IRF surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // IRF surrounded by TRF --> TRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(75)),
        value: ee.Image(16)
      });
      
      // IRF surrounded by RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb15.gt(85)),
        value: ee.Image(15)
      });
      
      // ####
      // TRF
      // ####
      
      focus_class = ee.Number(16); // TRF
      
      // TRF surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // TRF surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // TRF surrounded by IRF + ORF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.add(nb14).gt(75)),
        value: ee.Image(13)
      });
      
      // ####
      // LAGOONS
      // ####
      
      var nb11 = ee.Image().byte().paint(map_fc_neighbours, '11').unmask(0).rename('nb11'); // shallow lag
      
      // SL sourrounded by DL --> DL
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                .and(nb12.gt(75)),
        value: ee.Image(12)
      })
      
      // DL sourrounded by SL --> SL
      clean_map = clean_map.where({
        test: clean_map.eq(12)
                .and(nb11.gt(75)),
        value: ee.Image(11)
      })
      
      // DL/SL surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(11).or(clean_map.eq(12))
                .and(objsize.lte(max_size))
                .and(nb13.gt(80)),
        value: ee.Image(13)
      })
      
      // SL surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                .and(objsize.lte(max_size))
                .and(nb13.gt(80)),
        value: ee.Image(13)
      });
      
    
    } else if (vars.geomorphic && vars.fast_clean) {
      print("Executing the fast version OBIA");
      
      /* fast version of the geo clean up
        - blanket version assigns the underlying most common in neighbourhood
        - mode OBIA version iterates through objects+buffers but take the mode instead of doing the class percs, to see if that speeds things up
      */
      
      
      // ## Blanket version
      
      // make a very smooth map to capture the broader neighbourhood  - *** Change to ee.kernal*** see reef mask in clean 3
      var smooth_map = clean_map
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                            kernelType: 'circle', units: 'pixels', iterations: 2
                          });
      
      // first make a make size threshold, so we're not vectorising huge objects when we don't have t
      // - the unmask(99) captures small no data values/ data gaps
      var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt().multiply(2)).select('labels').pow(2).log().int();
      Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
      
      // replace small objects with smooth underneath
      var clean_map = clean_map.unmask(0).where({
        test: segment_id.gt(0), 
        value: smooth_map
      }).selfMask();
      
      
      // ## mode OBIA version
      
      /* A possible faster plan
            - vectorise one/few class/es at a time, thus only spending resources on what is actually needed to clean up
            - BUT, just assign the mode of the neighbours, so save resouces even further??
      
      // FUNCTION that maps over feature colleciton and assigns neighbour percentages
      var set_neighbour_mode = function(f) {
        // make the 1px buffer
        var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5))
        // reduce the classes in the buffer zone
        var diff_mode = ee.Number(ee.Dictionary(
          clean_map.unmask(ee.Image(0)).reduceRegion({
            reducer: ee.Reducer.mode(),
            geometry: diff.geometry(),
            scale: vars.image_data_scale,
            maxPixels: 1e11
          })).get('classification'))
        
        return(f.set('mode',diff_mode))
      }
      
      // FUNCTION to reduce the map to vectors and map the neighbour properties function
      var reduce_neighbours_mode = function() {
        // reduce map to vectors
        var map_fc = clean_map.unmask(0)
              .updateMask(classn.gt(0)) // only vectorise class/es of interest
              .reduceToVectors({
                scale: vars.image_data_scale, 
                eightConnected: false,
                bestEffort: true, 
                maxPixels: 1e13,
                tileScale: 1,
                geometry: region_extent
              })
        // map the function, calculate neighbour properties
        return(map_fc.map(set_neighbour_mode))
      }
      
      // first make a make size threshold, so we're not vecortising huge objects when we don't have to
      var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels')
      Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false)
      
      // This is where we select the single or group of classes to vectorise for cleaning up
      var classn = segment_id.where({
        test: clean_map.neq(16) //TRF
                .and(clean_map.neq(15)) //RR
                .and(clean_map.neq(14)) //ORF
                .and(clean_map.neq(13)) //IRF
                //.and(clean_map.neq(12)) // deep L
                .and(clean_map.neq(11)) // shallow L 
                .and(clean_map.unmask(0).neq(0)), // no data values (want to reclaim the small gaps 
        value: ee.Image(0) // 99 ensures it's ignored in logic
      })
      
      // calculate neighbours
      var map_fc_neighbours = reduce_neighbours_mode()
      
      //print(map_fc_neighbours.limit(10))
      
      var mode_map = ee.Image().byte().paint(map_fc_neighbours, 'mode').unmask(0).rename('mode') // paint out the mode values to an image
      //Map.addLayer(mode_map, display_pal, "mode map", false)
      
      // replace small objects with mode underneath
      var clean_map = clean_map.unmask(0).where({
        test: segment_id.gt(0), 
        value: mode_map
      }).selfMask()
      
      */
      
    } else {
      
      if (vars.cleanup_stage == 1) {
        // BENTHIC CLEAN-UP RULES
        
        // reclaim shallow no data to surrounding class
        var smooth_map = clean_map
                            .focal_mode({
                              radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                              kernelType: 'circle', units: 'pixels', iterations: 2
                            });
        
        var clean_map = clean_map.unmask(0).where({
          test: geo_map.gt(2).and(clean_map.eq(0)), 
          value: smooth_map
        }).selfMask();
        
        // cut benthic off to < 10 - 15 m
        clean_map = clean_map.where({
          test: depth.gt(vars.benthic_depth_cutoff),
          value: ee.Image(0)
        });
        
        // Deep (or land or missing) in geo == masked from benthic
        clean_map = clean_map.where({
          test: geo_map.unmask(0).lte(2),
          value: ee.Image(0)
        });
        
      }
    }
  }
  
  // Final clip to the classified extent and move on
  if (vars.geomorphic) {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  } else {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  }

  
  
  // 4. Export data
  
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  
  if (vars.do_export) {
    print("For export, the image data scale must be set to:", vars.image_data_scale);
    
    Map.addLayer(region_extent, {}, "Export footprint", false);
    
    Export.image.toAsset({
      image: clean_map.set(vars),
      description: output_name,
      assetId: vars.asset_output + 'in_out/' + output_name,
      region: region_extent,
      scale: vars.image_data_scale,
      crs: 'EPSG:4326',
      maxPixels: 1e13,
      pyramidingPolicy: {'.default': 'mode'}
    });
    
  } else {
    if (vars.reproject_display) {
      Map.addLayer(clean_map.reproject(ee.Projection('EPSG:4326').atScale(vars.image_data_scale)), display_pal, output_name, true);
    } else {
      Map.addLayer(clean_map, display_pal, output_name, false);
    }
  }

}

//Generate title
var title = ui.Label({
  value: 'Classes',
  style: {fontWeight: 'bold', fontSize: '12px'}
});

// generate the legend
var geo_legend = pkg_vis.discrete_legend(map_palettes.geo_atlas_names, map_palettes.geo_atlas_cols, 'Geomorphic Zone', false);
var benthic_legend = pkg_vis.discrete_legend(map_palettes.benthic_atlas_names, map_palettes.benthic_atlas_cols, 'Benthic Habitat', false);
//var mask_legend = pkg_vis.discrete_legend(["Low confidence depth","Water conditions"], ["#f7f7f7","#bababa"], 'Confidence Mask reason', false)
var legend = (vars.geomorphic) ? geo_legend : benthic_legend;
pkg_vis.add_lgds([title, legend]);//, mask_legend])
// generate the legend
