/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var imageVisParam = {"opacity":1,"bands":["depth"],"min":1500,"max":2500,"gamma":1},
    GCRMN_ext = ee.Image("projects/coral_atlas/global_datasets/GCRMN_reefextent_final"),
    mask4 = ee.FeatureCollection("projects/coral_atlas/ne_asia/in_out/TAJ_mid_mask_4"),
    wcmc = ee.FeatureCollection("projects/coral_atlas/global_datasets/wcmc_reefs_2018v4_dissolved"),
    GCRSmask1 = ee.FeatureCollection("projects/coral_atlas/ne_asia/in_out/TAJ_Geoclean3_rulesetmask1"),
    GCRSmask2 = ee.FeatureCollection("projects/coral_atlas/ne_asia/in_out/TAJ_Geoclean3_rulesetmask2"),
    phm = ee.FeatureCollection("projects/coral_atlas/ne_asia/in_out/TAJ_PortHarborMask"),
    XTOMASK = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry({
      "type": "GeometryCollection",
      "geometries": [
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                128.02163665132662,
                26.69478699549302
              ],
              [
                128.0123240216269,
                26.67814574546122
              ],
              [
                128.01271025972505,
                26.677992358586696
              ],
              [
                128.0222803814902,
                26.695285428636815
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                127.87547628196491,
                26.634257133469518
              ],
              [
                127.87480036529315,
                26.632521265080193
              ],
              [
                127.87693540366901,
                26.63247331254039
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                127.88104153442382,
                26.64546096553112
              ],
              [
                127.87913180160521,
                26.646554154126914
              ],
              [
                127.8784451560974,
                26.645556859686355
              ],
              [
                127.8783378677368,
                26.64448284054797
              ],
              [
                127.87790871429442,
                26.643523886352813
              ],
              [
                127.87683583068846,
                26.64137579973492
              ],
              [
                127.87649250793456,
                26.641299081608473
              ],
              [
                127.87647105026244,
                26.641068926919885
              ],
              [
                127.8767714576721,
                26.64085795138128
              ],
              [
                127.87831641006468,
                26.640896310599107
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                127.87395709593245,
                26.64891256331394
              ],
              [
                127.88076990683028,
                26.650370101721045
              ],
              [
                127.88076990683028,
                26.650571470695876
              ],
              [
                127.87401074011275,
                26.64912352397192
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                127.99328686316056,
                26.66801817020743
              ],
              [
                127.99580813963456,
                26.66685807384275
              ],
              [
                127.99592615683122,
                26.66710735174266
              ],
              [
                127.99337269384904,
                26.668209920536558
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                128.03308965043018,
                26.64655686913269
              ],
              [
                128.03197385148,
                26.641992258005665
              ],
              [
                128.03233863190601,
                26.64203061684251
              ],
              [
                128.03341151551197,
                26.646576047786102
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                128.03369046524952,
                26.636842467197738
              ],
              [
                128.0338835842986,
                26.635653283251408
              ],
              [
                128.03407670334767,
                26.635682053976858
              ],
              [
                128.0339050419707,
                26.63689041790365
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                128.1051992765604,
                26.671135280874
              ],
              [
                128.1041907659708,
                26.667722164351826
              ],
              [
                128.10361140882358,
                26.664807512105458
              ],
              [
                128.10322517072544,
                26.663925431617166
              ],
              [
                128.10356849347934,
                26.66386790439194
              ],
              [
                128.10389035856113,
                26.664692458515454
              ],
              [
                128.10446971570835,
                26.667818039805425
              ],
              [
                128.10547822629795,
                26.67094353546229
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        }
      ],
      "coordinates": []
    }),
    RUTOCA = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry({
      "type": "GeometryCollection",
      "geometries": [
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                127.86270934637831,
                26.63345348503175
              ],
              [
                127.86365348395155,
                26.632149179420352
              ],
              [
                127.87036973532484,
                26.63938021560666
              ],
              [
                127.86805230673598,
                26.63997478972783
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                127.87335283623962,
                26.64739667905039
              ],
              [
                127.87303097115783,
                26.646476106668583
              ],
              [
                127.87260181771545,
                26.646020612380877
              ],
              [
                127.87261791096954,
                26.64550278508898
              ],
              [
                127.87352449761657,
                26.645301407174628
              ],
              [
                127.87396437989501,
                26.647161742012482
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                127.86168653499604,
                26.63108069300067
              ],
              [
                127.86229807865143,
                26.629009098819626
              ],
              [
                127.86352116596223,
                26.62902828041948
              ],
              [
                127.86392886173249,
                26.6319150744913
              ],
              [
                127.86284524929047,
                26.63297962133998
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        }
      ],
      "coordinates": []
    }),
    RUTOROCK = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry({
      "type": "GeometryCollection",
      "geometries": [
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                127.87054188119201,
                26.64694118843495
              ],
              [
                127.87185079919128,
                26.643441042028883
              ],
              [
                127.87250525819091,
                26.643910930931547
              ],
              [
                127.8724838005188,
                26.64585759293114
              ],
              [
                127.87299878464965,
                26.64647131200133
              ],
              [
                127.8732240902069,
                26.64701790277109
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                127.87039298545838,
                26.641349395209964
              ],
              [
                127.87120837699891,
                26.640879495767955
              ],
              [
                127.87218470108033,
                26.64276867158211
              ],
              [
                127.87101525794984,
                26.642883747271703
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                127.869963832016,
                26.63958367780193
              ],
              [
                127.87015695106507,
                26.640082352192326
              ],
              [
                127.86932010185242,
                26.640168661000406
              ],
              [
                127.8697117043686,
                26.63964601221979
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                127.85774542981987,
                26.630423795776352
              ],
              [
                127.85840525323754,
                26.62974525301018
              ],
              [
                127.8584159820736,
                26.630452567818732
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        }
      ],
      "coordinates": []
    }),
    SGTOCA = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.MultiPolygon(
        [[[[127.87865930343902, 26.649218815068288],
           [127.87942105079925, 26.648911963329393],
           [127.87947469497955, 26.651280453804077],
           [127.87870221878326, 26.651481821173192]]],
         [[[127.87378482196785, 26.648209736745326],
           [127.87366680477119, 26.64778781166277],
           [127.87405304286933, 26.64778781166277],
           [127.8740637717054, 26.64811384481801]]],
         [[[127.87276558254219, 26.645975433916853],
           [127.87277631137825, 26.645668573461457],
           [127.87311963413215, 26.645668573461457],
           [127.87317327831245, 26.646052148901823]]],
         [[[127.87493280742622, 26.645294586166546],
           [127.87559799526191, 26.645006902798535],
           [127.87595204685188, 26.645965844540086],
           [127.8754156050489, 26.64614804256061]]],
         [[[127.87347368572212, 26.64740424205292],
           [127.87337712619758, 26.647154921115543],
           [127.87370972011543, 26.64705902830235],
           [127.87372044895149, 26.64730834944911]]],
         [[[127.87658591257966, 26.67860570148752],
           [127.87690777766144, 26.67755116681193],
           [127.8816713808719, 26.679315110236686],
           [127.88016934382355, 26.680043687601074]]],
         [[[127.88822685165435, 26.706454291327095],
           [127.88796935958892, 26.706118840610866],
           [127.8884521572116, 26.706080503323253]]],
         [[[127.88381741080586, 26.70928724387946],
           [127.88631722960774, 26.707418338083283],
           [127.8854267362148, 26.710111469509815]]],
         [[[127.89192624567734, 26.70493849262551],
           [127.8915292777491, 26.705710036298218],
           [127.89085336184385, 26.704564698950044],
           [127.89179749964462, 26.704133398531795],
           [127.89820261477219, 26.702964085070484],
           [127.8992325830339, 26.704612621892164],
           [127.89710827349411, 26.705494387606986],
           [127.89231248377548, 26.70528353120926]]],
         [[[127.89873198109709, 26.7058641385659],
           [127.8985174043759, 26.70542325799312],
           [127.89907530385099, 26.705394504853004]]]]),
    SGTOROCK = 
    /* color: #98ff00 */
    /* shown: false */
    ee.Geometry.MultiPolygon(
        [[[[127.8725784404988, 26.64677382981235],
           [127.87234240610549, 26.646049834665224],
           [127.87288957674453, 26.64599229843015],
           [127.87329190809676, 26.64675944584749]]],
         [[[127.87221094454976, 26.645354916160326],
           [127.87276884402486, 26.64529737957511],
           [127.8727768906519, 26.645697737713],
           [127.87224313105794, 26.645733697956075]]]]),
    CATOSG = 
    /* color: #ffc82d */
    /* shown: false */
    ee.Geometry.MultiPolygon(
        [[[[127.87820807144166, 26.707081376568368],
           [127.87803641006471, 26.704934486732277],
           [127.87803641006471, 26.704110223633208],
           [127.87559023544313, 26.702653371939608],
           [127.87552586242677, 26.70010383664022],
           [127.87696352645875, 26.70058307695363],
           [127.87837973281862, 26.70046805946226],
           [127.87917366668702, 26.702116632408096],
           [127.8796028201294, 26.70351598374518],
           [127.87898054763795, 26.704091054652956]]],
         [[[127.87528982803346, 26.69751590411034],
           [127.8747748439026, 26.696672417101976],
           [127.8747748439026, 26.695560538322766],
           [127.87473192855836, 26.69490874226977],
           [127.87518253967286, 26.69494708331729],
           [127.87604084655763, 26.696039797747748],
           [127.87608376190187, 26.696710757556],
           [127.87593355819703, 26.69751590411034]]]]),
    SATOSG = 
    /* color: #00ffff */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[127.87613740776398, 26.70203036883593],
          [127.87625542327882, 26.701311518368723],
          [127.87857285186769, 26.70081311158793],
          [127.8796028201294, 26.703400969215213],
          [127.87898054763795, 26.70357349096663],
          [127.87741413076081, 26.70341056235908],
          [127.8756760661316, 26.70263420271418]]]),
    ROTOSG = 
    /* color: #bf04c2 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[127.87559888335024, 26.70257776504928],
          [127.87558815451418, 26.702165625717985],
          [127.8758456465796, 26.701235910587734],
          [127.87586710425172, 26.700612901357513],
          [127.87843129606996, 26.70059373178871],
          [127.87875316115175, 26.701303003686217],
          [127.87904283972536, 26.70217521037053],
          [127.8794290778235, 26.702635272744374],
          [127.87940762015138, 26.703095333260066]]]),
    SGTORU = 
    /* color: #ff0000 */
    /* shown: false */
    ee.Geometry.MultiPolygon(
        [[[[127.88707886619598, 26.706051750349058],
           [127.8880015460971, 26.70674181972604],
           [127.88695012016326, 26.707594816371618],
           [127.88608108444244, 26.707211447883147]]],
         [[[127.887443646622, 26.70625302101592],
           [127.8870466796878, 26.705850479326504],
           [127.88849507255584, 26.705208326543456],
           [127.88912807388336, 26.705639623588027],
           [127.88888131065399, 26.70604216602273]]],
         [[[127.89076958580047, 26.70681849384315],
           [127.88938556594879, 26.705697129737246],
           [127.8899112789157, 26.704834534450406],
           [127.89205704612762, 26.705879232351514],
           [127.89128456993133, 26.706895167908634]]],
         [[[127.88796947036091, 26.70710205868333],
           [127.89055511985127, 26.706900789516954],
           [127.89076969657246, 26.709459756714352],
           [127.88710043464009, 26.7091147307832]]],
         [[[127.89262007811833, 26.70604562634849],
           [127.89332818129826, 26.70565266828596],
           [127.89345692733097, 26.706563178801055]]],
         [[[127.89938644009672, 26.7036117959894],
           [127.90184334355436, 26.70393766958616],
           [127.90100649434171, 26.706113331178173],
           [127.89921477871977, 26.7038801625486]]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
///////////////////////////////
// Global coral atlas project - North East Asia     
// Contact: mitchell.lyons@gmail.com
// Region coordinator: Robert Canto
// Description:
// - Developing a process to combine OBIA and supervised classification
// - This script loads the raw classification data (from *_classification script)
// - Then applied some cleanup and object-based relational rules
///////////////////////////////

// Table of contents  
// 1. Setting constants 
// 2. Data loads & vis
// 3. OBIA clean up rules 
// 4. Export

// Load and libraries needed
var map_palettes = require('users/mitchest/global_reefs_modules:colour_pals');
var param_module = require('users/mitchest/global_reefs_modules:reef_params');
var pkg_vis = require('users/mitchest/global_reefs_modules:pkg_vis');

// ###########################################
// SENSOR GENERICS
var sensor_params = param_module.dove;         //<------------ THIS IS WHERE YOU CHOOSE THE SENSOR
// REGION AND SENSOR SPECIFIC LOAD PATHS
var region_params = param_module.ne_asia;  //<------------ THIS IS WHERE YOU CHOOSE THE REGION
//  ^^ all the data paths are in this module ^^
// ###########################################

// 1. Setting constants

// These will get written to the asset metadata 

var vars = {
  
  // analysis type
  geomorphic: false, // map geomorphic zonation (when set to true) or benthic habitat (when set to false)

  // analysis parameters
  image_data_scale: sensor_params.pixel,
  small_object_geo: ee.Number(400).int(), // smallest object szie in pixels (geomorphic)
  small_object_benthic: ee.Number(130).int(), // smallest object szie in pixels (benthic)
  smooth_radius: ee.Number(1), // radius in pixels for initial smooth 
  dist_to_land_ORF: 1250, //distance to land in meters to convert terrestrial reef flat to ORF
  dist_to_land_RC: 500, //distance to land in meters to convert reef crest to TRF
  wave_height: 0.6, //cut off height for waves in metres, Hs95 threshold
  geo_depth_cutoff: 1250, //depth in centimetres
  shallowlag_depth_cutoff: 500, //depth in centimetres
  benthic_depth_cutoff: 800, //depth in centimetres
  turbid1_depth_cutoff: 500,//depth in centimeters to be combined with depth5m_mask Code introduced CR
  turbid2_depth_cutoff: 800,//depth in centimeters to be combined with depth8m_mask Code introduced CR
  
  //############
  // Clean-up stage selection
  cleanup_stage: 2, // set to 1, 2 or 3
  geo_refinement: false, // set to true to apply the refinement_mask (the other stage 3 masks will still run)
  
  // should the global extent + depth cleanup be applied?
  global_extent_clean: true,
  global_depth_thresh: 500, // this is the depth limit for ADDING to the global extent (i.e. 5 = everything <5m will be added to the global extent layer)
  
  /*
  - GEOMORPHIC 1: The first pass does a small object filter, just to generally clean noise and reduce the amount of cleaning needed
  -            2: The second pass runs the OBIA cleanup rules
  -            3: The third pass is the MANUAL cleanup stage, which includes AT LEAST the no_reef masking
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY

  - BENTHIC 1: This is the main benthic stge - it does noise removal, no data reclaim and OBIA rules - review those if needed
            2: The second mas is the MANUAL stage - it's optional, but shuold include ALL region specific stuff
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY
  */
  
  // DON'T TOUCH --->
  obia_2nd_pass: null,
  obia_clean: null, // run object-based relationship rules + small object clean up
  fast_clean: null, // run a faster (but less precise) version of the OBIA clean; only applies to geomorphic (`obia_clean: true` also)
  manual_clean: false, // apply manual touch ups
  // --------------<
  //############
  
  reproject_display: true,
  
  // export options
  do_export: true, // export the results?
  geomorph_output_name: region_params.sname + '_geo_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  benthic_output_name: region_params.sname + '_benthic_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  asset_output: region_params.asset // asset path

};


// Clean up stage auto-parameterisation (DON'T TOUCH) --->

if (vars.geomorphic) {
  var temp_outname = vars.geomorph_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.obia_2nd_pass = true;
    vars.obia_clean = true;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '2';
  } else if (vars.cleanup_stage == 3) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = false;
    vars.do_export = false;
    vars.geomorph_output_name = temp_outname + '3G';
  }
}

if (!vars.geomorphic) {
  var temp_outname = vars.benthic_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = true,
    vars.obia_clean = true, 
    vars.fast_clean = false, 
    vars.manual_clean = false;
    vars.benthic_output_name = temp_outname + '1b';
  } else if (vars.cleanup_stage == 2) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false,
    vars.obia_clean = false, 
    vars.fast_clean = false,
    vars.do_export = false;
    vars.benthic_output_name = temp_outname + '2FINALb';
  }
}

//Region extent is created in map viewer and exported to GEE asset
var region_extent = ee.FeatureCollection(region_params.extent_mask).geometry();
Map.addLayer(region_extent, {}, "Manual reef outline", false);
// -----------------------------------------<

//################################################################################################
//START OF CLEAN 3 - Manual Cleanup
//Review everything in this section
//This is the section to add/remove manual cleanups
//You MUST review it for each region

//###############################################################################################

if (vars.manual_clean && vars.geomorphic) {
  
  print("Doing GEOMORPHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.segments).select('depth');// replace pixel with segments
  
  // define the manually edited map - uses the output from the second pass of cleaning
  var man_geo = ee.Image(region_params.geo_map_clean2);
  
  /*
   // the "GLOBAL MASK" clean
  // currently uses GCRMN extent + bathymetry threhold < vars.global_depth_thresh
  if (vars.global_extent_clean) {
    var blanket_mask = ee.Image([param_module.global_extent_mask.gcrmn]).unmask(0, false)
              .eq(1) // extent according to global extent layer
              .add(depth.lt(vars.global_depth_thresh)) // combine with areas less than depth thrshold
              .eq(0) // get leftovers
              .selfMask().connectedPixelCount(25, true).gte(25);
    
    man_geo = man_geo.where({
      test: blanket_mask.eq(1),
      value: ee.Image(0)
    });
  }
  
  
  /*
  // import the mid mask from asset ****only use ee.FC if mid_mask created in map viewer****
 
  var mid_mask = ee.FeatureCollection(region_params.mid_mask).geometry();
  var midmask = ee.Image().byte().paint(ee.Feature(mid_mask.dissolve(),{zone: 1}), "zone").clip(mid_mask.dissolve());
  
  // the "MID MASK" CLEAN
  man_geo = man_geo.where({
    test: midmask.eq(1),
    value: ee.Image(0)
  });
   */
  
 //START**************************************************************************************************************************START
 //************************************* START clean up deep water using reef extent  *******************************START
 //*******************************************************************************************************************************START
 // Masking out all the areas that fall outside GCRMN_ext (the reef extent globally) or areas deeper then treshold depth
 // no additional mask are needed
 //*******************************************************************************************************************************START
 //***********Intergrating global mask to get out reefs to deep imagery to bad to get out using GCRMN_ext_mask created in viewer 
 
 /* 
 var GCRMNext = ee.Image(GCRMN_ext).unmask(0,false);//to take care GCRMN_ext has 1 for reef and 0 for no reef

 // START-ALL REEF EXTENT *****Maps areas that fall within GCRMN reef ext and < 5 m (turbid1_depth_cutoff)*************START
 
  man_geo = man_geo.where({
    test:  (GCRMNext.eq(1).add(depth.lt(vars.turbid1_depth_cutoff)).eq(0)),
    value: ee.Image(0)
  });
 // END-ALL REEF EXTENT *****Maps areas that fall within GCRMN reef ext and < 5 m (turbid1_depth_cutoff)*************START*/
 
 /*
 
// import the depth8m_mask from asset ****only use ee.FC if depth8m_mask created in map viewer****
  
  var turbiddeep_mask = ee.FeatureCollection(region_params.depth8m_mask).geometry();
  var turbiddeepmask = ee.Image().byte().paint(ee.Feature(turbiddeep_mask.dissolve(),{zone: 1}), "zone").clip(turbiddeep_mask.dissolve());
  
  // the "turdbid MASK" applied to areas deeper then 8 m
  man_geo = man_geo.where({
    test: (turbiddeepmask.eq(1).and(GCRMNextmask.neq(1)))
                           .and(depth.gt(vars.turbid2_depth_cutoff)),
                         //.and ((GCRMNextmask.eq(0).add(depth.gt(vars.turbid2_depth_cutoff))).eq(1)),
    value: ee.Image(0)
  });
  
   // import the depth5m_mask from asset ****only use ee.FC if depth5m_mask created in map viewer****
  
  var turbid_mask = ee.FeatureCollection(region_params.depth5m_mask).geometry();
  var turbidmask = ee.Image().byte().paint(ee.Feature(turbid_mask.dissolve(),{zone: 1}), "zone").clip(turbid_mask.dissolve());
  
  // the "turdbid MASK" applied to areas deeper then 5 m
  man_geo = man_geo.where({
    test: (turbidmask.eq(1).and (GCRMNextmask.eq(0)))
                     .and(depth.gt(vars.turbid1_depth_cutoff)),
                     //.and ((GCRMNextmask.eq(0).add(depth.gt(vars.turbid1_depth_cutoff))).eq(0)),
    value: ee.Image(0)
  });
  */


/* */
 //************************************* START Import AND APPLY Lagoons mask TAJ (by Chris) ************************************START
  // import the lagoon mask from asset ****only use ee.FC if  lagoons mask created in map viewer****
 
 
 
  //************************************* END IMPORT AND APPLY Lagoons mask TAJ ************************************END
  
  //*********************START CREATING and APPLYING REEF OUTINE BUFFER FROM  reef (lagoon) mask by Chris TAJ **************START
  // in map viewer manual digitised reef top areas with lagoon in it. Tried to use CNN layer but to many artefacts and manual took 3 hr
  // creatimg a buffer around lagoon_mask

 

  //********************* END CREATING and APPLYING REEF OUTINE BUFFER FROM  Lagoons mask Chris TAJ*****************END

/*


  //************************************* clean up small groups of  pixesl in deep water Chris RSAG ************************************
  
var man_geo = man_geo.where({
   test:man_geo.eq(22)// Reef Slope pixels
    .connectedPixelCount(25,false).lt(25),//selects group of pixel that are RS and neighbouring each other, with groups smaller then 25
   value: ee.Image(0) // change those selected no class
  });
   var man_geo = man_geo.where({
    test:man_geo.eq(12)// Deep Lagoon pixels
    .connectedPixelCount(25,false).lt(25),//selects group of pixel that are Deep Lagoon and neighbouring each other, with groups smaller then 25
    value: ee.Image(0) // change those selected no class
  });
     var man_geo = man_geo.where({
    test:man_geo.eq(23)// Plateau pixels
    .connectedPixelCount(25,false).lt(25),//selects group of pixel that are Plateau and neighbouring each other, with groups smaller then 25
    value: ee.Image(0) // change those selected no class
  });
  
 //************************************* END flean up small groups of pixesl in deep water Chris RSAG ************************************
 //************************************* END Import AND APPLY 5m and 8 m mask Chris RSAG************************************START
 //*************************************************************************************************************************START 
 */
 
 // Manual additions for NEA/TAJ Geomorphic
 
 /*
//v3_1
 
 var RCtOORF = ee.Image().byte().paint(ee.Feature(RCTOORF, {zone: 1}), "zone").clip(RCTOORF);
  
  man_geo = man_geo.where({
    test:  RCtOORF.eq(1)
                .and(man_geo.eq(15)), 
    value: ee.Image(14)//BRS
  });

//v3_1

//v3_2

 var SRSBRStORS = ee.Image().byte().paint(ee.Feature(SRSBRSTORS, {zone: 1}), "zone").clip(SRSBRSTORS);
  
  man_geo = man_geo.where({
    test:  SRSBRStORS.eq(1)
                .and(man_geo.eq(24).or(man_geo.eq(21))), 
    value: ee.Image(22)//BRS
  });


//v3_2
 
 //v3_3 RS22 BRS24 TO SRS21
 
 

 var RSBRStOSRS = ee.Image().byte().paint(ee.Feature(RSBRSTOSRS, {zone: 1}), "zone").clip(RSBRSTOSRS);
  
  man_geo = man_geo.where({
    test:  RSBRStOSRS.eq(1)
                .and(man_geo.eq(24).or(man_geo.eq(22))), 
    value: ee.Image(21)//BRS
  });
 
 //v3_3
 
 //v3_4
 
  var TRFIRFtOORF = ee.Image().byte().paint(ee.Feature(TRFIRFTOORF, {zone: 1}), "zone").clip(TRFIRFTOORF);
  
  man_geo = man_geo.where({
    test:  TRFIRFtOORF.eq(1)
                .and(man_geo.eq(16).or(man_geo.eq(13))), 
    value: ee.Image(14)//BRS
  });
 
 //v3_4
 
 //v3_5
 
 var DLtORS = ee.Image().byte().paint(ee.Feature(DLTORS, {zone: 1}), "zone").clip(DLTORS);
  
  man_geo = man_geo.where({
    test:  DLtORS.eq(1)
                .and(man_geo.eq(12)), 
    value: ee.Image(22)//BRS
  });
 
 //v3_5
 
  //v3_6
  
  var SLtOSRS = ee.Image().byte().paint(ee.Feature(SLTOSRS, {zone: 1}), "zone").clip(SLTOSRS);
  
  man_geo = man_geo.where({
    test:  SLtOSRS.eq(1)
                .and(man_geo.eq(11)), 
    value: ee.Image(21)//BRS
  });
  
  //v3_6
 
 //v3_7
 
 var IRFORFtOTRF = ee.Image().byte().paint(ee.Feature(IRFORFTOTRF, {zone: 1}), "zone").clip(IRFORFTOTRF);
  
  man_geo = man_geo.where({
    test:  IRFORFtOTRF.eq(1)
                .and(man_geo.eq(13).or(man_geo.eq(14))), 
    value: ee.Image(16)//BRS
  });
 
 //v3_7
 
  //v3_8
  
  var SLtOTRF = ee.Image().byte().paint(ee.Feature(SLTOTRF, {zone: 1}), "zone").clip(SLTOTRF);
  
  man_geo = man_geo.where({
    test:  SLtOTRF.eq(1)
                .and(man_geo.eq(11)), 
    value: ee.Image(16)//BRS
  });
  
  //v3_8
  
  //v3_9
  
   var IRFtOORF = ee.Image().byte().paint(ee.Feature(IRFTOORF, {zone: 1}), "zone").clip(IRFTOORF);
  
  man_geo = man_geo.where({
    test:  IRFtOORF.eq(1)
                .and(man_geo.eq(13)), 
    value: ee.Image(14)//BRS
  });
  
  //v3_9
  
  //v3_10
   
    var TRFtOIRF = ee.Image().byte().paint(ee.Feature(TRFTOIRF, {zone: 1}), "zone").clip(TRFTOIRF);
  
  man_geo = man_geo.where({
    test:  TRFtOIRF.eq(1)
                .and(man_geo.eq(16)), 
    value: ee.Image(13)//BRS
  });
  
   
  //v3_10
  
  //v3_11
  
    var IRFtOTRF = ee.Image().byte().paint(ee.Feature(IRFTOTRF, {zone: 1}), "zone").clip(IRFTOTRF);
  
  man_geo = man_geo.where({
    test:  IRFtOTRF.eq(1)
                .and(man_geo.eq(13)), 
    value: ee.Image(16)//BRS
  });
   
  //v3_11
  
  //v3_12
  
    var TRFtOORF = ee.Image().byte().paint(ee.Feature(TRFTOORF, {zone: 1}), "zone").clip(TRFTOORF);
  
  man_geo = man_geo.where({
    test:  TRFtOORF.eq(1)
                .and(man_geo.eq(16)), 
    value: ee.Image(14)//BRS
  });
  
  //v3_12
  
  
   //v3_12
   
    var ORFtOIRF = ee.Image().byte().paint(ee.Feature(ORFTOIRF, {zone: 1}), "zone").clip(ORFTOIRF);
  
  man_geo = man_geo.where({
    test:  ORFtOIRF.eq(1)
                .and(man_geo.eq(14)), 
    value: ee.Image(13)//BRS
  });
   
    //v3_12
  
  
  //v3_13
    
      var XtoDW = ee.Image().byte().paint(ee.Feature(XTODW, {zone: 1}), "zone").clip(XTODW)
 print (XtoDW)
 
man_geo = man_geo.where({
    test: XtoDW.eq(1)
            ,
    value: ee.Image(2)
  });
    
//v3_13
      
//v3_14
         
var SLtOIRF = ee.Image().byte().paint(ee.Feature(SLTOIRF, {zone: 1}), "zone").clip(SLTOIRF);
  
  man_geo = man_geo.where({
    test:  SLtOIRF.eq(1)
                .and(man_geo.eq(11)), 
    value: ee.Image(13)//BRS
  });
         
//v3_14

//v3_15

var RStOIRF = ee.Image().byte().paint(ee.Feature(RSTOIRF, {zone: 1}), "zone").clip(RSTOIRF);
  
  man_geo = man_geo.where({
    test:  RStOIRF.eq(1)
                .and(man_geo.eq(22)), 
    value: ee.Image(13)//BRS
  });

//v3_15
  
  //v3_16
  
  var DLSLtOSRS = ee.Image().byte().paint(ee.Feature(DLSLTOSRS, {zone: 1}), "zone").clip(DLSLTOSRS);
  
  man_geo = man_geo.where({
    test:  DLSLtOSRS.eq(1)
                .and(man_geo.eq(12).or(man_geo.eq(11))),
    value: ee.Image(21)//BRS
  });
  
  //v3_16
  
  //v3_17
  
  var XtORS = ee.Image().byte().paint(ee.Feature(XTORS, {zone: 1}), "zone").clip(XTORS)
 print (XtORS)
 
man_geo = man_geo.where({
    test: XtORS.eq(1)
            ,
    value: ee.Image(22)
  });
  
  //v3_17
  
  //v3_18
  
 var ORFtOTRF = ee.Image().byte().paint(ee.Feature(ORFTOTRF, {zone: 1}), "zone").clip(ORFTOTRF);
  
  man_geo = man_geo.where({
    test:  ORFtOTRF.eq(1)
                .and(man_geo.eq(14)), 
    value: ee.Image(16)//BRS
  });
  
  //v3_18
  
   //v3_19
   
       var XtOPL = ee.Image().byte().paint(ee.Feature(XTOPL, {zone: 1}), "zone").clip(XTOPL)
 print (XtOPL)
 
man_geo = man_geo.where({
    test: XtOPL.eq(1)
            ,
    value: ee.Image(23)
  });
   
    //v3_19
    
     //v3_20
     
     var DLSLtORS = ee.Image().byte().paint(ee.Feature(DLSLTORS, {zone: 1}), "zone").clip(DLSLTORS);
  
  man_geo = man_geo.where({
    test:  DLSLtORS.eq(1)
                .and(man_geo.eq(12).or(man_geo.eq(11))),
    value: ee.Image(22)//BRS
  });
     
      //v3_20
  
  //v3_21
  
   var RCtOTRF = ee.Image().byte().paint(ee.Feature(RCTOTRF, {zone: 1}), "zone").clip(RCTOTRF);
  
  man_geo = man_geo.where({
    test:  RCtOTRF.eq(1)
                .and(man_geo.eq(15)), 
    value: ee.Image(16)//BRS
  });
  
  //v3_21
  
   //v3_22
   
   var DLtODW = ee.Image().byte().paint(ee.Feature(DLTODW, {zone: 1}), "zone").clip(DLTODW);
  
  man_geo = man_geo.where({
    test:  DLtODW.eq(1)
                .and(man_geo.eq(12)), 
    value: ee.Image(2)//BRS
  });
   
    //v3_22
  */

/*
//v2_1 RS22 BRS24 TO SRS21

 var RSBRStOSRS = ee.Image().byte().paint(ee.Feature(RSBRSTOSRS, {zone: 1}), "zone").clip(RSBRSTOSRS);
  
  man_geo = man_geo.where({
    test:  RSBRStOSRS.eq(1)
                .and(man_geo.eq(24).or(man_geo.eq(22))), 
    value: ee.Image(21)//BRS
  });

//v2_1

//v2_2 SRS21 BRS24 TO RS22

 var SRSBRStORS = ee.Image().byte().paint(ee.Feature(SRSBRSTORS, {zone: 1}), "zone").clip(SRSBRSTORS);
  
  man_geo = man_geo.where({
    test:  SRSBRStORS.eq(1)
                .and(man_geo.eq(24).or(man_geo.eq(21))), 
    value: ee.Image(22)//BRS
  });


//v2_2

//v2_3

var RStOBRS = ee.Image().byte().paint(ee.Feature(RSTOBRS, {zone: 1}), "zone").clip(RSTOBRS);
  
  man_geo = man_geo.where({
    test:  RStOBRS.eq(1)
                .and(man_geo.eq(22)), 
    value: ee.Image(24)//BRS
  });

//v2_3

//v2_4

var RCtOORF = ee.Image().byte().paint(ee.Feature(RCTOORF, {zone: 1}), "zone").clip(RCTOORF);
  
  man_geo = man_geo.where({
    test:  RCtOORF.eq(1)
                .and(man_geo.eq(15)), 
    value: ee.Image(14)//BRS
  });

//v2_4

//v2_5

 var XtODW = ee.Image().byte().paint(ee.Feature(XTODW, {zone: 1}), "zone").clip(XTODW)
 print (XtODW)
 
man_geo = man_geo.where({
    test: XtODW.eq(1)
            ,
    value: ee.Image(2)
  });

//v2_5

//v2_6

var BRStOSRS = ee.Image().byte().paint(ee.Feature(BRSTOSRS, {zone: 1}), "zone").clip(BRSTOSRS);
  
  man_geo = man_geo.where({
    test:  BRStOSRS.eq(1)
                .and(man_geo.eq(24)), 
    value: ee.Image(21)//BRS
  });


//v2_6

//v2_7

var BRStOORF = ee.Image().byte().paint(ee.Feature(BRSTOORF, {zone: 1}), "zone").clip(BRSTOORF);
  
  man_geo = man_geo.where({
    test:  BRStOORF.eq(1)
                .and(man_geo.eq(24)), 
    value: ee.Image(14)//BRS
  });


//v2_7

//v2_8

var SRSRStOBRS = ee.Image().byte().paint(ee.Feature(SRSRSTOBRS, {zone: 1}), "zone").clip(SRSRSTOBRS);
  
  man_geo = man_geo.where({
    test:  SRSRStOBRS.eq(1)
                .and(man_geo.eq(21).or(man_geo.eq(22))), 
    value: ee.Image(24)//BRS
  });

//v2_8 

//v2_9

var RCtOIRF = ee.Image().byte().paint(ee.Feature(RCTOIRF, {zone: 1}), "zone").clip(RCTOIRF);
  
  man_geo = man_geo.where({
    test:  RCtOIRF.eq(1)
                .and(man_geo.eq(15)), 
    value: ee.Image(13)//BRS
  });

//v2_9

//v2_10 RS TO  SRS

var RStOSRS = ee.Image().byte().paint(ee.Feature(RSTOSRS, {zone: 1}), "zone").clip(RSTOSRS);
  
  man_geo = man_geo.where({
    test:  RStOSRS.eq(1)
                .and(man_geo.eq(22)), 
    value: ee.Image(21)//BRS
});

//v2_10
*/



/*
//1 apply Geoclean3_rulesetmask1 for 136.09032, 20.42189

 // import the lagoon mask from asset ****only use ee.FC if  lagoons mask created in map viewer****
  var geoclean3_rulesetmask1 = ee.FeatureCollection(region_params.Geoclean3_rulesetmask1).geometry();
  var geoclean3rulesetmask1 = ee.Image().byte().paint(ee.Feature(geoclean3_rulesetmask1.dissolve(),{zone: 1}), "zone").clip(geoclean3_rulesetmask1.dissolve());


// RC, IRF, TRF (within lagoon mask) -> Outer Reef flat 
 man_geo = man_geo.where({
  test: geoclean3rulesetmask1.eq(1)
                    .and(man_geo.eq(13).or(man_geo.eq(16)).or(man_geo.eq(15))),
    value: ee.Image(14)
 });    
 
 //DL, SL, , SRS, RS (within mask) --> Back reef slope
  man_geo = man_geo.where({
  test: geoclean3rulesetmask1.eq(1)
                    .and(man_geo.eq(12).or(man_geo.eq(21)).or(man_geo.eq(11)).or(man_geo.eq(22))),
    value: ee.Image(24)
 });   
 
 
  var polygon_buffered = geoclean3_rulesetmask1.buffer(1000); // buffer 1000 m wide around reef mask
  var polygon_band_mask = polygon_buffered.difference(geoclean3_rulesetmask1);//substract buffered lagoon mask - lagoon mask resulting in band around reef of 1000 m
  var polygonbandmask = ee.Image().byte().paint(ee.Feature(polygon_band_mask.dissolve(),{zone: 1}), "zone").clip(polygon_band_mask.dissolve()); // paint it as image

  //  DL, SL, SRS, BRS should not be present on outside of reef on within reefbandmask  -> Reef Slope
 man_geo = man_geo.where({
  test: polygonbandmask.eq(1)
                    .and(man_geo.eq(11).or(man_geo.eq(24)).or(man_geo.eq(21)).or(man_geo.eq(12))),
    value: ee.Image(22)
 });    
 
  // TRF, IRF on within reefbandmask  -> ORF 
  man_geo = man_geo.where({
  test: polygonbandmask.eq(1)
                    .and(man_geo.eq(16).or(man_geo.eq(13))),
    value: ee.Image(14)
 });   
 //1



 //2 Apply Geoclean3_rulesetmask2 (taiwan polygon) from asset ****only use ee.FC if  lagoons mask created in map viewer****
  var geoclean3_rulesetmask2 = ee.FeatureCollection(region_params.Geoclean3_rulesetmask2).geometry();
  var geoclean3rulesetmask2 = ee.Image().byte().paint(ee.Feature(geoclean3_rulesetmask2.dissolve(),{zone: 1}), "zone").clip(geoclean3_rulesetmask2.dissolve());


// x (within lagoon mask) -> RC15, IRF13, TRF16 to ORF14 EDIT HERE
 man_geo = man_geo.where({
  test: geoclean3rulesetmask2.eq(1)
                    .and(man_geo.eq(15).or(man_geo.eq(13)).or(man_geo.eq(16))),
    value: ee.Image(14)
 });    
 
 //x --> x  DL12, SL11, SRS21, BRS24 to RS22
  man_geo = man_geo.where({
  test: geoclean3rulesetmask2.eq(1)
                    .and(man_geo.eq(12).or(man_geo.eq(21)).or(man_geo.eq(11)).or(man_geo.eq(24))),
    value: ee.Image(22)
 });   
 //2
 
 //3 Lagoons Mask for TAJ
 
  var lagoons_mask = ee.FeatureCollection(region_params.Lagoons_mask).geometry();
  var lagoonsmask = ee.Image().byte().paint(ee.Feature(lagoons_mask.dissolve(),{zone: 1}), "zone").clip(lagoons_mask.dissolve());

  
  // RC within Lagoon ORF
man_geo = man_geo.where({
test: lagoonsmask.eq(1)
             .and(man_geo.eq(15)),
  value: ee.Image(14)
});
// Reef slope, sheltered slope (within lagoon mask) -> Back Reef Slope
 man_geo = man_geo.where({
  test: lagoonsmask.eq(1)
                    .and(man_geo.eq(21).or(man_geo.eq(22))),
    value: ee.Image(24)
 });    
  
  
  //*********************START CREATING and APPLYING REEF OUTINE BUFFER FROM  reef (lagoon) mask Chris SCS**************START
  // in map viewer manual digitised reef top areas with lagoon in it. Tried to use CNN layer but to many artefacts and manual took 3 hr
  // creatimg a buffer around lagoon_mask

  var lagoon_buffered = lagoons_mask.buffer(1000); // buffer 1000 m wide around reef mask
  var reef_band_mask = lagoon_buffered.difference(lagoons_mask);//substract buffered lagoon mask - lagoon mask resulting in band around reef of 1000 m
  var reefbandmask = ee.Image().byte().paint(ee.Feature(reef_band_mask.dissolve(),{zone: 1}), "zone").clip(reef_band_mask.dissolve()); // paint it as image

  // BRS, DL and SL should not be present on outside of reef on within reefbandmask  -> Reef Slope
  man_geo = man_geo.where({
   test: reefbandmask.eq(1)
                      .and(man_geo.eq(24).or(man_geo.eq(12)).or(man_geo.eq(11))),
    value: ee.Image(22)
 });    
  // IRF on within reefbandmask  -> ORF as RC would get artefacts
   man_geo = man_geo.where({
  test: reefbandmask.eq(1)
                    .and(man_geo.eq(13)),
    value: ee.Image(14)
  });   
 
 //3
 

//4 ORFto BRS
var ORFBRS = ee.Image().byte().paint(ee.Feature(ORFtoBRS, {zone: 1}), "zone").clip(ORFtoBRS);
  
  man_geo = man_geo.where({
    test:  ORFBRS.eq(1)
                .and(man_geo.eq(14)), //ORF
    value: ee.Image(24)//BRS
  });
  
//5 any x to deep water

      var XtoDW = ee.Image().byte().paint(ee.Feature(xtoDw, {zone: 1}), "zone").clip(xtoDw)
 print (XtoDW)
 
man_geo = man_geo.where({
    test: XtoDW.eq(1)
            ,
    value: ee.Image(2)
  });
  
  // 6 Small Islands with no crest, only flat and slope
  
      var IslandsNc = ee.Image().byte().paint(ee.Feature(ISLANDSNC, {zone: 1}), "zone").clip(ISLANDSNC)
 print (IslandsNc)
  
  // BRS24, SRS21 to RS22
   man_geo = man_geo.where({
  test: IslandsNc.eq(1)
                    .and(man_geo.eq(24).or(man_geo.eq(13)).or(man_geo.eq(21))), 
    value: ee.Image(22)
 });    
 
 // RC15 to ORF14
  man_geo = man_geo.where({
  test: IslandsNc.eq(1)
                    .and(man_geo.eq(15).or(man_geo.eq(21))), 
    value: ee.Image(14)
 });   
  
  //6
  
  //7 RC TO IRF
  var RCTOIRF = ee.Image().byte().paint(ee.Feature(RCtoIRF, {zone: 1}), "zone").clip(RCtoIRF);
  
  man_geo = man_geo.where({
    test:  RCTOIRF.eq(1)
                .and(man_geo.eq(15)), //
    value: ee.Image(13)//
  });
  
  
  //7
  
  //8 RC TO ORF
   var RCTOORF = ee.Image().byte().paint(ee.Feature(RCtoORF, {zone: 1}), "zone").clip(RCtoORF);
  
  man_geo = man_geo.where({
    test:  RCTOORF.eq(1)
                .and(man_geo.eq(15)), //
    value: ee.Image(14)//
  });
  
  //8
  
  //9 BAY Cleanup RS & BRS to SRS
  
       var ToSRS = ee.Image().byte().paint(ee.Feature(SHELSLOPE, {zone: 1}), "zone").clip(SHELSLOPE)
       print (ToSRS)
       
        man_geo = man_geo.where({
           test: ToSRS.eq(1)
                    .and(man_geo.eq(22).or(man_geo.eq(24))), 
    value: ee.Image(21)
 }); 
  
  
  //9 Remove ORF where TRF is dominant 119.59873, 23.58594
  
  //10
  
     var BRSDLtORS = ee.Image().byte().paint(ee.Feature(BRSDLTORS, {zone: 1}), "zone").clip(BRSDLTORS)
       print (BRSDLtORS)
       
        man_geo = man_geo.where({
           test: BRSDLtORS.eq(1)
                    .and(man_geo.eq(24).or(man_geo.eq(12))), 
    value: ee.Image(22)
 }); 
  
  //10
  
  // DL to BRS
var DLtOBRS = ee.Image().byte().paint(ee.Feature(DLTOBRS, {zone: 1}), "zone").clip(DLTOBRS);
  
  man_geo = man_geo.where({
    test:  DLtOBRS.eq(1)
                .and(man_geo.eq(12)), //DL
    value: ee.Image(22)//BRS
  });
// ORFto BRS3
  //10
  
  //11 BRS To RS
  
  var BRStORS = ee.Image().byte().paint(ee.Feature(BRSTORS, {zone: 1}), "zone").clip(BRSTORS);
  
  man_geo = man_geo.where({
    test:  BRStORS.eq(1)
                .and(man_geo.eq(24)), //DL
    value: ee.Image(22)//BRS
  });
  
  //11
  
  //12 TRF TO ORF
  
   var TRFtOORF = ee.Image().byte().paint(ee.Feature(TRFTOORF, {zone: 1}), "zone").clip(TRFTOORF);
  
  man_geo = man_geo.where({
    test:  TRFtOORF.eq(1)
                .and(man_geo.eq(16)), //DL
    value: ee.Image(14)//BRS
  });
  
  //12

//13 TRF TO IRF

   var TRFtOIRF = ee.Image().byte().paint(ee.Feature(TRFTOIRF, {zone: 1}), "zone").clip(TRFTOIRF);
  
  man_geo = man_geo.where({
    test:  TRFtOIRF.eq(1)
                .and(man_geo.eq(16)), //DL
    value: ee.Image(13)//BRS
  });

//13

//14 RSLOPE BRS & SRS To RS

  var toRSLOPE = ee.Image().byte().paint(ee.Feature(RSLOPE, {zone: 1}), "zone").clip(RSLOPE);
  
  man_geo = man_geo.where({
    test:  toRSLOPE.eq(1)
                .and(man_geo.eq(24).or(man_geo.eq(21))), 
    value: ee.Image(22)//BRS
  });


//14

//15 SL TO BRS

  var SLTtOBRS = ee.Image().byte().paint(ee.Feature(SLTOBRS, {zone: 1}), "zone").clip(SLTOBRS);
  
  man_geo = man_geo.where({
    test:  SLTtOBRS.eq(1)
                .and(man_geo.eq(11)), 
    value: ee.Image(24)//BRS
  });

//15

//16 SL TO RS

 var SLtORS = ee.Image().byte().paint(ee.Feature(SLTORS, {zone: 1}), "zone").clip(SLTORS);
  
  man_geo = man_geo.where({
    test:  SLtORS.eq(1)
                .and(man_geo.eq(11)), 
    value: ee.Image(22)//BRS
  });

//16

//17 RC to SLOPE

 var RCtOSLOPE = ee.Image().byte().paint(ee.Feature(RCTOSLOPE, {zone: 1}), "zone").clip(RCTOSLOPE);
  
  man_geo = man_geo.where({
    test:  RCtOSLOPE.eq(1)
                .and(man_geo.eq(15)), 
    value: ee.Image(22)//BRS
  });

//17

//18 RC TO TRF

 var RCtOTRF = ee.Image().byte().paint(ee.Feature(RCTOTRF, {zone: 1}), "zone").clip(RCTOTRF);
  
  man_geo = man_geo.where({
    test:  RCtOTRF.eq(1)
                .and(man_geo.eq(15)), 
    value: ee.Image(22)//BRS
  });

//18

*/



/*
var MidMask = ee.Image().byte().paint(ee.Feature(mid_mask, {zone: 1}), "zone").clip(mid_mask);
  
  man_geo = man_geo.where({
    test:  MidMask.eq(1),
    value: ee.Image(0)
  });
  
 // TRF to IRF
var TRFIRF = ee.Image().byte().paint(ee.Feature(TRFtoIRF, {zone: 1}), "zone").clip(TRFtoIRF);
  
  man_geo = man_geo.where({
    test:  TRFIRF.eq(1)
                .and(man_geo.eq(16)), //TRF
    value: ee.Image(13)//IRF
  });

// ORF to Deep
var ORFDeep = ee.Image().byte().paint(ee.Feature(ORFtoDeep, {zone: 1}), "zone").clip(ORFtoDeep);
  
  man_geo = man_geo.where({
    test:  ORFDeep.eq(1)
                .and(man_geo.eq(14)), //ORF
    value: ee.Image(2)//Deep
  });

// ORFto BRS
var ORFBRS = ee.Image().byte().paint(ee.Feature(ORFtoBRS, {zone: 1}), "zone").clip(ORFtoBRS);
  
  man_geo = man_geo.where({
    test:  ORFBRS.eq(1)
                .and(man_geo.eq(14)), //ORF
    value: ee.Image(24)//BRS
  });

// ORF to RS
var ORFRS = ee.Image().byte().paint(ee.Feature(ORFtoRS, {zone: 1}), "zone").clip(ORFtoRS);
  
  man_geo = man_geo.where({
    test:  ORFRS.eq(1)
                .and(man_geo.eq(14)), //ORF
    value: ee.Image(22)//RS
  });

// DL to BRS
var DLBRS = ee.Image().byte().paint(ee.Feature(DLtoBRS, {zone: 1}), "zone").clip(DLtoBRS);
  
  man_geo = man_geo.where({
    test:  DLBRS.eq(1)
                .and(man_geo.eq(12)), //DL
    value: ee.Image(24)//BRS
  });
// ORFto BRS3
var ORFBRS3 = ee.Image().byte().paint(ee.Feature(ORFtoBRS3, {zone: 1}), "zone").clip(ORFtoBRS3);
  
  man_geo = man_geo.where({
    test:  ORFBRS3.eq(1)
                .and(man_geo.eq(14)), //ORF
    value: ee.Image(24)//BRS
  });
  
  // ORFto RS3
var ORFRS3 = ee.Image().byte().paint(ee.Feature(ORFtoRS3, {zone: 1}), "zone").clip(ORFtoRS3);
  
  man_geo = man_geo.where({
    test:  ORFRS3.eq(1)
                .and(man_geo.eq(14)), //ORF
    value: ee.Image(22)//RS
  });

// RS to BRS2
var RSBRS2 = ee.Image().byte().paint(ee.Feature(RStoBRS2, {zone: 1}), "zone").clip(RStoBRS2);
  
  man_geo = man_geo.where({
    test:  RSBRS2.eq(1)
                .and(man_geo.eq(22)), //RS
    value: ee.Image(24)//BRS
  });
 
// SL to BRS2
var SLBRS2 = ee.Image().byte().paint(ee.Feature(SLtoBRS2, {zone: 1}), "zone").clip(SLtoBRS2);
  
  man_geo = man_geo.where({
    test:  SLBRS2.eq(1)
                .and(man_geo.eq(11)), //SL
    value: ee.Image(24)//BRS
  });
   
  
// BRS to RS
var BRSRS2 = ee.Image().byte().paint(ee.Feature(BRStoRS2, {zone: 1}), "zone").clip(BRStoRS2);
  
  man_geo = man_geo.where({
    test:  BRSRS2.eq(1)
                .and(man_geo.eq(24)), //BRS
    value: ee.Image(22)//RS
  });
*/

/*
// Mask out phantom reefs
var mask4 = ee.Image().byte().paint(ee.Feature(Mask4, {zone: 1}), "zone").clip(Mask4);
    man_geo = man_geo.where({
      test: mask4.eq(1),
      value: ee.Image(0)
    });
    
// More ORF to BRS
var orfTobrs = ee.Image().byte().paint(ee.Feature(ORFtoBRS4, {zone: 1}), "zone").clip(ORFtoBRS4);
  
  man_geo = man_geo.where({
    test:  orfTobrs.eq(1)
                .and(man_geo.eq(14)), //ORF
    value: ee.Image(24)//BRS
  });

// More ORF to RS
var orfTors = ee.Image().byte().paint(ee.Feature(ORFtoRS4, {zone: 1}), "zone").clip(ORFtoRS4);
  
  man_geo = man_geo.where({
    test:  orfTors.eq(1)
                .and(man_geo.eq(14)), //ORF
    value: ee.Image(22)//RS
  });

  // Cleanup phantom reefs
var crap = ee.Image().byte().paint(ee.Feature(garbage, {zone: 1}), "zone").clip(garbage);
  
  man_geo = man_geo.where({
    test:  crap.eq(1),
    value: ee.Image(0)
  });
  */
  
  
/*    
  // the "REEF MASK" CLEAN
  
  // Define a kernel for reef mask Morphological Operations
  var kernel_rm = ee.Kernel.circle({radius: vars.smooth_radius.multiply(5)});

  // Create reef mask to clean areas inside the reef - Perform an dilation of deepwater
  var reef_mask = man_geo.eq(2)
            .focal_max({kernel: kernel_rm, iterations: 2});

  // Inner Reef Flat (outside reef mask) -> outer reef flat
  man_geo = man_geo.where({
    test: reef_mask.eq(1)
                    .and(man_geo.eq(13)),
    value: ee.Image(14)
  });
  
  // Reef crest, slope, sheltered slope (within reef mask) -> outer reef flat
  man_geo = man_geo.where({
    test: reef_mask.eq(0)
                    .and(man_geo.eq(15).or(man_geo.eq(21)).or(man_geo.eq(22))),
    value: ee.Image(14)
  });
  
*/
  /*
  // WAVE clean (un-comment this sectio nbased on whether you have waves or not)
  
  var waves = ee.Image(region_params.waves)
  Map.addLayer(waves.lt(vars.wave_height), {}, vars.wave_height + "m Hs95 threshold", false)
  
  man_geo = man_geo.where({
    test: waves.lte(vars.wave_height)
               .and(man_geo.eq(22)),
    value: ee.Image(21)
  })*/
  

  
  
  /*
  ##############
  
  The rest of the manual geometry paintings and rules should go here
      - make the geom, paint the layer, use it in a rule
      - consult previous regions *_cleanup script for ideas/hints/existing rules etc.
  e.g. 
  var notreefcrest = ee.Image().byte().paint(ee.Feature(not_reef_crest, {zone: 1}), "zone").clip(not_reef_crest);
  var notdeepwater = ee.Image().byte().paint(ee.Feature(not_deep_water, {zone: 1}), "zone").clip(not_deep_water);
  
  
  // Reef crest -> Inner reef flat (inside the reef)
  man_geo = man_geo.where({
    test: notreefcrest.eq(1)
                     .and(man_geo.eq(15)),
    value: ee.Image(13)
  });
  
  // Deep water -> Deep lagoon (inside the reef)
  man_geo = man_geo.where({
    test: notdeepwater.eq(1)
                     .and(man_geo.eq(2)),
    value: ee.Image(12)
  });
  
  ##############
  */
  
  if (vars.geo_refinement) {
    // make the mask image layer
    var refine = ee.Image().byte().paint(ee.Feature(refinement_mask, {zone: 1}), "zone").clip(refinement_mask);
    // apply
    man_geo = man_geo.where({
      test: refine.eq(1),
      value: ee.Image(0)
    });
  }
  
  man_geo = man_geo.updateMask(man_geo.gt(2)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  
  // Add data + the manual layer to the map
  var lowtide_image = ee.Image(region_params.image);
  Map.addLayer(lowtide_image, {bands: ['b3','b2','b1'], min:0, max:2000, gamma:1.5}, sensor_params.sname + ' low tide', false);
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(geo_clean2, map_palettes.geo, 'Geo clean stage 2', false);
//  Map.addLayer(man_geo.updateMask(man_geo), map_palettes.geo, 'Geo clean stage 3', false);
//Map.addLayer(mid_mask, {color: 'red'}, "mid mask import", false, 0.4);// CR added
//Map.addLayer(lagoons_mask, {color: 'blue'}, "lagoons mask import", true, 0.4);// CR added*/
//Map.addLayer(turbiddeepmask, {color: 'green'}, "turbiddeep import", false, 0.4);// CR added
//Map.addLayer(reef_band_mask, {}, "band(buffer) around lagoon");// CR added*/
//Map.addLayer(ORFtoRS_mask, {}, "ORF_IRF_RCToRS");// CR added*/
var GCRMNext=ee.Image([param_module.global_extent_mask.gcrmn])
Map.addLayer(GCRMNext, {}, "GCRMNextmask", false);// CR added GCRMN_ext

 Map.addLayer(man_geo.updateMask(man_geo.gt(2)), map_palettes.geo, 'Geo clean stage 3 - no DW', false);
 //Map.addLayer(mask4, map_palettes.geo, 'mask 4', false);
 //Map.addLayer(GCRSmask1, map_palettes.geo, 'GCRSmask1', false);
// Map.addLayer(GCRSmask2, map_palettes.geo, 'GCRSmask2', false);
 Map.addLayer(wcmc, map_palettes.geo, 'wcmc', false);
  //Map.addLayer(global_reef_mask.updateMask(global_reef_mask.eq(1)), {palette: ['F8FF23'], opacity: 0.4}, 'global_reef_mask - land', false);
  // Map.addLayer(global_reef_mask.updateMask(global_reef_mask.eq(3)), {palette: ['0000ff'], opacity: 0.4}, 'global_reef_mask - reef', false);
  //Map.addLayer(global_reef_mask.updateMask(global_reef_mask.eq(2)), {palette: ['FF0000'], opacity: 0.4}, 'global_reef_mask - water', false);

  
  
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_geo,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: region_extent,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
} 

if (vars.manual_clean && !vars.geomorphic) {
  
  print("Doing BENTHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.segments).select('depth');
  
  // define the final geomorphic map (the manually edited geo map - stage 3)
  var geo_map = ee.Image(region_params.geo_map_clean3);
  
  // define the clean benthic map to apply 2nd stage rules to
  var man_benthic = ee.Image(region_params.benthic_map_clean1);
  
  // extra depth cutoff refinement
  man_benthic = man_benthic.where({
          test: depth.gt(vars.benthic_depth_cutoff),
          value: ee.Image(0)
        });
  
  /*
  **Generic benthic rules**
    - should be generally applicable, but still review
  */
  
//NEA/TAJ rules


  //
  
  /*
  // BMA on inner RF, outer RF,reef crest, reef slope -> rubble 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(18)
                     .and(geo_map.eq(13).or(geo_map.eq(14)).or(geo_map.eq(15)).or(geo_map.eq(22))),
    value: ee.Image(12)
  });
  
  // Rubble on Reef crest -> rock 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(12)
                     .and(geo_map.eq(15)), //(geo_map.eq(14).or
    value: ee.Image(13)
  });
     // Coral/Algae and Seagrass on Deep Lagoon -> Sand
  man_benthic = man_benthic.where({
    test: man_benthic.eq(15)
                     .and(geo_map.eq(12)),
    value: ee.Image(11)
  });
  man_benthic = man_benthic.where({
    test: man_benthic.eq(14)
                     .and(geo_map.eq(12)),
    value: ee.Image(11)
  });
  man_benthic = man_benthic.where({
    test: man_benthic.eq(13)
                     .and((geo_map.eq(12)).or(geo_map.eq(11))),
    value: ee.Image(11)
  });
  // Seagrass on Reef Crest or Outer Reef Flat or reef slope or sheltered slope change to coral/algae or rock -> coral algae
  // Seagrass in generaly does not grow on hard substrate areas.
  
  man_benthic = man_benthic.where({
    test: man_benthic.eq(14)
                     .and(geo_map.eq(15)),
    value: ee.Image(15)
  });  
   // Seagrass on reef slope or sheltered slope change to rock -> rock
  // Seagrass in generaly does not grow on hard substrate areas.
  
  man_benthic = man_benthic.where({
    test: man_benthic.eq(14)
                     .and(geo_map.eq(21).or(geo_map.eq(22))),
    value: ee.Image(13)
  }); 
  // Sand on Reef crest ->  ROCK
  // Sand in generally cannot stay in high energy zone so has to be hard substrate posisble Rock
  man_benthic = man_benthic.where({
    test: man_benthic.eq(11)
                     .and(geo_map.eq(15)),
    value: ee.Image(13)
  });  
  // Sand on Reef slope or sheltered slope -> Rubble CR ADDED
  man_benthic = man_benthic.where({
    test: man_benthic.eq(11)
                     .and((geo_map.eq(21)).or(geo_map.eq(22))),
    value: ee.Image(12)
  });  
  */
  
  
  /*
  
    **Manual polygon guided rules**
   - same as per geomorphic clean section
   - add a geometry, paint the layer, create a rule
   */
   
   //NEA-TAJ
  
  
  //Benthic clean 2 post feedback manual edits 17 SEP 2021
  
  //pf1_1
   var XtOMASK = ee.Image().byte().paint(ee.Feature(XTOMASK, {zone: 1}), "zone").clip(XTOMASK)// X to ignore
 
 
man_benthic = man_benthic.where({
    test: XtOMASK.eq(1)
            ,
    value: ee.Image(0)
  });
        
 //pf1_2

  var RUtOCA = ee.Image().byte().paint(ee.Feature(RUTOCA, {zone: 1}), "zone").clip(RUTOCA);
   man_benthic = man_benthic.where({
    test: RUtOCA.eq(1) 
                     .and(man_benthic.eq(12)),//C/A
    value: ee.Image(15)//
  }); 
        
  //pf1_3
    var RUtOROCK = ee.Image().byte().paint(ee.Feature(RUTOROCK, {zone: 1}), "zone").clip(RUTOROCK);
   man_benthic = man_benthic.where({
    test: RUtOROCK.eq(1) 
                     .and(man_benthic.eq(12)),//C/A
    value: ee.Image(13)//
  }); 
  
   //pf1_4 
   var SGtOCA = ee.Image().byte().paint(ee.Feature(SGTOCA, {zone: 1}), "zone").clip(SGTOCA);
   man_benthic = man_benthic.where({
    test: SGtOCA.eq(1) 
                     .and(man_benthic.eq(14)),//C/A
    value: ee.Image(15)//
  }); 
  
  //pf1_5
   var SGtOROCK = ee.Image().byte().paint(ee.Feature(SGTOROCK, {zone: 1}), "zone").clip(SGTOROCK);
   man_benthic = man_benthic.where({
    test: SGtOROCK.eq(1) 
                     .and(man_benthic.eq(14)),
    value: ee.Image(13)//
  }); 
  
   //pf1_6
    var CAtOSG = ee.Image().byte().paint(ee.Feature(CATOSG, {zone: 1}), "zone").clip(CATOSG);
   man_benthic = man_benthic.where({
    test: CAtOSG.eq(1) 
                     .and(man_benthic.eq(15)),//
    value: ee.Image(14)//
  }); 
  
  //pf1_7 
    var SAtOSG = ee.Image().byte().paint(ee.Feature(SATOSG, {zone: 1}), "zone").clip(SATOSG);
   man_benthic = man_benthic.where({
    test: SAtOSG.eq(1) 
                     .and(man_benthic.eq(11)),//
    value: ee.Image(14)//
  }); 
  
  //pf1_8
    var ROtOSG = ee.Image().byte().paint(ee.Feature(ROTOSG, {zone: 1}), "zone").clip(ROTOSG);
   man_benthic = man_benthic.where({
    test: ROtOSG.eq(1) 
                     .and(man_benthic.eq(13)),//
    value: ee.Image(14)//
  }); 
  
   //pf1_8
      var SGtORU = ee.Image().byte().paint(ee.Feature(SGTORU, {zone: 1}), "zone").clip(SGTORU);
   man_benthic = man_benthic.where({
    test: SGtORU.eq(1) 
                     .and(man_benthic.eq(14)),
    value: ee.Image(12)//
  }); 
   
  
  /*
  // Sand to rock
  
  //v2_1
  
    var SAND_ORFtOROCK = ee.Image().byte().paint(ee.Feature(SAND_ORFTOROCK, {zone: 1}), "zone").clip(SAND_ORFTOROCK);

man_benthic = man_benthic.where({
    test: SAND_ORFtOROCK.eq(1)
                     .and(man_benthic.eq(11).and(geo_map.eq(14))),
    value: ee.Image(13)
  }); 
  
  //v2_1
  
  //v2_2
  
    var SAND_RCtOROCK = ee.Image().byte().paint(ee.Feature(SAND_RCTOROCK, {zone: 1}), "zone").clip(SAND_RCTOROCK);

man_benthic = man_benthic.where({
    test: SAND_RCtOROCK.eq(1)
                     .and(man_benthic.eq(11).and(geo_map.eq(15))),
    value: ee.Image(13)
  }); 
  
  //v2_2
  
  //v2_3
   var SANDtOROCK = ee.Image().byte().paint(ee.Feature(SANDTOROCK, {zone: 1}), "zone").clip(SANDTOROCK);
   man_benthic = man_benthic.where({
    test: SANDtOROCK.eq(1) 
                     .and(man_benthic.eq(11)),//C/A
    value: ee.Image(13)//Sand
  }); 
  
  //v2_3
  
   //v2_4
   
    var SG_ORFtOCA = ee.Image().byte().paint(ee.Feature(SG_ORFTOCA, {zone: 1}), "zone").clip(SG_ORFTOCA);

man_benthic = man_benthic.where({
    test: SG_ORFtOCA.eq(1)
                     .and(man_benthic.eq(14).and(geo_map.eq(14))),
    value: ee.Image(15)
  }); 
  
   //v2_4
  
  //v2_5
  
  var SGtOCA = ee.Image().byte().paint(ee.Feature(SGTOCA, {zone: 1}), "zone").clip(SGTOCA);
   man_benthic = man_benthic.where({
    test: SGtOCA.eq(1) 
                     .and(man_benthic.eq(14)),//C/A
    value: ee.Image(15)//Sand
  }); 
  
  //v2_5
  
  //v2_6
   var RUBBLEtOROCK = ee.Image().byte().paint(ee.Feature(RUBBLETOROCK, {zone: 1}), "zone").clip(RUBBLETOROCK);
   man_benthic = man_benthic.where({
    test: RUBBLEtOROCK.eq(1) 
                     .and(man_benthic.eq(12)),//C/A
    value: ee.Image(13)//Sand
  }); 
  //v2_6
  
  //v2_7
    var ROCKtOSAND = ee.Image().byte().paint(ee.Feature(ROCKTOSAND, {zone: 1}), "zone").clip(ROCKTOSAND);
   man_benthic = man_benthic.where({
    test: ROCKtOSAND.eq(1) 
                     .and(man_benthic.eq(13)),//C/A
    value: ee.Image(11)//Sand
  }); 
  //v2_7
  
    //v2_8
    
        var ROCK_TRFtOSAND = ee.Image().byte().paint(ee.Feature(ROCK_TRFTOSAND, {zone: 1}), "zone").clip(ROCK_TRFTOSAND);

man_benthic = man_benthic.where({
    test: ROCK_TRFtOSAND.eq(1)
                     .and(man_benthic.eq(13).and(geo_map.eq(16))),
    value: ee.Image(11)
}); 
    //v2_8
    
      //v2_9
      
     var RUBBLEtOSAND = ee.Image().byte().paint(ee.Feature(RUBBLETOSAND, {zone: 1}), "zone").clip(RUBBLETOSAND);
   man_benthic = man_benthic.where({
    test: RUBBLEtOSAND.eq(1) 
                     .and(man_benthic.eq(12)),//C/A
    value: ee.Image(11)//Sand
  }); 
  
    //v2_9
    
  //v2_10
       
  var XtOSAND = ee.Image().byte().paint(ee.Feature(XTOSAND, {zone: 1}), "zone").clip(XTOSAND)

 
man_benthic = man_benthic.where({
    test: XtOSAND.eq(1)
            ,
    value: ee.Image(11)
  });
       
  //v2_10
  
  //v2_11
    var CAtOMASK = ee.Image().byte().paint(ee.Feature(CATOMASK, {zone: 1}), "zone").clip(CATOMASK);
   man_benthic = man_benthic.where({
    test: CAtOMASK.eq(1) 
                     .and(man_benthic.eq(15)),//C/A
    value: ee.Image(0)//Sand
  }); 
  //v2_11
  
    //v2_12
  var SAND_ORFtOCA = ee.Image().byte().paint(ee.Feature(SAND_ORFTOCA, {zone: 1}), "zone").clip(SAND_ORFTOCA);

man_benthic = man_benthic.where({
    test: SAND_ORFtOCA.eq(1)
                     .and(man_benthic.eq(11).and(geo_map.eq(14))),
    value: ee.Image(15)
  }); 
    //v2_12
    
        //v2_13
      var RUBBLE_ORFtOROCK = ee.Image().byte().paint(ee.Feature(RUBBLE_ORFTOROCK, {zone: 1}), "zone").clip(RUBBLE_ORFTOROCK);

man_benthic = man_benthic.where({
    test: RUBBLE_ORFtOROCK.eq(1)
                     .and(man_benthic.eq(12).and(geo_map.eq(14))),
    value: ee.Image(13)
  }); 
        //v2_13
        
         //v2_14
         
   var XtOMASK = ee.Image().byte().paint(ee.Feature(XTOMASK, {zone: 1}), "zone").clip(XTOMASK)// X to ignore
 
 
man_benthic = man_benthic.where({
    test: XtOMASK.eq(1)
            ,
    value: ee.Image(0)
  });
         
          //v2_14
          
    //v2_15 
   var SANDtOCA = ee.Image().byte().paint(ee.Feature(SANDTOCA, {zone: 1}), "zone").clip(SANDTOCA);
   man_benthic = man_benthic.where({
    test: SANDtOCA.eq(1) 
                     .and(man_benthic.eq(11)),//C/A
    value: ee.Image(15)//Sand
  }); 
  //v2_15 
  
//v2_16
    
   var CAtOSG = ee.Image().byte().paint(ee.Feature(CATOSG, {zone: 1}), "zone").clip(CATOSG);
   man_benthic = man_benthic.where({
    test: CAtOSG.eq(1) 
                     .and(man_benthic.eq(15)),//C/A
    value: ee.Image(14)//Sand
  }); 
    
//v2_16
  
  //v2_17
  /*
    var ROCKtOSG = ee.Image().byte().paint(ee.Feature(ROCKTOSG, {zone: 1}), "zone").clip(ROCKTOSG);
   man_benthic = man_benthic.where({
    test: ROCKtOSG.eq(1) 
                     .and(man_benthic.eq(13)),//C/A
    value: ee.Image(14)//Sand
  }); 
  */
  //v2_17
  
    //v2_18
    /*
  var ROCK_ORFtOSAND = ee.Image().byte().paint(ee.Feature(ROCK_ORFTOSAND, {zone: 1}), "zone").clip(ROCK_ORFTOSAND);

man_benthic = man_benthic.where({
    test: ROCK_ORFtOSAND.eq(1)
                     .and(man_benthic.eq(13).and(geo_map.eq(14))),
    value: ee.Image(11)
}); 
*/
  //v2_18
  
  
  
  
  
  //v1_1
  /*
var SANDtOROCK = ee.Image().byte().paint(ee.Feature(SANDTOROCK, {zone: 1}), "zone").clip(SANDTOROCK);
   man_benthic = man_benthic.where({
    test: SANDtOROCK.eq(1) 
                     .and(man_benthic.eq(11)),//C/A
    value: ee.Image(13)//Sand
  }); 
  
  //v1_1
  
  //v1_2
  
  var SGtOCA = ee.Image().byte().paint(ee.Feature(SGTOCA, {zone: 1}), "zone").clip(SGTOCA);
   man_benthic = man_benthic.where({
    test: SGtOCA.eq(1) 
                     .and(man_benthic.eq(14)),//C/A
    value: ee.Image(15)//Sand
  }); 
  
  //v1_2
  
  //v1_3
  
  var SANDtORUBBLE = ee.Image().byte().paint(ee.Feature(SANDTORUBBLE, {zone: 1}), "zone").clip(SANDTORUBBLE);
   man_benthic = man_benthic.where({
    test: SANDtORUBBLE.eq(1) 
                     .and(man_benthic.eq(11)),//C/A
    value: ee.Image(12)//Sand
  }); 
  
  //v1_3
  
  //v1_4
  
   var SANDtOCA = ee.Image().byte().paint(ee.Feature(SANDTOCA, {zone: 1}), "zone").clip(SANDTOCA);
   man_benthic = man_benthic.where({
    test: SANDtOCA.eq(1) 
                     .and(man_benthic.eq(11)),//C/A
    value: ee.Image(15)//Sand
  }); 
  
   //v1_4
   
    //v1_5
    
      var RUBBLEtOCA = ee.Image().byte().paint(ee.Feature(RUBBLETOCA, {zone: 1}), "zone").clip(RUBBLETOCA);
   man_benthic = man_benthic.where({
    test: RUBBLEtOCA.eq(1) 
                     .and(man_benthic.eq(12)),//C/A
    value: ee.Image(15)//Sand
  }); 
    
         //v1_5
    
     //v1_6
    
   var MaSK = ee.Image().byte().paint(ee.Feature(MASK, {zone: 1}), "zone").clip(MASK);
   man_benthic = man_benthic.where({
    test: MaSK.eq(1), 
                     
    value: ee.Image(0)//Ignore
  }); 
  
   //v1_6
   
  //v1_7
      
     var SANDtOMASK = ee.Image().byte().paint(ee.Feature(SANDTOMASK, {zone: 1}), "zone").clip(SANDTOMASK);
   man_benthic = man_benthic.where({
    test: SANDtOMASK.eq(1) 
                     .and(man_benthic.eq(11)),//C/A
    value: ee.Image(0)//Sand
  }); 
      
  //v1_7
   
    //v1_8
    
      var ROCKtOSAND = ee.Image().byte().paint(ee.Feature(ROCKTOSAND, {zone: 1}), "zone").clip(ROCKTOSAND);
   man_benthic = man_benthic.where({
    test: ROCKtOSAND.eq(1) 
                     .and(man_benthic.eq(13)),//C/A
    value: ee.Image(11)//Sand
  }); 
   
    //v1_8
    
    //v1_9
    
         var RUBBLEtOSAND = ee.Image().byte().paint(ee.Feature(RUBBLETOSAND, {zone: 1}), "zone").clip(RUBBLETOSAND);
   man_benthic = man_benthic.where({
    test: RUBBLEtOSAND.eq(1) 
                     .and(man_benthic.eq(12)),//C/A
    value: ee.Image(11)//Sand
  }); 
   
    
    //v1_9
    
  //v1_10
    
    var ROCKtORUBBLE = ee.Image().byte().paint(ee.Feature(ROCKTORUBBLE, {zone: 1}), "zone").clip(ROCKTORUBBLE);
   man_benthic = man_benthic.where({
    test: ROCKtORUBBLE.eq(1) 
                     .and(man_benthic.eq(13)),//C/A
    value: ee.Image(12)//Sand
  }); 
    
  //v1_10
  
   //v1_11
   
  // Seagrass on RS to CA
  
  var SG_RSLOPEtOCA = ee.Image().byte().paint(ee.Feature(SG_RSLOPETOCA, {zone: 1}), "zone").clip(SG_RSLOPETOCA);

man_benthic = man_benthic.where({
    test: SG_RSLOPEtOCA.eq(1)
                     .and(man_benthic.eq(14).and(geo_map.eq(22))),
    value: ee.Image(15)
  }); 
   
    //v1_11
    
    //v1_12
    
     var SG_SRSLOPEtOCA = ee.Image().byte().paint(ee.Feature(SG_SRSLOPETOCA, {zone: 1}), "zone").clip(SG_SRSLOPETOCA);

man_benthic = man_benthic.where({
    test: SG_SRSLOPEtOCA.eq(1)
                     .and(man_benthic.eq(14).and(geo_map.eq(21))),
    value: ee.Image(15)
  }); 
 
    
  //v1_12
     
  //v1_13
       
      var SAND_RStOCA = ee.Image().byte().paint(ee.Feature(SAND_RSTOCA, {zone: 1}), "zone").clip(SAND_RSTOCA);

man_benthic = man_benthic.where({
    test: SAND_RStOCA.eq(1)
                     .and(man_benthic.eq(11).and(geo_map.eq(22))),
    value: ee.Image(15)
  }); 
       
  //v1_13
  
  //v1_14
  
        var SAND_ORFtOCA = ee.Image().byte().paint(ee.Feature(SAND_ORFTOCA, {zone: 1}), "zone").clip(SAND_ORFTOCA);

man_benthic = man_benthic.where({
    test: SAND_ORFtOCA.eq(1)
                     .and(man_benthic.eq(11).and(geo_map.eq(14))),
    value: ee.Image(15)
  }); 
  
  //v1_14
    
    
  //v1_15
  
   var SAND_RCtOCA = ee.Image().byte().paint(ee.Feature(SAND_RCTOCA, {zone: 1}), "zone").clip(SAND_RCTOCA);

man_benthic = man_benthic.where({
    test: SAND_RCtOCA.eq(1)
                     .and(man_benthic.eq(11).and(geo_map.eq(15))),
    value: ee.Image(15)
  }); 
      
  //v1_15
  
   //v1_16
   
    var SGtOSAND = ee.Image().byte().paint(ee.Feature(SGTOSAND, {zone: 1}), "zone").clip(SGTOSAND);
   man_benthic = man_benthic.where({
    test: SGtOSAND.eq(1) 
                     .and(man_benthic.eq(14)),//C/A
    value: ee.Image(11)//Sand
  }); 
   
    //v1_16
    
     //v1_17
     
      var RUBBLEtOROCK = ee.Image().byte().paint(ee.Feature(RUBBLETOROCK, {zone: 1}), "zone").clip(RUBBLETOROCK);
   man_benthic = man_benthic.where({
    test: RUBBLEtOROCK.eq(1) 
                     .and(man_benthic.eq(12)),//C/A
    value: ee.Image(13)//Sand
  }); 
     
      //v1_17
      
      //v1_18
      
      
           var ROCKtOCA = ee.Image().byte().paint(ee.Feature(ROCKTOCA, {zone: 1}), "zone").clip(ROCKTOCA);
   man_benthic = man_benthic.where({
    test: ROCKtOCA.eq(1) 
                     .and(man_benthic.eq(13)),//C/A
    value: ee.Image(15)//Sand
  }); 
      
      //v1_18
      
  //v1_19
       
  var XtOSAND = ee.Image().byte().paint(ee.Feature(XTOSAND, {zone: 1}), "zone").clip(XTOSAND)

 
man_benthic = man_benthic.where({
    test: XtOSAND.eq(1)
            ,
    value: ee.Image(11)
  });
       
  //v1_19
  
    //v1_20
    
    
      var XtOCA = ee.Image().byte().paint(ee.Feature(XTOCA, {zone: 1}), "zone").clip(XTOCA)

 
man_benthic = man_benthic.where({
    test: XtOCA.eq(1)
            ,
    value: ee.Image(15)
  });
      
    
      //v1_20
      
      //v1_21
      
 var SG_ORFtOCA = ee.Image().byte().paint(ee.Feature(SG_ORFTOCA, {zone: 1}), "zone").clip(SG_ORFTOCA);

man_benthic = man_benthic.where({
    test: SG_ORFtOCA.eq(1)
                     .and(man_benthic.eq(14).and(geo_map.eq(14))),
    value: ee.Image(15)
  }); 
  
      //v1_21
      
         //v1_22
         
          var SG_RCtOCA = ee.Image().byte().paint(ee.Feature(SG_RCTOCA, {zone: 1}), "zone").clip(SG_RCTOCA);

man_benthic = man_benthic.where({
    test: SG_RCtOCA.eq(1)
                     .and(man_benthic.eq(14).and(geo_map.eq(15))),
    value: ee.Image(15)
  }); 
      
      
         //v1_22
  */
  
    //NEA-TAJ
  
  
  /*
  // cORAL/aLGAE TO sAND
  var CtoS = ee.Image().byte().paint(ee.Feature(CtoSD, {zone: 1}), "zone").clip(CtoSD);
   man_benthic = man_benthic.where({
    test: CtoS.eq(1) 
                     .and(man_benthic.eq(15)),//C/A
    value: ee.Image(11)//Sand
  }); 
  
// cORAL/aLGAE TO Ignore
  var CtoD = ee.Image().byte().paint(ee.Feature(CtoDeep, {zone: 1}), "zone").clip(CtoDeep);
   man_benthic = man_benthic.where({
    test: CtoD.eq(1) 
                     .and(man_benthic.eq(15)),//C/A
    value: ee.Image(0)//Ignore
  }); 
    
// All classes to Ignore
  var Deep = ee.Image().byte().paint(ee.Feature(deep, {zone: 1}), "zone").clip(deep);
   man_benthic = man_benthic.where({
    test: Deep.eq(1) 
                     .and(man_benthic.eq(15).or(man_benthic.eq(11).or(man_benthic.eq(14).or(man_benthic.eq(13).or(man_benthic.eq(12).or(man_benthic.eq(18))))))),
    value: ee.Image(0)//Ignore
  });   
  
     // Cleanup phantom reefs
  var crap = ee.Image().byte().paint(ee.Feature(garbage, {zone: 1}), "zone").clip(garbage);
  
  man_benthic = man_benthic.where({
    test:  crap.eq(1),
    value: ee.Image(0)
  });
  
  */
  
  // <---------- End manual NAS
  
  
  // final smooth for missing data due to depth
  man_benthic = man_benthic.focal_mode(2)
                           .selfMask()
  
 // man_benthic = man_benthic.updateMask(man_geo.gt(0)); // this ignores class 0
  // Add the manual layer to the map

  var dove_image = ee.Image(region_params.image);
  Map.addLayer(dove_image, {bands: ['b3','b2','b1'], min:0, max:4000, gamma:1.5}, sensor_params.sname + ' low tide', true);
  var benthic_clean1 = ee.Image(region_params.benthic_map_clean1);
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(GCRMN_ext, {}, "GCRMN_ext");// CR added GCRMN_ext
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false);
  Map.addLayer(geo_clean2.updateMask(geo_clean2.gt(2)), map_palettes.geo, 'Geo clean stage 2', false);
  Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Geo clean stage 3 - MANUAL', true);
  Map.addLayer(benthic_clean1, map_palettes.benthic, 'Benthic clean stage 1', false);
  Map.addLayer(man_benthic.reproject({crs:'EPSG:4326', scale: 5}), map_palettes.benthic, 'Benthic clean stage 2 - MANUAL', true);
 
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_benthic,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: region_extent,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
}

// #################################################################################################
// END OF MANUAL SECTION
// #################################################################################################


// 2. Data loads & vis

if (!vars.manual_clean) {

  // load input data
  
  // define raw geo/benthic outputs
  // Run check to see if the region has been split into multiple areas
  
  // geo
  if (ee.List(region_params.geo_map).length().getInfo() > 1) {
    var geo_map_raw = ee.Image(region_params.geo_map[0]).unmask(0, false)
                 .add(ee.Image(region_params.geo_map[1]).unmask(0,false))
                 .selfMask();
  } else {
    var geo_map_raw = ee.Image(region_params.geo_map);
  }
  
  // benthic
  if (ee.List(region_params.benthic_map).length().getInfo() > 1) {
      var benthic_map = ee.Image(region_params.benthic_map[0]).unmask(0, false)
               .add(ee.Image(region_params.benthic_map[1]).unmask(0,false))
               .selfMask();
  } else {
      var benthic_map = ee.Image(region_params.benthic_map);
  }
  
  // set the geo map for further processing
  if (vars.geomorphic && vars.obia_2nd_pass) {
    // if it's 2nd pass, you want to make sure you're loading the latest geo clean map
    var geo_map = ee.Image(region_params.geo_map_clean1);
  } else if (vars.geomorphic) {
    var geo_map = geo_map_raw;
  }
  
  var depth = ee.Image(region_params.pixels).select('depth');
  var low_tide_image = ee.Image(region_params.image);
  
  var display_pal = (vars.geomorphic) ? map_palettes.geo : map_palettes.benthic;
  Map.addLayer(depth, {min:0, max:2500}, 'Depth data', false);
  Map.addLayer(low_tide_image, {bands: ['b3','b2','b1'], min:0, max:3000}, sensor_params.sname + ' low tide', false);
  
  // load for display purposes
  if (vars.geomorphic) {
    Map.addLayer(geo_map_raw, display_pal, 'Geomorphic map RAW', false);
    if (vars.cleanup_stage == 2) Map.addLayer(ee.Image(region_params.geo_map_clean1), display_pal, 'Geo clean stage 1', false);
  }
  if (!vars.geomorphic) {
    // Use the manually cleaned geomorphic map as input for the benthic clean
    var geo_map = ee.Image(region_params.geo_map_clean3);
    Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Geo clean stage 3', false);
    Map.addLayer(benthic_map, display_pal, 'Benthic map RAW', false);
  }
  
  // 3. Object-based re-classificaiton and cleaning
  
  /* OUTPUT EXTENT
    - to the mapping extent just so it doesn't balloon out
    - to the 'reef boundary' extent for noise/deep removal
  */  
  var class_extent_mask = geo_map.gt(0);
  
  /*
  
  ########
  Initial small object clean
   - this was originally at the end, but we needed to massively reduce the number of objects to 
     iterate through in the OBIA cleaning, so this happens first now
   - future collabs with google might fix this, but need to change the parallel serialisation of vector procesing
   
   - includes a possible special case for:
        - geomorphic to clean up turbid areas over size threshold; fix shallow vs. deep lagoon
        - benthic to allow breaking waves (temporal class) to grow into surrounding class
  ########
  
  */
  
  // ##############################################################################################
  // START OF CLEAN 1
  // ##############################################################################################
  
  if (vars.geomorphic && !vars.obia_2nd_pass) {
    
    // shallow lagoon > 5m == deep lagoon
    geo_map = geo_map.where({
      test: geo_map.eq(11)
                    .and(depth.gt(vars.shallowlag_depth_cutoff)),
      value: ee.Image(12)
    });
    
    // deep water in depth data == deep (s2 + ls8 data should be good enough for this)
    geo_map = geo_map.where({
      test: depth.gt(vars.geo_depth_cutoff),
      value: ee.Image(2)
    });
   
    // make a smooth map with masked area as a value - *** Change to ee.kernal*** see reef mask in clean 3
    var smooth_map = geo_map
                        .focal_mode({
                          radius: vars.smooth_radius, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 2
                        });
    
    // replace small objects with smooth underneath
    var clean_map = geo_map.where({
      test: geo_map.connectedPixelCount(vars.small_object_geo, false).lt(vars.small_object_geo), 
      value: smooth_map
    }).updateMask(class_extent_mask);
    
    // display distance to land mask for assessing cut-off distances
    var distToLand = ee.Image(region_params.distToLand);
    
    Map.addLayer(distToLand.lte(vars.dist_to_land_RC), {}, 'RC to TRF ' + vars.dist_to_land_RC + 'm', false);
    Map.addLayer(distToLand.unmask(100000, false).lte(vars.dist_to_land_ORF), {}, 'TRF to ORF ' + vars.dist_to_land_ORF + 'm', false);

   // reef crest close to land -> TRF - Not need when using .focal masks (reef mask) as this will take care of RC inside the reef
    clean_map = clean_map.where({
    test: distToLand.lte(vars.dist_to_land_RC)
                     .and(clean_map.eq(15)),
       value: ee.Image(14)
     });
    
    // TRF outside of specified distance from land -> ORF
    clean_map = clean_map.where({
      test: distToLand.unmask(100000, false).gt(vars.dist_to_land_ORF)
                       .and(clean_map.eq(16)),
      value: ee.Image(14)
    });
  }
  
  if (!vars.geomorphic && vars.cleanup_stage == 1) {
   // TRF
    // make a smooth map with masked area as a value, and without temporal class (basically breaking waves)
    var smooth_map = benthic_map
                        .focal_mode({
                          radius: vars.smooth_radius, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 1
                        });
    
    //replace small objects with smooth underneath
    var clean_map = benthic_map.where({
      test: benthic_map.connectedPixelCount(vars.small_object_benthic, false).lt(vars.small_object_benthic),
      value: smooth_map
    }).updateMask(class_extent_mask);
    
  }
  
  // ##############################################################################################
  // START OF CLEAN 2
  // ##############################################################################################
  
  if (vars.geomorphic && vars.obia_2nd_pass) {
    var clean_map = geo_map;
  }
  
  if (vars.obia_clean) {
    
    if (vars.geomorphic && !vars.fast_clean) { 
      
      // FUNCTION that maps over feature colleciton and assigns neighbour percentages
      var set_neighbour_properties = function(f) {
        // make the 1px buffer
        var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5));
        // reduce the classes in the buffer zone
        var diff_classes = ee.Dictionary(
          clean_map.unmask(ee.Image(0)).reduceRegion({
            reducer: ee.Reducer.frequencyHistogram(),
            geometry: diff.geometry(),
            scale: vars.image_data_scale,
            maxPixels: 1e11
          }).get('classification')
        );
        // calculate the percentages
        var diff_sum = diff_classes.toArray().reduce(ee.Reducer.sum(), [0]).get([0]);
        var diff_percs = diff_classes.map(function(k,v){return(ee.Number(v).divide(diff_sum).multiply(100).toUint8())});
        
        /* NOW, we can try to do the class logic right here (see /users/mitchest/global_reefs/obia_dev),
           or we can return the neighbour % and do image logic via (painted) rasters */
        
        return(f.set(diff_percs));
      };
      
      // FUNCTION to reduce the map to vectors and map the neighbour properties function
      var reduce_neighbours = function() {
        // reduce map to vectors
        var map_fc = clean_map
              .updateMask(segment_id).updateMask(clean_map.eq(classn)) // only vectorise class/es of interest
              .reduceToVectors({
                scale: vars.image_data_scale, 
                eightConnected: false,
                bestEffort: true, 
                maxPixels: 1e13,
                tileScale: 1,
                geometry: region_extent
              });
        // map the function, calculate neighbour properties
        return(map_fc.map(set_neighbour_properties));
      };
      
      // first make a make size threshold, so we're not vecortising huge objects when we don't have to
      var segment_id = clean_map.connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels');
      //Map.addLayer(segment_id.reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))))
      Map.addLayer(clean_map.updateMask(segment_id).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
      
      // This is where we select the single or group of classes to vectorise for cleaning up
      //var classn = ee.Number(15) // one class
      var classn = clean_map.where({
        test: clean_map.neq(16) //TRF
                .and(clean_map.neq(15)) //RR
                .and(clean_map.neq(14)) //ORF
                .and(clean_map.neq(13)) //IRF
                //.and(clean_map.neq(12)) // deep L
                .and(clean_map.neq(11)), // shallow L 
        value: ee.Image(99) // 99 ensures it's ignored in logic
      });
      
      // Minimum size of object to reclass based on neighbourhood
      var max_size = ee.Number(1000).divide(vars.image_data_scale).pow(2); // the first number is the square dimension of the desired min size;
      // calculate neighbours
      var map_fc_neighbours = reduce_neighbours();
      
      // #########
      // REEF RIM
      // #########
      
      var focus_class = ee.Number(15); //RR
      
      // start the object-based neighbourhood rules
      // paint out to rasters (only paint the layers needed)
      var objsize = ee.Image(30000).paint(map_fc_neighbours, 'count').rename('count');
      //var nb24 = ee.Image().byte().paint(map_fc_neighbours, '24').unmask(0).rename('nb24') //OCL
      var nb22 = ee.Image().byte().paint(map_fc_neighbours, '22').unmask(0).rename('nb22'); //SL ex
      var nb21 = ee.Image().byte().paint(map_fc_neighbours, '21').unmask(0).rename('nb21'); //Sl sh
      var nb16 = ee.Image().byte().paint(map_fc_neighbours, '16').unmask(0).rename('nb16'); //TRF
      var nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15'); //RR
      var nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14'); //ORF
      var nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13'); //IRF
      //var nb3 = ee.Image().byte().paint(map_fc_neighbours, '3').unmask(0).rename('nb3') //Turbid
      
      // RR surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // RR surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // RR surrounded by IRF + ORF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.add(nb14).gt(75)),
        value: ee.Image(13)
      });
      
      // RR with decent border to TRF --> TRF (often dark, probably seagrass)
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(40)),
        value: ee.Image(16)
      });
      
      // RR surrounded by OCL --> OCL
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb24.gt(75)),
        value: ee.Image(24)
      })
      
      // small RR objects touching OCL + stuff --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(objsize.lte(max_size))
                .and(nb13.lte(75).and(nb14.lte(75))) // to ensure we're no re-writing previous rules
                .and(nb24.gt(1)),
        value: ee.Image(14)
      })
      
      // ####
      // ORF
      // ####
      
      focus_class = ee.Number(14); // ORF
      
      // ORF surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // ORF surrounded by TRF --> TRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(75)),
        value: ee.Image(16)
      });
      
      // ORF surrounded by RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb15.gt(85)),
        value: ee.Image(15)
      });
      
      // ORF touching slope and RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb21.gt(0).or(nb22.gt(0)))
                .and(nb15.gt(0)),
        value: ee.Image(15)
      });
      
      // ####
      // IRF
      // ####
      
      focus_class = ee.Number(13); // IRF
      
      // IRF surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // IRF surrounded by TRF --> TRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(75)),
        value: ee.Image(16)
      });
      
      // IRF surrounded by RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb15.gt(85)),
        value: ee.Image(15)
      });
      
      // ####
      // TRF
      // ####
      
      focus_class = ee.Number(16); // TRF
      
      // TRF surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // TRF surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // TRF surrounded by IRF + ORF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.add(nb14).gt(75)),
        value: ee.Image(13)
      });
      
      // ####
      // LAGOONS
      // ####
      
      var nb11 = ee.Image().byte().paint(map_fc_neighbours, '11').unmask(0).rename('nb11'); // shallow lag
      
      // SL sourrounded by DL --> DL
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                .and(nb12.gt(75)),
        value: ee.Image(12)
      })
      
      // DL sourrounded by SL --> SL
      clean_map = clean_map.where({
        test: clean_map.eq(12)
                .and(nb11.gt(75)),
        value: ee.Image(11)
      })
      
      // DL/SL surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(11).or(clean_map.eq(12))
                .and(objsize.lte(max_size))
                .and(nb13.gt(80)),
        value: ee.Image(13)
      })
      
      // SL surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                .and(objsize.lte(max_size))
                .and(nb13.gt(80)),
        value: ee.Image(13)
      });
      
    
    } else if (vars.geomorphic && vars.fast_clean) {
      print("Executing the fast version OBIA");
      
      /* fast version of the geo clean up
        - blanket version assigns the underlying most common in neighbourhood
        - mode OBIA version iterates through objects+buffers but take the mode instead of doing the class percs, to see if that speeds things up
      */
      
      
      // ## Blanket version
      
      // make a very smooth map to capture the broader neighbourhood  - *** Change to ee.kernal*** see reef mask in clean 3
      var smooth_map = clean_map
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                            kernelType: 'circle', units: 'pixels', iterations: 2
                          });
      
      // first make a make size threshold, so we're not vectorising huge objects when we don't have t
      // - the unmask(99) captures small no data values/ data gaps
      var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt().multiply(2)).select('labels').pow(2).log().int();
      Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
      
      // replace small objects with smooth underneath
      var clean_map = clean_map.unmask(0).where({
        test: segment_id.gt(0), 
        value: smooth_map
      }).selfMask();
      
      
      // ## mode OBIA version
      
      /* A possible faster plan
            - vectorise one/few class/es at a time, thus only spending resources on what is actually needed to clean up
            - BUT, just assign the mode of the neighbours, so save resouces even further??
      
      // FUNCTION that maps over feature colleciton and assigns neighbour percentages
      var set_neighbour_mode = function(f) {
        // make the 1px buffer
        var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5))
        // reduce the classes in the buffer zone
        var diff_mode = ee.Number(ee.Dictionary(
          clean_map.unmask(ee.Image(0)).reduceRegion({
            reducer: ee.Reducer.mode(),
            geometry: diff.geometry(),
            scale: vars.image_data_scale,
            maxPixels: 1e11
          })).get('classification'))
        
        return(f.set('mode',diff_mode))
      }
      
      // FUNCTION to reduce the map to vectors and map the neighbour properties function
      var reduce_neighbours_mode = function() {
        // reduce map to vectors
        var map_fc = clean_map.unmask(0)
              .updateMask(classn.gt(0)) // only vectorise class/es of interest
              .reduceToVectors({
                scale: vars.image_data_scale, 
                eightConnected: false,
                bestEffort: true, 
                maxPixels: 1e13,
                tileScale: 1,
                geometry: region_extent
              })
        // map the function, calculate neighbour properties
        return(map_fc.map(set_neighbour_mode))
      }
      
      // first make a make size threshold, so we're not vecortising huge objects when we don't have to
      var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels')
      Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false)
      
      // This is where we select the single or group of classes to vectorise for cleaning up
      var classn = segment_id.where({
        test: clean_map.neq(16) //TRF
                .and(clean_map.neq(15)) //RR
                .and(clean_map.neq(14)) //ORF
                .and(clean_map.neq(13)) //IRF
                //.and(clean_map.neq(12)) // deep L
                .and(clean_map.neq(11)) // shallow L 
                .and(clean_map.unmask(0).neq(0)), // no data values (want to reclaim the small gaps 
        value: ee.Image(0) // 99 ensures it's ignored in logic
      })
      
      // calculate neighbours
      var map_fc_neighbours = reduce_neighbours_mode()
      
      //print(map_fc_neighbours.limit(10))
      
      var mode_map = ee.Image().byte().paint(map_fc_neighbours, 'mode').unmask(0).rename('mode') // paint out the mode values to an image
      //Map.addLayer(mode_map, display_pal, "mode map", false)
      
      // replace small objects with mode underneath
      var clean_map = clean_map.unmask(0).where({
        test: segment_id.gt(0), 
        value: mode_map
      }).selfMask()
      
      */
      
    } else {
      
      if (vars.cleanup_stage == 1) {
        // BENTHIC CLEAN-UP RULES
        
        /*// reclaim shallow no data to surrounding class
        var smooth_map = clean_map
                            .focal_mode({
                              radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                              kernelType: 'circle', units: 'pixels', iterations: 2
                            });
        
        var clean_map = clean_map.unmask(0).where({
          test: geo_map.gt(2).and(clean_map.eq(0)), 
          value: smooth_map
        }).selfMask();*/
        
        // cut benthic off to < 10 - 15 m
        clean_map = clean_map.where({
          test: depth.gt(vars.benthic_depth_cutoff),
          value: ee.Image(0)
        });
        
        // Deep (or land or missing) in geo == masked from benthic
        clean_map = clean_map.where({
          test: geo_map.unmask(0).lte(2),
          value: ee.Image(0)
        });
        
      }
    }
  }
  
  // Final clip to the classified extent and move on
  if (vars.geomorphic) {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  } else {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  }

  
  
  // 4. Export data
  
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  
  if (vars.do_export) {
    print("For export, the image data scale must be set to:", vars.image_data_scale);
    
    Map.addLayer(region_extent, {}, "Export footprint", false);
    
    Export.image.toAsset({
      image: clean_map.set(vars),
      description: output_name,
      assetId: vars.asset_output + 'in_out/' + output_name,
      region: region_extent,
      scale: vars.image_data_scale,
      crs: 'EPSG:4326',
      maxPixels: 1e13,
      pyramidingPolicy: {'.default': 'mode'}
    });
    
  } else {
    if (vars.reproject_display) {
      Map.addLayer(clean_map.reproject(ee.Projection('EPSG:4326').atScale(vars.image_data_scale)), display_pal, output_name, true);
    } else {
      Map.addLayer(clean_map, display_pal, output_name, false);
    }
  }

}

//Generate title
var title = ui.Label({
  value: 'Classes',
  style: {fontWeight: 'bold', fontSize: '12px'}
});

// generate the legend
var geo_legend = pkg_vis.discrete_legend(map_palettes.geo_atlas_names, map_palettes.geo_atlas_cols, 'Geomorphic Zone', false);
var benthic_legend = pkg_vis.discrete_legend(map_palettes.benthic_atlas_names, map_palettes.benthic_atlas_cols, 'Benthic Habitat', false);
//var mask_legend = pkg_vis.discrete_legend(["Low confidence depth","Water conditions"], ["#f7f7f7","#bababa"], 'Confidence Mask reason', false)
var legend = (vars.geomorphic) ? geo_legend : benthic_legend;
pkg_vis.add_lgds([title, legend]);//, mask_legend])
// generate the legend
