/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var imageVisParam = {"opacity":1,"bands":["depth"],"min":1500,"max":2500,"gamma":1},
    imageVisParam2 = {"opacity":1,"bands":["b3","b2","b1"],"min":44.94,"max":2202.06,"gamma":1},
    waves = ee.Image("projects/coral_atlas/coral_sea/in_out/cosea_waves"),
    wavespng = ee.Image("projects/coral_atlas/png_solomons/in_out/pns_waves"),
    wcmc = ee.FeatureCollection("projects/coral_atlas/global_datasets/wcmc_reefs_2018v4_dissolved"),
    geometry = /* color: #d63000 */ee.Geometry.MultiPoint(),
    mid_mask = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry({
      "type": "GeometryCollection",
      "geometries": [
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                -64.57366708800909,
                32.38253907457304
              ],
              [
                -64.58430827046728,
                32.43993066844359
              ],
              [
                -64.62791339567376,
                32.39761407028685
              ],
              [
                -64.63992536066476,
                32.38166825925228
              ],
              [
                -64.63906582772461,
                32.35223679558766
              ],
              [
                -64.68602482755865,
                32.319811331251366
              ],
              [
                -64.69885375108028,
                32.31938687890832
              ],
              [
                -64.70543754588842,
                32.32105909655231
              ],
              [
                -64.70910152594561,
                32.32476176633224
              ],
              [
                -64.71628327318531,
                32.321226843154335
              ],
              [
                -64.72535311841648,
                32.31522544151082
              ],
              [
                -64.73731245110352,
                32.31482827392924
              ],
              [
                -64.7505020124968,
                32.309551903003864
              ],
              [
                -64.74927107828371,
                32.29861632929625
              ],
              [
                -64.74821173351727,
                32.2943548110171
              ],
              [
                -64.74836886149004,
                32.292078965867525
              ],
              [
                -64.74938473419486,
                32.28835190277249
              ],
              [
                -64.75021350671098,
                32.287557565218194
              ],
              [
                -64.7521729637317,
                32.28527406980693
              ],
              [
                -64.75572765326888,
                32.28181049539405
              ],
              [
                -64.76626024674461,
                32.27195268363418
              ],
              [
                -64.77953633881297,
                32.26557545526704
              ],
              [
                -64.79326926732377,
                32.257597730858194
              ],
              [
                -64.80905903169096,
                32.24990809952791
              ],
              [
                -64.81523094999004,
                32.24614204529793
              ],
              [
                -64.83350592866931,
                32.23794182088392
              ],
              [
                -64.84147977803163,
                32.236128843007535
              ],
              [
                -64.86129508480126,
                32.22807034388455
              ],
              [
                -64.88321684463376,
                32.22854071080831
              ],
              [
                -64.89002911915823,
                32.210130677252586
              ],
              [
                -64.9039481553036,
                32.13517509576115
              ],
              [
                -64.73524320930713,
                32.19595032352217
              ],
              [
                -64.57298041735466,
                32.36804070174248
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                -64.84775048428966,
                32.51625738029418
              ],
              [
                -64.8161670431834,
                32.47977516139698
              ],
              [
                -64.7097445201909,
                32.495412188774964
              ],
              [
                -64.66374252882916,
                32.49251664396619
              ],
              [
                -64.63490545662435,
                32.468190395996956
              ],
              [
                -64.61430754596465,
                32.45312799604574
              ],
              [
                -64.60332199032518,
                32.43226820523142
              ],
              [
                -64.56967874486702,
                32.45834219697914
              ],
              [
                -64.57311173640285,
                32.48209192414406
              ],
              [
                -64.63009928528412,
                32.52378358687463
              ],
              [
                -64.70150535486256,
                32.537097682695624
              ],
              [
                -64.76741864897512,
                32.534203488858424
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                -65.00225331582655,
                32.3824078600774
              ],
              [
                -65.0489452103578,
                32.29944885475138
              ],
              [
                -65.02285268106093,
                32.20188943961425
              ],
              [
                -64.95830800332655,
                32.17167124480729
              ],
              [
                -64.90337636270155,
                32.214671040303664
              ],
              [
                -64.9116161087953,
                32.233840073067036
              ],
              [
                -64.9226024369203,
                32.23558251194556
              ],
              [
                -64.93564870156874,
                32.23790571180482
              ],
              [
                -64.99264027871718,
                32.242551933301854
              ],
              [
                -65.02353932656874,
                32.306413372379915
              ],
              [
                -64.97135426797499,
                32.34354842483502
              ],
              [
                -64.92397572793593,
                32.38646683731187
              ],
              [
                -64.94251515664686,
                32.39748314185408
              ]
            ]
          ],
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                -64.9053881825267,
                32.22959508708876
              ],
              [
                -64.90126830947983,
                32.22698124402552
              ],
              [
                -64.88993865860093,
                32.22581951186777
              ],
              [
                -64.88650543106186,
                32.22901423957126
              ],
              [
                -64.89234191787827,
                32.23220885497616
              ],
              [
                -64.89611846817124,
                32.23337050546143
              ],
              [
                -64.9053881825267,
                32.23337050546143
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                -64.68440595695431,
                32.324923409863835
              ],
              [
                -64.6877533538049,
                32.32485088038712
              ],
              [
                -64.68912664482052,
                32.32506846864294
              ],
              [
                -64.689212475509,
                32.32361787039411
              ],
              [
                -64.69015661308224,
                32.32238484361115
              ],
              [
                -64.6906715972131,
                32.321006734985076
              ],
              [
                -64.6924740416711,
                32.321079267540874
              ],
              [
                -64.69667974540646,
                32.31962860538701
              ],
              [
                -64.69419065544064,
                32.317887780129396
              ],
              [
                -64.68311849662716,
                32.318322989580764
              ],
              [
                -64.67547956535275,
                32.32463329160839
              ],
              [
                -64.68140188285763,
                32.326373987197385
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        },
        {
          "type": "Polygon",
          "coordinates": [
            [
              [
                -64.69007078239376,
                32.49079097406424
              ],
              [
                -64.68595090934689,
                32.486157492853216
              ],
              [
                -64.67977109977657,
                32.48470948104229
              ],
              [
                -64.67462125846798,
                32.483551054817376
              ],
              [
                -64.6701580626672,
                32.47688981464942
              ],
              [
                -64.65436521598751,
                32.46762118219011
              ],
              [
                -64.64990202018673,
                32.460669081702285
              ],
              [
                -64.63822904655392,
                32.45371644458783
              ],
              [
                -64.62758604118282,
                32.44647354369441
              ],
              [
                -64.6207195861047,
                32.440099309358025
              ],
              [
                -64.61900297233517,
                32.436622264271115
              ],
              [
                -64.61282316276485,
                32.434014392449804
              ],
              [
                -64.60080686637814,
                32.44937077391268
              ],
              [
                -64.61076322624142,
                32.4713866792059
              ],
              [
                -64.65058866569454,
                32.487895076269254
              ],
              [
                -64.66088834831173,
                32.4983198720968
              ],
              [
                -64.66981473991329,
                32.496003355202724
              ]
            ]
          ],
          "geodesic": true,
          "evenOdd": true
        }
      ],
      "coordinates": []
    }),
    sandCoral = 
    /* color: #d63000 */
    /* shown: false */
    ee.Geometry.MultiPolygon(
        [[[[-64.86290751826576, 32.309716141587806],
           [-64.86307917964271, 32.309716141587806],
           [-64.86327229869178, 32.30969800617936],
           [-64.86348687541297, 32.30958919365245],
           [-64.86333667170814, 32.3092264842856],
           [-64.86299334895423, 32.3092264842856],
           [-64.86262856852821, 32.309353432729154],
           [-64.86224233043006, 32.309462245539216],
           [-64.86209212672523, 32.309643599932244],
           [-64.8621779574137, 32.309879360100446],
           [-64.86237107646278, 32.3100063076292],
           [-64.86262856852821, 32.309734276992614]]],
         [[[-64.85996781718544, 32.305055222201275],
           [-64.85968886744789, 32.30481944948031],
           [-64.85915242564491, 32.304710631094515],
           [-64.85885201823524, 32.304891994998265],
           [-64.85913096797279, 32.30496454045813],
           [-64.85949574839881, 32.304910131368665],
           [-64.85968886744789, 32.30503708585991],
           [-64.85977469813636, 32.305309130599355],
           [-64.86009656321815, 32.305309130599355]]],
         [[[-64.86005364787391, 32.30645170958616],
           [-64.86001073252967, 32.306252212706],
           [-64.86028968226722, 32.306215940498795],
           [-64.86033259761146, 32.30594389848183],
           [-64.86033259761146, 32.30570812807313],
           [-64.85990344416908, 32.30576253668345],
           [-64.85960303675941, 32.30588948998043],
           [-64.85953866374305, 32.3060345792449],
           [-64.85953866374305, 32.30623407660421],
           [-64.85928117167762, 32.306342893160526],
           [-64.8592597140055, 32.306469845644415],
           [-64.85943137538246, 32.306469845644415],
           [-64.85968886744789, 32.30668747806007]]],
         [[[-64.86256419551185, 32.30574440048363],
           [-64.86234961879066, 32.30556303828595],
           [-64.86204921138099, 32.30538167572526],
           [-64.8618346346598, 32.30538167572526],
           [-64.86170588862709, 32.305581174522054],
           [-64.8619419230204, 32.30581694526108],
           [-64.86219941508583, 32.30599830695055],
           [-64.86230670344642, 32.3061433960408],
           [-64.86262856852821, 32.30608898765917]]],
         [[[-64.86297189128211, 32.311239502937205],
           [-64.86325084101966, 32.311058151738806],
           [-64.86342250239662, 32.31073171866685],
           [-64.8632937563639, 32.31044155494879],
           [-64.86331521403602, 32.3101513903014],
           [-64.86305772197059, 32.31029647274126],
           [-64.86299334895423, 32.310532231210544],
           [-64.86316501033119, 32.31071358346171],
           [-64.86303626429847, 32.31093120568392],
           [-64.86280022990516, 32.310967476003476],
           [-64.86262856852821, 32.31107628687499],
           [-64.86269294154457, 32.311330178400254]]],
         [[[-64.86305772197059, 32.30518217648924],
           [-64.86331521403602, 32.305309130599355],
           [-64.8635083330851, 32.305164040173295],
           [-64.86357270610145, 32.304910131368665],
           [-64.86348687541297, 32.304783176699566],
           [-64.8632937563639, 32.304837585865236],
           [-64.86327229869178, 32.30507335853903]]],
         [[[-64.86165226534833, 32.312388852074754],
           [-64.86171663836468, 32.31230724511577],
           [-64.86152351931561, 32.312207503177156],
           [-64.86127675608624, 32.312207503177156],
           [-64.86111582354535, 32.31227097533261],
           [-64.86116946772565, 32.3124795263874],
           [-64.86126602725018, 32.312633672510636],
           [-64.86153424815167, 32.312588335442804],
           [-64.86149133280743, 32.31240698694454]]],
         [[[-64.85483888762636, 32.31262609889803],
           [-64.85460285323305, 32.312444750475386],
           [-64.85445264952821, 32.31257169440935],
           [-64.85462431090517, 32.31277117737476],
           [-64.85458139556093, 32.31282558174363],
           [-64.85479597228212, 32.31287998607987],
           [-64.85486034529848, 32.31311573782579],
           [-64.85518221038026, 32.3130431988924],
           [-64.85531095641298, 32.31286185130474],
           [-64.855675736839, 32.31271677297321],
           [-64.85580448287172, 32.31253542473208],
           [-64.85604051726503, 32.312553559572535],
           [-64.85640529769105, 32.31253542473208],
           [-64.85627655165834, 32.3122634016897],
           [-64.85608343260927, 32.312154592244035],
           [-64.85580448287172, 32.31220899698319],
           [-64.8553324140851, 32.31249915504029],
           [-64.85516075270814, 32.31277117737476]]],
         [[[-64.85855106490297, 32.306333096372995],
           [-64.858915845329, 32.306296824198164],
           [-64.85913042205019, 32.30604291856773],
           [-64.85917333739442, 32.30584342078753],
           [-64.8593664564435, 32.30564392256813],
           [-64.8596024908368, 32.30544442390949],
           [-64.85951666014833, 32.30531746998894],
           [-64.85917333739442, 32.30540815137892],
           [-64.85885147231264, 32.30562578634457],
           [-64.85852960723085, 32.30539001510818],
           [-64.85820774214906, 32.30529933370004],
           [-64.85792879241151, 32.30558951388661],
           [-64.8582506574933, 32.30598851012577],
           [-64.85848669188661, 32.306061054707776]]],
         [[[-64.69389314283055, 32.35687455845258],
           [-64.69775552381199, 32.354699417014054],
           [-64.700459190499, 32.3541193704618],
           [-64.70183248151463, 32.35190790885442],
           [-64.69994420636814, 32.350566504157655],
           [-64.69869964624958, 32.349551365759055],
           [-64.69784135450047, 32.34781112400807],
           [-64.6955239259116, 32.347231033282384],
           [-64.69290608991307, 32.34802865707121],
           [-64.69123239148777, 32.34955137386693],
           [-64.69054574597996, 32.351146573494745],
           [-64.69024533857029, 32.35266923780597],
           [-64.69067449201268, 32.3541193704618],
           [-64.69153279889744, 32.35564198472717],
           [-64.69269151319187, 32.356439534350095]]]]),
    rbCoral = /* color: #98ff00 */ee.Geometry.MultiPolygon(
        [[[[-64.85377458665174, 32.3169882181662],
           [-64.85525516602796, 32.31633539358421],
           [-64.85692886445325, 32.31481211792812],
           [-64.85774425599378, 32.314503832833275],
           [-64.85922483537, 32.31428621919345],
           [-64.85991148087781, 32.31426808469986],
           [-64.8605766687135, 32.31312560428508],
           [-64.86081270310682, 32.31254529125457],
           [-64.85896734330457, 32.31185616470244],
           [-64.85600618455213, 32.31337949006694],
           [-64.85291627976697, 32.315065998983094],
           [-64.85145715806287, 32.31629912541393],
           [-64.85145715806287, 32.31697008421356],
           [-64.852379837964, 32.317405298074604]]],
         [[[-64.72033824879377, 32.33294941031494],
           [-64.7258743282005, 32.33073743124234],
           [-64.7345003123924, 32.32718364677506],
           [-64.73574485737531, 32.3259869328541],
           [-64.73329868275373, 32.32435502474377],
           [-64.730466270034, 32.324681408718796],
           [-64.72591724354474, 32.32595066854897],
           [-64.7235139842674, 32.328017710759795],
           [-64.72128238636701, 32.328489134830534],
           [-64.71896495777814, 32.329250660836195],
           [-64.71832122761457, 32.33033854401791],
           [-64.71866455036847, 32.332731840999706]]],
         [[[-64.7090851746909, 32.3524154622008],
           [-64.70917100537937, 32.35020395893302],
           [-64.70912809003514, 32.348499976913594],
           [-64.70826978315037, 32.34661468281071],
           [-64.70951432813328, 32.34440303772892],
           [-64.70711106885594, 32.34255391591928],
           [-64.70419282544773, 32.34262643121197],
           [-64.70419282544773, 32.34588955923279],
           [-64.7050511323325, 32.350639013028214],
           [-64.70629567731541, 32.35448189999291],
           [-64.70788354505223, 32.3541193704618]]],
         [[[-64.75240807844777, 32.43048976250579],
           [-64.75515466047902, 32.42208577842365],
           [-64.75875954939504, 32.41121739673366],
           [-64.76305108381887, 32.40107239275241],
           [-64.75790124251027, 32.39382526327535],
           [-64.7512064488091, 32.38715739045057],
           [-64.74245171858449, 32.39092624862151],
           [-64.7156725437798, 32.40223187948796],
           [-64.70623116804738, 32.4102029476477],
           [-64.70056634260793, 32.416289471108826],
           [-64.67224221541066, 32.44077633209282],
           [-64.66365975245994, 32.45134974545129],
           [-64.69678979231496, 32.46120110985896],
           [-64.73970513655324, 32.44034171205524]]],
         [[[-64.97283556999717, 32.302363985612146],
           [-64.95064833702598, 32.323327791212975],
           [-64.94018755608681, 32.32777916360676],
           [-64.94200050348608, 32.33687202753752],
           [-64.96648409904991, 32.33228489277272],
           [-64.98476603569542, 32.315022642301045],
           [-64.98729804100547, 32.290175183959064],
           [-64.98549559654747, 32.285023471545315],
           [-64.98094657005821, 32.27903695921508],
           [-64.97485259117637, 32.27192519475114],
           [-64.96146300377403, 32.26368791368645],
           [-64.95635607780967, 32.26503060521683],
           [-64.97034648003135, 32.273594332397316],
           [-64.9745521837667, 32.27736792170574],
           [-64.97549632133995, 32.280089162731095],
           [-64.977127104421, 32.28357223211462],
           [-64.97819998802696, 32.28817983711884],
           [-64.98051741661583, 32.291009588707745],
           [-64.98000243248497, 32.293149983165186],
           [-64.97841456474815, 32.29431085393791]]],
         [[[-64.95495386108549, 32.27345033219915],
           [-64.95727128967435, 32.270982896559886],
           [-64.9527222631851, 32.26916856283955],
           [-64.94585580810697, 32.26800737021996],
           [-64.94087762817533, 32.26938628480149],
           [-64.9377018927017, 32.270184594192415],
           [-64.9362427709976, 32.272144051101854],
           [-64.93864603027494, 32.27345033219915],
           [-64.9431950567642, 32.27243433741546],
           [-64.94877405151517, 32.2714183312545],
           [-64.95237894043119, 32.27236176592413]]],
         [[[-64.87724075108744, 32.39758310123319],
           [-64.87998733311869, 32.395988721040894],
           [-64.88196143895365, 32.3941044172453],
           [-64.88153228551127, 32.39185769594718],
           [-64.87981567174174, 32.390553122447045],
           [-64.87724075108744, 32.390045783219016],
           [-64.87415084630229, 32.39250997563059],
           [-64.87320670872904, 32.39511904725185],
           [-64.87457999974467, 32.3962061381794],
           [-64.87621078282572, 32.39729321601951]]],
         [[[-64.8185119273198, 32.44615156816926],
           [-64.82520672102098, 32.443616406265086],
           [-64.82409092207078, 32.43919781079064],
           [-64.81885525007371, 32.4367348930778],
           [-64.81456371564988, 32.439342686207716],
           [-64.81276127119187, 32.44325423445755],
           [-64.8130187632573, 32.44593427137169]]],
         [[[-64.79442297500967, 32.45916070494096],
           [-64.80266272110342, 32.45713287392307],
           [-64.80292021316885, 32.45322192805258],
           [-64.79716955704092, 32.448948663486384],
           [-64.78978811783193, 32.446848171024556],
           [-64.78601156753896, 32.44192268636679],
           [-64.77991758865713, 32.440763709682436],
           [-64.77279364151357, 32.44605141969727],
           [-64.77665602249502, 32.4540910418069],
           [-64.78360830826162, 32.458943439515366],
           [-64.79021727127432, 32.45930554826691]]],
         [[[-64.78420912308096, 32.46437491794018],
           [-64.77536856216787, 32.452642514225396],
           [-64.7727078108251, 32.448948663486384],
           [-64.76137815994619, 32.44467519626832],
           [-64.75210844559072, 32.444095727484964],
           [-64.74755941910146, 32.446123851927176],
           [-64.74910437149404, 32.44981781845975],
           [-64.76163565201162, 32.452714941157566],
           [-64.76884542984365, 32.460826389127455],
           [-64.77717100662588, 32.46546117431998]]],
         [[[-64.76704298538564, 32.46104365001133],
           [-64.7635239271581, 32.4562637895129],
           [-64.75665747207998, 32.452497660186374],
           [-64.74953352493642, 32.45539469671854],
           [-64.73811804336904, 32.44938324202097],
           [-64.72412764114736, 32.450252392802696],
           [-64.70902143997549, 32.45908828319066],
           [-64.69503103775381, 32.46604050569853],
           [-64.69958006424307, 32.47378870459513],
           [-64.71168219131826, 32.47530930087275],
           [-64.72129522842764, 32.47291978090488],
           [-64.73734556717275, 32.47089225968047],
           [-64.74275290054678, 32.46843020824014],
           [-64.75854574722646, 32.46958882906864],
           [-64.76566969437002, 32.468357793943355],
           [-64.77348028702139, 32.468285379588316]]],
         [[[-64.69169122131206, 32.47461905593457],
           [-64.6940944805894, 32.467957154768186],
           [-64.6721218243394, 32.45803580150623],
           [-64.6629379406724, 32.4518072403959],
           [-64.66328126342631, 32.448620368201624],
           [-64.65813142211772, 32.44304307066479],
           [-64.64791757018901, 32.438624447085274],
           [-64.63349801452495, 32.43688591286259],
           [-64.62869149597026, 32.44231872098694],
           [-64.63392716796733, 32.45187966799948],
           [-64.65066415222026, 32.46592952179392],
           [-64.67418176086284, 32.47534314592464],
           [-64.6831081524644, 32.476646493229794]]],
         [[[-64.64664509071294, 32.39641847482631],
           [-64.65634395851079, 32.392577370675916],
           [-64.66012050880376, 32.388663624830144],
           [-64.65840389503423, 32.384967153588114],
           [-64.65419819129887, 32.38293765407583],
           [-64.65067913307134, 32.38917097182199],
           [-64.6442418314356, 32.392359944800525],
           [-64.64183857215825, 32.39359201783981],
           [-64.6420102335352, 32.39714319313633]]],
         [[[-64.67820770251512, 32.39520747357274],
           [-64.68704826342821, 32.38426337333906],
           [-64.68284255969286, 32.381943923533946],
           [-64.6658480833745, 32.37976938525967],
           [-64.65932495105028, 32.378537123673006],
           [-64.65752250659227, 32.38317613865751],
           [-64.6614707182622, 32.388249788554916],
           [-64.66507560717821, 32.3932506788398],
           [-64.66945297229051, 32.396004674085255]]],
         [[[-64.90791337010207, 32.26832338030581],
           [-64.90980164524855, 32.26737990364678],
           [-64.9073983859712, 32.26454941481519],
           [-64.90473763462843, 32.263533320368296],
           [-64.90216271397414, 32.262734952465394],
           [-64.8964120578462, 32.26237205564255],
           [-64.89418045994582, 32.26157367752498],
           [-64.89220635411085, 32.2608478731424],
           [-64.8894597720796, 32.26288011078828],
           [-64.88714234349074, 32.26208173713959],
           [-64.88662735935988, 32.26382363422821],
           [-64.88697068211378, 32.26636384089011],
           [-64.88894478794874, 32.26687187369048],
           [-64.89194886204542, 32.26571065168208],
           [-64.8957254123384, 32.265928381940455],
           [-64.90430848118605, 32.26875882776302]]]]),
    rockCoral = /* color: #0b4a8b */ee.Geometry.MultiPolygon(
        [[[[-64.88422884574047, 32.399066748264964],
           [-64.88766207327953, 32.39036992991918],
           [-64.87942232718578, 32.388195594466545],
           [-64.86362948050609, 32.4038496413216],
           [-64.84714998831859, 32.41051628156046],
           [-64.83410372367015, 32.41921115920651],
           [-64.82483400931469, 32.43080302596451],
           [-64.8035479985725, 32.44644968267939],
           [-64.78689684500804, 32.4568792782873],
           [-64.7983981572639, 32.46339716245544],
           [-64.81504931082836, 32.46556968569942],
           [-64.84131350150219, 32.453547733139864],
           [-64.84800829520336, 32.43428029547401],
           [-64.87083925833812, 32.42051531858656],
           [-64.87736239066234, 32.40790765489197],
           [-64.88422884574047, 32.398052162617056]]],
         [[[-64.7470444349706, 32.48001574561059],
           [-64.77699934524892, 32.47465761989879],
           [-64.78266417068838, 32.46604050569853],
           [-64.77330862564443, 32.46466458758922],
           [-64.75639998001455, 32.46459217026431],
           [-64.74489866775869, 32.467706062651715],
           [-64.7371739057958, 32.46958882906864],
           [-64.73614393753408, 32.47444039185911],
           [-64.74017797989248, 32.47871244708972]]],
         [[[-64.650078318252, 32.39504149401246],
           [-64.65608646644536, 32.391345283793946],
           [-64.65891887916509, 32.38917097182199],
           [-64.65763141883794, 32.38511211609435],
           [-64.65531399024907, 32.38337255066665],
           [-64.65256740821782, 32.38743148455699],
           [-64.64733173622075, 32.391780139906935],
           [-64.64226772560063, 32.393881914935584],
           [-64.6416669107813, 32.397215664647405],
           [-64.64535763038579, 32.39649094691905]]],
         [[[-64.67511779772997, 32.39520747357274],
           [-64.67812187182665, 32.393685525778146],
           [-64.68215591418505, 32.38875713787129],
           [-64.68618995654344, 32.383755998782675],
           [-64.68215591418505, 32.38266875799494],
           [-64.673143691895, 32.38237882490839],
           [-64.66790801989794, 32.38020429710143],
           [-64.66370231616258, 32.37926198546513],
           [-64.65983993518114, 32.38085666093885],
           [-64.6588957976079, 32.38295869015104],
           [-64.66215736377, 32.38716260185223],
           [-64.66713554370165, 32.392163552333265],
           [-64.66945297229051, 32.394047896627235],
           [-64.67151290881395, 32.39520747357274]]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/

///////////////////////////////
// Global coral atlas project - Bermuda
// Contact: mitchell.lyons@gmail.com
// Region coordinator: Rodney Borrego (rodbio2008@gmail.com)...Note: previous geometries for geo 3 are in version saved 21/04 15:58. I removed geoms as the script crashed.
// Description:
// - Developing a process to combine OBIA and supervised classification
// - This script loads the raw classification data (from *_classification script)
// - Then applied some cleanup and object-based relational rules
///////////////////////////////

// Table of contents
// 1. Setting constants
// 2. Data loads & vis
// 3. OBIA clean up rules
// 4. Export

// Load and libraries needed
var map_palettes = require('users/mitchest/global_reefs_modules:colour_pals');
var pkg_vis = require('users/mitchest/global_reefs_modules:pkg_vis');
var param_module = require('users/mitchest/global_reefs_modules:reef_params');

// ###########################################
// SENSOR GENERICS
var sensor_params = param_module.dove;         //<------------ THIS IS WHERE YOU CHOOSE THE SENSOR
// REGION AND SENSOR SPECIFIC LOAD PATHS
var region_params = param_module.bermuda;  //<------------ THIS IS WHERE YOU CHOOSE THE REGION
//  ^^ all the data paths are in this module ^^
// ###########################################

// 1. Setting constants

// These will get written to the asset metadata 

//Map.centerObject(geometry, 7)

var vars = {
  
  // analysis type
  geomorphic: false, // map geomorphic zonation (when set to true) or benthic habitat (when set to false)

  // analysis parameters
  image_data_scale: sensor_params.pixel,
  small_object_geo: ee.Number(400).int(), // smallest object szie in pixels (geomorphic)
  small_object_benthic: ee.Number(130).int(), // smallest object szie in pixels (benthic)
  smooth_radius: ee.Number(3), // radius in pixels for initial smooth 
  dist_to_land_ORF: 8000, //distance to land in meters to convert terrestrial reef flat to ORF
  dist_to_land_RC: 500, //distance to land in meters to convert reef crest to TRF - not used for Indo
  wave_height: 0.4, //cut off height for waves in metres, Hs95 threshold
  geo_depth_cutoff: 1500, //depth in centimetres
  shallowlag_depth_cutoff: 500, //depth in centimetres
  benthic_depth_cutoff: 1500, //depth in centimetres
  
  //############
  // Clean-up stage selection
  cleanup_stage: 2, // set to 1, 2 or 3
  geo_refinement: false, // set to true to apply the refinement_mask (the other stage 3 masks will still run)
  
  //if the global extend + depth cleanup be applied?
  global_extent_clean: false,
  global_depth_thresh: 500, //this threshold will be adding to the global extent (above 5 m will be added to the global extent)
  
  /*
  - GEOMORPHIC 1: The first pass does a small object filter, just to generally clean noise and reduce the amount of cleaning needed
  -            2: The second pass runs the OBIA cleanup rules
  -            3: The third pass is the MANUAL cleanup stage, which includes AT LEAST the no_reef masking
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY

  - BENTHIC 1: This is the main benthic stge - it does noise removal, no data reclaim and OBIA rules - review those if needed
            2: The second mas is the MANUAL stage - it's optional, but shuold include ALL region specific stuff
                        - see below where it starts/ends (only that section is run)
                        - please put region specific stuff in here ONLY
  */
  
  // DON'T TOUCH --->
  obia_2nd_pass: null,
  obia_clean: null, // run object-based relationship rules + small object clean up
  fast_clean: null, // run a faster (but less precise) version of the OBIA clean; only applies to geomorphic (`obia_clean: true` also)
  manual_clean: false, // apply manual touch ups
  // --------------<
  //############
  
  reproject_display: false,
  
  // export options
  do_export: true, // export the results?
  geomorph_output_name: region_params.sname + '_geo_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  benthic_output_name: region_params.sname + '_benthic_clean', // DO NOT CHANGE - change in the pop up dialouge if you must
  asset_output: region_params.asset // asset path

};


// Clean up stage auto-parameterisation (DON'T TOUCH) --->

if (vars.geomorphic) {
  var temp_outname = vars.geomorph_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.obia_2nd_pass = true;
    vars.obia_clean = true;
    vars.fast_clean = true;
    vars.manual_clean = false;
    vars.geomorph_output_name = temp_outname + '2';
  } else if (vars.cleanup_stage == 3) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false;
    vars.obia_clean = false;
    vars.fast_clean = false;
    vars.do_export = false;
    vars.geomorph_output_name = temp_outname + '3';
  }
}

if (!vars.geomorphic) {
  var temp_outname = vars.benthic_output_name;
  if (vars.cleanup_stage == 1) {
    vars.obia_2nd_pass = true,
    vars.obia_clean = true, 
    vars.fast_clean = false, 
    vars.manual_clean = false;
    vars.benthic_output_name = temp_outname + '1';
  } else if (vars.cleanup_stage == 2) {
    vars.manual_clean = true;
    vars.obia_2nd_pass = false,
    vars.obia_clean = false, 
    vars.fast_clean = false,
    vars.do_export = false;
    vars.benthic_output_name = temp_outname + '2';
  }
}

//Region extent is created in map viewer and exported to GEE asset
var region_extent = ee.FeatureCollection(region_params.extent_mask).geometry();
Map.addLayer(region_extent, {}, "Manual reef outline", false);
// -----------------------------------------<

//################################################################################################
//START OF CLEAN 3 - Manual Cleanup
//Review everything in this section
//This is the section to add/remove manual cleanups
//You MUST review it for each region

//###############################################################################################

if (vars.manual_clean && vars.geomorphic) {
  
  print("Doing GEOMORPHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.pixels).select('depth');
  
 
  
  // define the manually edited map - uses the output from the second pass of cleaning
  //var man_geo = ee.Image(region_params.geo_map_clean2);
  var man_geo = ee.Image(region_params.geo_map_clean2); // use this when testing for a small area
  
  /*
 
  if (vars.global_extent_clean) {
    var blanket_mask = ee.Image([param_module.global_extent_mask.gcrmn]).unmask(0, false)
    .eq(1) ///extent for the NN global extnet
    .add(depth.lt(vars.global_depth_thresh))//combine with areas less than depth thershold
    .eq(0)
    .selfMask().connectedPixelCount(25, true).gte(25)
  }
  
 */ 
  
  
  // import the mid mask from asset ****only use ee.FC if mid_mask created in map viewer****
  //var mid_mask = ee.FeatureCollection(region_params.mid_mask).geometry();
  //Map.addLayer(mid_mask, {color: 'red'}, "mid mask import", true, 0.4);
  var midmask = ee.Image().byte().paint(ee.Feature(mid_mask.dissolve(),{zone: 1}), "zone").clip(mid_mask.dissolve());
  
  // the "MID MASK" CLEAN
  man_geo = man_geo.where({
  test: midmask.eq(1),
 value: ee.Image(0)
  });
  
  /*
  // the "REEF MASK" CLEAN
  
  // Define a kernel for reef mask Morphological Operations
  var kernel_rm = ee.Kernel.circle({radius: vars.smooth_radius.multiply(5)});

  // Create reef mask to clean areas inside the reef - Perform an dilation of deepwater
  var reef_mask = man_geo.eq(2)
            .focal_max({kernel: kernel_rm, iterations: 2});
  var global_reef_mask = ee.Image(region_params.global_reef_mask);
  

  // Reef crest, slope, sheltered slope (within reef mask) -> Inner reef flat
  man_geo = man_geo.where({
    test: reef_mask.eq(0)
                    .and(man_geo.eq(15).or(man_geo.eq(21)).or(man_geo.eq(22))),
    value: ee.Image(13)
  });
  
  // the "DEEP WATER" CLEAN
  
  // Define a kernel for deep water Morphological Operations
  var kernel_dw = ee.Kernel.circle({radius: vars.smooth_radius.multiply(5)});

  // Create mask to clean deepwater areas - Perform an dilation of deepwater followed by a erosion
  var deepwater = man_geo.eq(2)
            .focal_max({kernel: kernel_dw, iterations: 2})
            .focal_min({kernel: kernel_dw, iterations: 2});
    
  
    // Deep lagoon (outside reef mask and global mask) -> deepwater 
  man_geo = man_geo.where({
    test: deepwater.eq(1)
                    .and(man_geo.eq(12)),
                    //.and(global_reef_mask.eq(2)),
    value: ee.Image(2)
  });
  
 
  // Reef classes in deepwater -> deepwater
  man_geo = man_geo.where({
    test: deepwater.eq(1)
                    .and(man_geo.eq(15).or(man_geo.eq(21)).or(man_geo.eq(22)).or(man_geo.eq(24))),
    value: ee.Image(2)
  });
  
  */
  
  
  
  
/*
  // WAVE clean (un-comment this sectio nbased on whether you have waves or not)
  
  var waves = ee.Image(region_params.waves)
  Map.addLayer(waves.lt(vars.wave_height), {}, vars.wave_height + "m Hs95 threshold", false)
  
  man_geo = man_geo.where({
    test: waves.lte(vars.wave_height)
               .and(man_geo.eq(22)),
    value: ee.Image(21)
  })
 
*/ 
  
  
/*
  ##############
  
  The rest of the manual geometry paintings and rules should go here
      - make the geom, paint the layer, use it in a rule
      - consult previous regions *_cleanup script for ideas/hints/existing rules etc.
  e.g. 
  var notreefcrest = ee.Image().byte().paint(ee.Feature(not_reef_crest, {zone: 1}), "zone").clip(not_reef_crest);
  var notdeepwater = ee.Image().byte().paint(ee.Feature(not_deep_water, {zone: 1}), "zone").clip(not_deep_water);
  
*/
/*
var mid_Mask = ee.Image().byte().paint(ee.Feature(midMask, {zone: 1}), "zone").clip(midMask);

man_geo = man_geo.where({
  test: mid_Mask.eq(1),
  value: ee.Image (0),
})

*/
var makedeeplagoon = ee.Image().byte().paint(ee.Feature(makeDeepLagoon, {zone: 1}), "zone").clip(makeDeepLagoon);
var orfdl = ee.Image().byte().paint(ee.Feature(orf_dl, {zone: 1}), "zone").clip(orf_dl);
var brs_RS_dl = ee.Image().byte().paint(ee.Feature(brs_rs_dl, {zone: 1}), "zone").clip(brs_rs_dl);
var rcorf = ee.Image().byte().paint(ee.Feature(rc_orf, {zone: 1}), "zone").clip(rc_orf);
var cleanrc = ee.Image().byte().paint(ee.Feature(cleanRC, {zone: 1}), "zone").clip(cleanRC);


man_geo = man_geo.where({
  test: makedeeplagoon.eq(1)
        .and(man_geo.neq(14).and(man_geo.neq(22).and(man_geo.neq(24).and(man_geo.neq(11).and(man_geo.neq(13)))))),
  value: ee.Image (12)
});

man_geo = man_geo.where({
  test: orfdl.eq(1)
        .and(man_geo.eq(14)),
  value: ee.Image (12)
});

man_geo = man_geo.where({
  test: brs_RS_dl.eq(1)
        .and(man_geo.eq(24).or(man_geo.eq(22))),
  value: ee.Image (12)
});

man_geo = man_geo.where({
  test: rcorf.eq(1)
        .and(man_geo.eq(15)),
  value: ee.Image (14)
});

man_geo = man_geo.where({
  test: cleanrc.eq(1)
        .and(man_geo.eq(15)),
  value: ee.Image (0)
});

/*
var Brs_Sl = ee.Image().byte().paint(ee.Feature(brs_sl, {zone: 1}), "zone").clip(brs_sl);

var Dl_SRS_Pr_toRs = ee.Image().byte().paint(ee.Feature(Dl_SRS_Pr_to_rs, {zone: 1}), "zone").clip(Dl_SRS_Pr_to_rs);
var Rs_Sl = ee.Image().byte().paint(ee.Feature(rs_sl, {zone:1}), "zone").clip(rs_sl)

var Sl_Brs = ee.Image().byte().paint(ee.Feature(sl_brs, {zone: 1}), "zone").clip(sl_brs);
var Rs_Brs = ee.Image().byte().paint(ee.Feature(rs_brs, {zone: 1}), "zone").clip(rs_brs);
var Rs_Dl_Sl_SRS_toBrs= ee.Image().byte().paint(ee.Feature(rs_dl_sl_srs_tobrs, {zone:1}), "zone").clip(rs_dl_sl_srs_tobrs);
var SRS_toBrs = ee.Image().byte().paint(ee.Feature(srs_brs, {zone: 1}), "zone").clip(srs_brs);
var Rs_mask = ee.Image().byte().paint(ee.Feature(rs_mask, {zone: 1}), "zone").clip(rs_mask);
var Sl_mask = ee.Image().byte().paint(ee.Feature(sl_mask, {zone: 1}), "zone").clip(sl_mask);
var Srs_rs = ee.Image().byte().paint(ee.Feature(srs_rs, {zone:1}), "zone").clip(srs_rs)
var Srs_tomask = ee.Image().byte().paint(ee.Feature(srs_tomask, {zone:1}), "zone").clip(srs_tomask)
var Dl_SRS_Pr_toRs = ee.Image().byte().paint(ee.Feature(Dl_SRS_Pr_to_rs, {zone: 1}), "zone").clip(Dl_SRS_Pr_to_rs);

var Orf_irf_rs_brs_totrf= ee.Image().byte().paint(ee.Feature(orf_irf_rs_brs_totrf, {zone:1}), "zone").clip(orf_irf_rs_brs_totrf);


var Brs_rs = ee.Image().byte().paint(ee.Feature(brs_rs, {zone: 1}), "zone").clip(brs_rs)
var BrsDl_srs = ee.Image().byte().paint(ee.Feature(brsdl_srs, {zone: 1}), "zone").clip(brsdl_srs)
var Sl_srs = ee.Image().byte().paint(ee.Feature(sl_srs, {zone:1}),"zone").clip(sl_srs) 
var Sl_rs = ee.Image().byte().paint(ee.Feature(sl_rs, {zone:1}),"zone").clip(sl_rs)  


//var Brs_mask = ee.Image().byte().paint(ee.Feature(brsdl_mask, {zone:1}),"zone").clip(brsdl_mask)  
 
 //var Srs_Brs = ee.Image().byte().paint(ee.Feature(srs_brs, {zone: 1}), "zone").clip(srs_brs)
 //var All_Brs = ee.Image().byte().paint(ee.Feature(all_brs, {zone:1}), "zone").clip(all_brs)
 // var Srs_Orf = ee.Image().byte().paint(ee.Feature(srs_orf, {zone: 1}), "zone").clip(srs_orf)  
  
  // Back reef slope -> shallow lagoon (inside the reef)


  man_geo = man_geo.where({
   test: Brs_Sl.eq(1)
                   .and(man_geo.eq(24)).or(man_geo.eq(12)),
    value: ee.Image(11)
  });
  



  

  // deep laggon, sheltered r s and patch reefs into reef slope
  
  man_geo = man_geo.where({
    test: Dl_SRS_Pr_toRs.eq(1)
                            .and(man_geo.eq(12)).or(man_geo.eq(25)).or(man_geo.eq(21)),
    value: ee.Image(22)
  });
  
  //reef slope to shallow lagoon
  
  man_geo = man_geo.where({
   test: Rs_Sl.eq(1)
                   .and(man_geo.eq(22)),
  value: ee.Image(11)
  })
  

   // Shallow lagoon and deep lagoon > back reef slope (inside the reef)
  man_geo = man_geo.where({
    test:  Sl_Brs.eq(1)
                     .and(man_geo.eq(11).or(man_geo.eq(12))),
    value: ee.Image(24)
  });
  
  // reef slope > back reef slope (outside the reef)
  man_geo = man_geo.where({
    test: Rs_Brs.eq(1)
                     .and(man_geo.eq(22)),
    value: ee.Image(24)
  });
  
   // deep laggon, sheltered r s and patch reefs into reef slope
  
  
  man_geo = man_geo.where({
    test: Dl_SRS_Pr_toRs.eq(1)
                            .and(man_geo.eq(12)).or(man_geo.eq(25)).or(man_geo.eq(21)),
    value: ee.Image(22)
  });
  
  

  man_geo = man_geo.where({
    test: Rs_Dl_Sl_SRS_toBrs.eq(1)
                      .and(man_geo.eq(22)).or(man_geo.eq(12)).or(man_geo.eq(11)).or(man_geo.eq(21)),
    value: ee.Image(24)
  })
  
   //sheltered reef slope > back reef slope (inside the reef)
  man_geo = man_geo.where({
    test:  SRS_toBrs.eq(1)
                     .and(man_geo.eq(21)),
    value: ee.Image(24)
  });
  
  //mask out rs
  man_geo = man_geo.where({
  test: Rs_mask.eq(1)
        .and(man_geo.eq(22)),
  value: ee.Image (0),
})

//mask out shallow lagoon
  man_geo = man_geo.where({
  test: Sl_mask.eq(1)
        .and(man_geo.eq(11)),
  value: ee.Image (0),
})


//srs to rs
  man_geo = man_geo.where({
  test: Srs_rs.eq(1)
        .and(man_geo.eq(21)),
  value: ee.Image (22),
})


//srs to mask
  man_geo = man_geo.where({
  test: Srs_tomask.eq(1)
        .and(man_geo.eq(21)),
  value: ee.Image (0),
})

  man_geo = man_geo.where({
    test: Orf_irf_rs_brs_totrf.eq(1)
                      .and(man_geo.eq(14)).or(man_geo.eq(13)).or(man_geo.eq(22)).or(man_geo.eq(24)),
    value: ee.Image(16)
  })
  
  
  /*
  
  man_geo = man_geo.where({
    test: Brs_rs.eq(1)
          .and(man_geo.eq(24)),
    value: ee.Image(22)
  })
  
  
  man_geo = man_geo.where({
    test: BrsDl_srs.eq(1)
          .and(man_geo.eq(24)).or(man_geo.eq(12)),
    value: ee.Image(21)
  })
  
  
   man_geo = man_geo.where({
    test: Sl_srs.eq(1)
          .and(man_geo.eq(11)),
    value: ee.Image(21)
  })
  
  man_geo = man_geo.where({
    test: Sl_rs.eq(1)
          .and(man_geo.eq(11)),
    value: ee.Image(22)
  })
  

  man_geo = man_geo.where({
    test: Brs_mask.eq(1)
         .and(man_geo.eq(24)).or(man_geo.eq(12)),
    value: ee.Image(0)
  }) 
  
  
  var refine = ee.Image().byte().paint(ee.Feature(refinement_mask, {zone: 1}), "zone").clip(refinement_mask);
    // apply
    man_geo = man_geo.where({
      test: refine.eq(1),
      value: ee.Image(0)
    });

/*
 //Back reef slope > reef slope (outside the reef)
  man_geo = man_geo.where({rock
    test:  Brs_Rs.eq(1)
                     .and(man_geo.eq(24)),
    value: ee.Image(22)
  });
  
  //reef crest > Back reef slope (outside the reef)
 // man_geo = man_geo.where({
   // test:  Rc_Brs.eq(1)
   //                  .and(man_geo.eq(15)),
  //  value: ee.Image(24)
  //});
   
  //sheltered reef slope > Back reef slope (outside the reef)
  man_geo = man_geo.where({
    test:  Srs_Brs.eq(1)
                     .and(man_geo.eq(21)),
    value: ee.Image(24)
  });
    
  //sheltered reef slope > outer reef falt (inside the reef)
 // man_geo = man_geo.where({
   // test:  Srs_Orf.eq(1)
     //                .and(man_geo.eq(21)),
   // value: ee.Image(14)
  //}); 
  
  man_geo = man_geo.where({
    test: All_Brs.eq(1)
            .and(man_geo.eq(11)).or(man_geo.eq(12))
            .or(man_geo.eq(13)).or(man_geo.eq(15))
            .or(man_geo.eq(16)).or(man_geo.eq(21)).or(man_geo.eq(22))
            .or(man_geo.eq(23)),
    
    value: ee.Image(24)
  });
*/
/*
var Dl_Null = ee.Image().byte().paint(ee.Feature(dl_null, {zone: 1}), "zone").clip(dl_null);

var Dl_SRS_toRs = ee.Image().byte().paint(ee.Feature(Dl_SRS_trf_to_rs, {zone: 1}), "zone").clip(Dl_SRS_trf_to_rs);

var Dl_SRS_TRF_toRs = ee.Image().byte().paint(ee.Feature(Dl_SRS_trf_to_rs, {zone: 1}), "zone").clip(Dl_SRS_trf_to_rs);

var trf_rs =ee.Image().byte().paint(ee.Feature(trf_tors, {zone:1}), "zone").clip(trf_tors);

var Srs_tomask = ee.Image().byte().paint(ee.Feature(SRS_tomask, {zone:1}), "zone").clip(SRS_tomask)

var Rc_rs = ee.Image().byte().paint(ee.Feature(rc_rs, {zone: 1}), "zone").clip(rc_rs)

var RC_Null = ee.Image().byte().paint(ee.Feature(rc_null, {zone: 1}), "zone").clip(rc_null);

var TRF_srs = ee.Image().byte().paint(ee.Feature(trf_srs, {zone: 1}), "zone").clip(trf_srs)

var Orf_irf_rs_brs_totrf= ee.Image().byte().paint(ee.Feature(orf_irf_rs_brs_totrf, {zone:1}), "zone").clip(orf_irf_rs_brs_totrf);

var Pl_brs = ee.Image().byte().paint(ee.Feature(pl_brs, {zone: 1}), "zone").clip(pl_brs)

var ORF_irf_rs_brs_tors= ee.Image().byte().paint(ee.Feature(orf_irf_rs_brs_tors, {zone:1}), "zone").clip(orf_irf_rs_brs_tors);

var TRF_Null = ee.Image().byte().paint(ee.Feature(trf_null, {zone: 1}), "zone").clip(trf_null);

var RS_srs = ee.Image().byte().paint(ee.Feature(rs_srs, {zone: 1}), "zone").clip(rs_srs);

var RS_Null = ee.Image().byte().paint(ee.Feature(rs_null, {zone: 1}), "zone").clip(rs_null);


var Sl_pl_dl_brs = ee.Image().byte().paint(ee.Feature(sl_pl_dl_brs, {zone: 1}), "zone").clip(sl_pl_dl_brs);

var pr_Null = ee.Image().byte().paint(ee.Feature(Pr_null, {zone: 1}), "zone").clip(Pr_null);

var Sl_rs = ee.Image().byte().paint(ee.Feature(sl_rs, {zone: 1}), "zone").clip(sl_rs);

man_geo=man_geo.where({
  test: Dl_Null.eq(1).and(man_geo.eq(12)),
  value: ee.Image(0)
})

man_geo = man_geo.where({
    test: Dl_SRS_TRF_toRs.eq(1)
                            .and(man_geo.eq(12)).or(man_geo.eq(16)).or(man_geo.eq(21)),
    value: ee.Image(22)
  });
  
man_geo=man_geo.where({
  test: trf_rs.eq(1)
                    .and(man_geo.eq(16)),
 value: ee.Image(22)
});

man_geo=man_geo.where({
  test: Srs_tomask.eq(1)
         .and(man_geo.eq(21)),
  value:ee.Image(0)

})

man_geo=man_geo.where({
  test: Rc_rs.eq(1)
        .and(man_geo.eq(15)),
  value: ee.Image(22)
})

man_geo=man_geo.where({
  test: RC_Null.eq(1).and(man_geo.eq(15)),
  value: ee.Image(0)
})
 
 man_geo=man_geo.where({
  test: TRF_srs.eq(1)
        .and(man_geo.eq(16)),
  value: ee.Image(21)
})

  man_geo = man_geo.where({
    test: Orf_irf_rs_brs_totrf.eq(1)
                      .and(man_geo.eq(14)).or(man_geo.eq(13)).or(man_geo.eq(22)).or(man_geo.eq(24)),
    value: ee.Image(16)
  })
  
  man_geo=man_geo.where({
  test: Pl_brs.eq(1)
        .and(man_geo.eq(23)),
  value: ee.Image(24)
})


 man_geo = man_geo.where({
    test: ORF_irf_rs_brs_tors.eq(1)
                      .and(man_geo.eq(14)).or(man_geo.eq(13)).or(man_geo.eq(22)).or(man_geo.eq(24)),
    value: ee.Image(22)
  })

man_geo=man_geo.where({
  test: TRF_Null.eq(1)
         .and(man_geo.eq(16)),
  value:ee.Image(0)

})

man_geo=man_geo.where({
  test: RS_srs.eq(1)
        .and(man_geo.eq(22)),
  value: ee.Image(21)
})

man_geo=man_geo.where({
  test: RS_Null.eq(1)
        .and(man_geo.eq(22)),
  value: ee.Image(0)
})

man_geo = man_geo.where({
    test: Sl_pl_dl_brs.eq(1)
                            .and(man_geo.eq(23)).or(man_geo.eq(11)).or(man_geo.eq(12)),
    value: ee.Image(24)
  });

man_geo=man_geo.where({
  test: pr_Null.eq(1)
         .and(man_geo.eq(25)),
  value:ee.Image(0)

 });
 
 man_geo=man_geo.where({
  test: Sl_rs.eq(1)
         .and(man_geo.eq(11)),
  value:ee.Image(22)
 });
 
 */
 /*
 
 var Dl_SRS_TRF_toRs = ee.Image().byte().paint(ee.Feature(Dl_SRS_trf_to_rs, {zone: 1}), "zone").clip(Dl_SRS_trf_to_rs);

 var INF_Sl = ee.Image().byte().paint(ee.Feature(irf_sl, {zone:1}), "zone").clip(irf_sl)
 var Dl_Null = ee.Image().byte().paint(ee.Feature(dl_null, {zone: 1}), "zone").clip(dl_null);
 
 man_geo = man_geo.where({
    test: Dl_SRS_TRF_toRs.eq(1)
                            .and(man_geo.eq(12)).or(man_geo.eq(16)).or(man_geo.eq(21)),
    value: ee.Image(22)
  });
  
  
man_geo = man_geo.where({
  test: INF_Sl.eq(1)
              .and(man_geo.eq(13)),
  value:ee.Image(11)
});
 
 man_geo=man_geo.where({
  test: Dl_Null.eq(1).and(man_geo.eq(12)),
  value: ee.Image(0)
})
 
 */
  if (vars.geo_refinement) {
    // make the mask image layer
    var refine = ee.Image().byte().paint(ee.Feature(refinement_mask, {zone: 1}), "zone").clip(refinement_mask);
    // apply
    man_geo = man_geo.where({
      test: refine.eq(1),
      value: ee.Image(0)
    });
  }
  
  
  
  
  // Add data + the manual layer to the map
  var lowtide_image = ee.ImageCollection(region_params.pixels).mosaic();
  Map.addLayer(lowtide_image, imageVisParam2, sensor_params.sname + ' low tide', false);
 // var notreef_mask = ee.FeatureCollection(region_params.notreef_mask).geometry();
  //Map.addLayer(notreef_mask, {}, "noReefmask", false);
  //var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  //Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false); I removed this asset by mistake
  var geo_raw = ee.Image(region_params.geo_map);
  Map.addLayer(geo_raw, map_palettes.geo, 'Geo raw', false);
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo 1', false);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(geo_clean2.updateMask(geo_clean2.gt(2)), map_palettes.geo, 'Geo clean stage 2', false);
  Map.addLayer(man_geo.updateMask(man_geo.gt(2)), map_palettes.geo, 'Geo clean stage 3', false);
  var unepClipped= wcmc.filterBounds(region_extent)
  Map.addLayer(unepClipped, {color:'#FFFF33'}, 'UNEP_layer', false)
  
 // Map.addLayer(waves, {}, 'waves', false);
 // Map.addLayer(wavespng, {}, 'wavespng', false);
  
  //Map.addLayer(man_geo.updateMask(man_geo.gt(2)), map_palettes.geo, 'Geo clean stage 3 - no DW', false);
 // Map.addLayer(global_reef_mask.updateMask(global_reef_mask.eq(1)), {palette: ['F8FF23'], opacity: 0.4}, 'global_reef_mask - land', false);
  //Map.addLayer(global_reef_mask.updateMask(global_reef_mask.eq(3)), {palette: ['0000ff'], opacity: 0.4}, 'global_reef_mask - reef', false);
  //Map.addLayer(global_reef_mask.updateMask(global_reef_mask.eq(2)), {palette: ['FF0000'], opacity: 0.4}, 'global_reef_mask - water', false);

  // display distance to land mask for assessing cut-off distances
  var distToLand = ee.Image(region_params.distToLand);
    
  //Map.addLayer(distToLand.lte(vars.dist_to_land_RC), {}, 'RC to TRF ' + vars.dist_to_land_RC + 'm', false);
 // Map.addLayer(distToLand.unmask(100000, false).lte(vars.dist_to_land_ORF), {}, 'TRF to ORF ' + vars.dist_to_land_ORF + 'm', false);
  
  // display distance to water mask
  var distToWater = ee.Image(region_params.distToWater);
    
  //Map.addLayer(distToWater.unmask(100000, false).lte(vars.dist_to_land_ORF), {}, 'distToWater ' + vars.dist_to_land_ORF + 'm', false);
  
  
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_geo,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: region_extent,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
} 

if (vars.manual_clean && !vars.geomorphic) {
  
  print("Doing BENTHIC manual clean ups - make sure this is what you want to do");
  print("Export the manual map, check 'manual' layer in the viewer for effects");
  
  var depth = ee.Image(region_params.pixels).select('depth');
  
  // define the final geomorphic map (the manually edited geo map - stage 3)
  var geo_map = ee.Image(region_params.geo_map_clean3);
  
  // define the clean benthic map to apply 2nd stage rules to
  var man_benthic = ee.Image(region_params.benthic_map_clean1);
  
  
  /*
  **Generic benthic rules**
    - should be generally applicable, but still review
  */
  
  // BMA on inner RF, outer RF,reef crest, reef slope -> rubble 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(18)
                     .and(geo_map.eq(13).or(geo_map.eq(14)).or(geo_map.eq(15)).or(geo_map.eq(22))),
    value: ee.Image(12)
  });
  
  // Rubble on Outer reef flat and Reef crest -> rock 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(12)
                     .and(geo_map.eq(14).or(geo_map.eq(15))),
    value: ee.Image(13)
  });
    
  // Seagrass on Back reef slope -> Sand 
  man_benthic = man_benthic.where({
    test: man_benthic.eq(14)
                     .and(geo_map.eq(24)),
    value: ee.Image(11)
  });  
  
     
  /*
  
  **Manual polygon guided rules**
   - same as per geomorphic clean section
   - add a geometry, paint the layer, create a rule
   
   */
  /* 

  var RockRubbleCoral_sg = ee.Image().byte().paint(ee.Feature(rockrubblecoral_sg, {zone: 1}), "zone").clip(rockrubblecoral_sg);
  
  
  
  man_benthic = man_benthic.where({
    test: RockRubbleCoral_sg.eq(1)
                  .and(man_benthic.eq(13).or(man_benthic.eq(12).or(man_benthic.eq(15)))),
    value: ee.Image(14)
  }); 
  
 var RockSeagrasstoCoral = ee.Image().byte().paint(ee.Feature(rockSeagrass_coral, {zone: 1}), "zone").clip(rockSeagrass_coral);

 man_benthic = man_benthic.where({
    test: RockSeagrasstoCoral.eq(1)
                  .and(man_benthic.eq(13).or(man_benthic.eq(14))),
    value: ee.Image(15)
  });
 
 var sg_toSand = ee.Image().byte().paint(ee.Feature(seagrass_toSand, {zone: 1}), "zone").clip(seagrass_toSand);

man_benthic = man_benthic.where({
    test: sg_toSand.eq(1)
                  .and(man_benthic.eq(14)),
    value: ee.Image(11)
  });



/*
  // code added by Mitch to regain missing data and to cleAN A ;LITTLE BIT benthic 2 > I used man_benthic10 in a first draft to chris but after that I
  //am using benthic 2_RB
  /*
  var ben_mask = man_benthic.gt(0),
  
  
  man_benthic2 = man_benthic.focal_mode(1, 'plus')
                   .updateMask(ben_mask)
               .selfMask()                  
                    
                    
  
 //This is the final benthic2 after focal_mode 
  var man_benthic10 = man_benthic.focal_mode(4, 'diamond')
                    .updateMask(ben_mask)
                    .selfMask()                  
  
 */ 
 
 
 
 /*
 
  // cleaning benthic (just porting over some rules commented above_RB.These rules act over man_benthic10
  var benthic_Mask = ee.Image().byte().paint(ee.Feature(benthic_mask.dissolve(), {zone: 1}), "zone").clip(benthic_mask);
  var SG_corals = ee.Image().byte().paint(ee.Feature(sg_corals, {zone: 1}), "zone").clip(sg_corals);
  var Rb_sand = ee.Image().byte().paint(ee.Feature(rb_sand, {zone: 1}), "zone").clip(rb_sand);
  var BMA_sg = ee.Image().byte().paint(ee.Feature(bma_sg, {zone: 1}), "zone").clip(bma_sg);
  var Rock_sand = ee.Image().byte().paint(ee.Feature(rock_sand, {zone: 1}), "zone").clip(rock_sand);
 var Corals_sg = ee.Image().byte().paint(ee.Feature(corals_sg, {zone: 1}), "zone").clip(corals_sg);
var Rock_sg = ee.Image().byte().paint(ee.Feature(rock_sg, {zone: 1}), "zone").clip(rock_sg);
 
 man_benthic = man_benthic.where({
  test: benthic_Mask.eq(1),
  value: ee.Image (0),
})   
   
  man_benthic = man_benthic.where({
    test: SG_corals.eq(1)
                   .and(man_benthic.eq(14)),
    value: ee.Image(15)
  })
  
  man_benthic = man_benthic.where({
    test: Rb_sand.eq(1)
                   .and(man_benthic.eq(12)),
    value: ee.Image(11)
  })
  
  man_benthic = man_benthic.where({
    test: BMA_sg.eq(1)
                   .and(man_benthic.eq(18)),
    value: ee.Image(14)
  })
  
 man_benthic = man_benthic.where({
    test: Rock_sand.eq(1)
                   .and(man_benthic.eq(13)),
    value: ee.Image(11)
  })
  
man_benthic = man_benthic.where({
    test: Corals_sg.eq(1)
                   .and(man_benthic.eq(15)),
    value: ee.Image(14)
  })  

man_benthic = man_benthic.where({
    test: Rock_sg.eq(1)
                   .and(man_benthic.eq(13)),
    value: ee.Image(14)
  })    
  

  //turn everything in geo RS into benthic coral_algae
  man_benthic10 = man_benthic10.where({
       test:  man_benthic10
              .and(geo_map.eq(22)),
       value: ee.Image(15)
  })
  
  //turn everything in geo SRS into benthic coral_algae
  man_benthic10 = man_benthic10.where({
       test:  man_benthic10
              .and(geo_map.eq(21)),
       value: ee.Image(15)
  })
  
  */
    
  var rb_corals = ee.Image().byte().paint(ee.Feature(rbCoral, {zone: 1}), "zone").clip(rbCoral);
  
   man_benthic = man_benthic.where({
    test: rb_corals.eq(1)
                   .and(man_benthic.eq(12)),
    value: ee.Image(15)
  }) 
  
  
  var sandCorals = ee.Image().byte().paint(ee.Feature(sandCoral, {zone: 1}), "zone").clip(sandCoral);
  
   man_benthic = man_benthic.where({
    test: sandCorals.eq(1)
                   .and(man_benthic.eq(11)),
    value: ee.Image(15)
  }) 
  
  var rockCorals = ee.Image().byte().paint(ee.Feature(rockCoral, {zone: 1}), "zone").clip(rockCoral); 
  
   man_benthic = man_benthic.where({
    test: rockCorals.eq(1)
                   .and(man_benthic.eq(13)),
    value: ee.Image(15)
  }) 
  

  // Add the manual layer to the map

  var dove_image = ee.ImageCollection(region_params.pixels).mosaic();
  Map.addLayer(dove_image, {bands: ['b3','b2','b1'], min:0, max:4000, gamma:1.5}, sensor_params.sname + ' low tide', true);
  
  var benthic_clean1 = ee.Image(region_params.benthic_map_clean1);
  var geo_clean1 = ee.Image(region_params.geo_map_clean1);
  var geo_clean2 = ee.Image(region_params.geo_map_clean2);
  Map.addLayer(geo_clean1, map_palettes.geo, 'Geo clean stage 1', false);
   Map.addLayer(geo_clean2.updateMask(geo_clean2.gt(2)), map_palettes.geo, 'Geo clean stage 2', false);
  // Map.addLayer(geo_clean2, map_palettes.geo, 'Geo clean stage 2', false);
  //Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Geo clean stage 3 - MANUAL', true);
  Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Geo clean stage 3 - MANUAL', false);
  Map.addLayer(benthic_clean1.updateMask(geo_map.gt(0)), map_palettes.benthic, 'Benthic clean stage 1', false);
  //Map.addLayer(man_benthic.updateMask(man_benthic.gt(0)), map_palettes.benthic, 'Benthic clean stage 2 - MANUAL', true);
  Map.addLayer(man_benthic.updateMask(man_benthic.gt(0)), map_palettes.benthic, 'Benthic clean stage 2 ', true);
  //Map.addLayer(man_benthic10.updateMask(man_benthic10.gt(0)), map_palettes.benthic, 'Benthic clean stage 2 - MANUAL10_radius', true);
  // Export
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  Export.image.toAsset({
    image: man_benthic,
    description: output_name,
    assetId: vars.asset_output + 'in_out/' + output_name,
    region: region_extent,
    scale: vars.image_data_scale,
    crs: 'EPSG:4326',
    maxPixels: 1e13,
    pyramidingPolicy: {'.default': 'mode'}
  });
  
}

// #################################################################################################
// END OF MANUAL SECTION
// #################################################################################################


// 2. Data loads & vis

if (!vars.manual_clean) {

  // load input data
  
  // define raw geo/benthic outputs
  // Run check to see if the region has been split into multiple areas
  
  // geo
  if (ee.List(region_params.geo_map).length().getInfo() > 1) {
    var geo_map_raw = ee.Image(region_params.geo_map[0]).unmask(0, false)
                 .add(ee.Image(region_params.geo_map[1]).unmask(0,false))
                 .selfMask();
  } else {
    var geo_map_raw = ee.Image(region_params.geo_map);
  }
  
  // benthic
  if (ee.List(region_params.benthic_map).length().getInfo() > 1) {
      var benthic_map = ee.Image(region_params.benthic_map[0]).unmask(0, false)
               .add(ee.Image(region_params.benthic_map[1]).unmask(0,false))
               .selfMask();
  } else {
      var benthic_map = ee.Image(region_params.benthic_map);
  }
  
  // set the geo map for further processing
  if (vars.geomorphic && vars.obia_2nd_pass) {
    // if it's 2nd pass, you want to make sure you're loading the latest geo clean map
    var geo_map = ee.Image(region_params.geo_map_clean1);
  } else if (vars.geomorphic) {
    var geo_map = geo_map_raw;
  }
  
  var depth = ee.Image(region_params.pixels).select('depth');
  var low_tide_image = ee.Image(region_params.image);
  
  var display_pal = (vars.geomorphic) ? map_palettes.geo : map_palettes.benthic;
  Map.addLayer(depth, {min:0, max:2500}, 'Depth data', false);
  Map.addLayer(low_tide_image, {bands: ['b3','b2','b1'], min:0, max:3000}, sensor_params.sname + ' low tide', false);
  
  // load for display purposes
  if (vars.geomorphic) {
    Map.addLayer(geo_map_raw, display_pal, 'Geomorphic map RAW', false);
    if (vars.cleanup_stage == 2) Map.addLayer(ee.Image(region_params.geo_map_clean1), display_pal, 'Geo clean stage 1', false);
  }
  if (!vars.geomorphic) {
    // Use the manually cleaned geomorphic map as input for the benthic clean
    var geo_map = ee.Image(region_params.geo_map_clean3);
    Map.addLayer(geo_map.updateMask(geo_map.gt(2)), map_palettes.geo, 'Geo clean stage 3', false);
    Map.addLayer(benthic_map, display_pal, 'Benthic map RAW', false);
  }
  
  // 3. Object-based re-classificaiton and cleaning
  
  /* OUTPUT EXTENT
    - to the mapping extent just so it doesn't balloon out
    - to the 'reef boundary' extent for noise/deep removal
  */  
  var class_extent_mask = geo_map.gt(0);
  
  /*
  
  ########
  Initial small object clean
   - this was originally at the end, but we needed to massively reduce the number of objects to 
     iterate through in the OBIA cleaning, so this happens first now
   - future collabs with google might fix this, but need to change the parallel serialisation of vector procesing
   
   - includes a possible special case for:
        - geomorphic to clean up turbid areas over size threshold; fix shallow vs. deep lagoon
        - benthic to allow breaking waves (temporal class) to grow into surrounding class
  ########
  
  */
  
  // ##############################################################################################
  // START OF CLEAN 1
  // ##############################################################################################
  
  if (vars.geomorphic && !vars.obia_2nd_pass) {
    
    // shallow lagoon > 5m == deep lagoon//this rule is making mini deep laggoons witin BRS 
    //so I will generate another clean up1 with shallow lagoons instead (comenting this up)
    
    // = geo_map.where({
     // test: geo_map.eq(11)
                    //.and(depth.gt(vars.shallowlag_depth_cutoff)),
      //value: ee.Image(12)
    //});
    
    // deep water in depth data == deep (s2 + ls8 data should be good enough for this)
    geo_map = geo_map.where({
      test: depth.gt(vars.geo_depth_cutoff),
      value: ee.Image(2)
    });
    
    // make a smooth map with masked area as a value - *** Change to ee.kernal*** see reef mask in clean 3
    var smooth_map = geo_map
                        .focal_mode({
                          radius: vars.smooth_radius, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 2
                        });
    
    // replace small objects with smooth underneath
    var clean_map = geo_map.where({
      test: geo_map.connectedPixelCount(vars.small_object_geo, false).lt(vars.small_object_geo), 
      value: smooth_map
    }).updateMask(class_extent_mask);
    
    // display distance to land mask for assessing cut-off distances
    var distToLand = ee.Image(region_params.distToLand);
    
    Map.addLayer(distToLand.lte(vars.dist_to_land_RC), {}, 'RC to TRF ' + vars.dist_to_land_RC + 'm', false);
    Map.addLayer(distToLand.unmask(100000, false).lte(vars.dist_to_land_ORF), {}, 'TRF to ORF ' + vars.dist_to_land_ORF + 'm', false);

    // // reef crest close to land -> TRF - Not need when using .focal masks (reef mask) as this will take care of RC inside the reef
    // clean_map = clean_map.where({
    //   test: distToLand.lte(vars.dist_to_land_RC)
    //                 .and(clean_map.eq(15)),
    //   value: ee.Image(16)
    // });
    
    // TRF outside of specified distance from land -> ORF
    clean_map = clean_map.where({
      test: distToLand.unmask(100000, false).gt(vars.dist_to_land_ORF)
                       .and(clean_map.eq(16)),
      value: ee.Image(14)
    });
  }
  
  if (!vars.geomorphic && vars.cleanup_stage == 1) {
    
    // make a smooth map with masked area as a value, and without temporal class (basically breaking waves)
    var smooth_map = benthic_map
                        .focal_mode({
                          radius: vars.smooth_radius, // relates to smoothness required
                          kernelType: 'circle', units: 'pixels', iterations: 1
                        });
    
    //replace small objects with smooth underneath
    var clean_map = benthic_map.where({
      test: benthic_map.connectedPixelCount(vars.small_object_benthic, false).lt(vars.small_object_benthic),
      value: smooth_map
    }).updateMask(class_extent_mask);
    
  }
  
  // ##############################################################################################
  // START OF CLEAN 2
  // ##############################################################################################
  
  if (vars.geomorphic && vars.obia_2nd_pass) {
    var clean_map = geo_map;
  }
  
  if (vars.obia_clean) {
    
    if (vars.geomorphic && !vars.fast_clean) { 
      
      // FUNCTION that maps over feature colleciton and assigns neighbour percentages
      var set_neighbour_properties = function(f) {
        // make the 1px buffer
        var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5));
        // reduce the classes in the buffer zone
        var diff_classes = ee.Dictionary(
          clean_map.unmask(ee.Image(0)).reduceRegion({
            reducer: ee.Reducer.frequencyHistogram(),
            geometry: diff.geometry(),
            scale: vars.image_data_scale,
            maxPixels: 1e11
          }).get('classification')
        );
        // calculate the percentages
        var diff_sum = diff_classes.toArray().reduce(ee.Reducer.sum(), [0]).get([0]);
        var diff_percs = diff_classes.map(function(k,v){return(ee.Number(v).divide(diff_sum).multiply(100).toUint8())});
        
        /* NOW, we can try to do the class logic right here (see /users/mitchest/global_reefs/obia_dev),
           or we can return the neighbour % and do image logic via (painted) rasters */
        
        return(f.set(diff_percs));
      };
      
      // FUNCTION to reduce the map to vectors and map the neighbour properties function
      var reduce_neighbours = function() {
        // reduce map to vectors
        var map_fc = clean_map
              .updateMask(segment_id).updateMask(clean_map.eq(classn)) // only vectorise class/es of interest
              .reduceToVectors({
                scale: vars.image_data_scale, 
                eightConnected: false,
                bestEffort: true, 
                maxPixels: 1e13,
                tileScale: 1,
                geometry: region_extent
              });
        // map the function, calculate neighbour properties
        return(map_fc.map(set_neighbour_properties));
      };
      
      // first make a make size threshold, so we're not vecortising huge objects when we don't have to
      var segment_id = clean_map.connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels');
      //Map.addLayer(segment_id.reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))))
      Map.addLayer(clean_map.updateMask(segment_id).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
      
      // This is where we select the single or group of classes to vectorise for cleaning up
      //var classn = ee.Number(15) // one class
      var classn = clean_map.where({
        test: clean_map.neq(16) //TRF
                .and(clean_map.neq(15)) //RR
                .and(clean_map.neq(14)) //ORF
                .and(clean_map.neq(13)) //IRF
                //.and(clean_map.neq(12)) // deep L
                .and(clean_map.neq(11)), // shallow L 
        value: ee.Image(99) // 99 ensures it's ignored in logic
      });
      
      // Minimum size of object to reclass based on neighbourhood
      var max_size = ee.Number(1000).divide(vars.image_data_scale).pow(2); // the first number is the square dimension of the desired min size;
      // calculate neighbours
      var map_fc_neighbours = reduce_neighbours();
      
      // #########
      // REEF RIM
      // #########
      
      var focus_class = ee.Number(15); //RR
      
      // start the object-based neighbourhood rules
      // paint out to rasters (only paint the layers needed)
      var objsize = ee.Image(30000).paint(map_fc_neighbours, 'count').rename('count');
      //var nb24 = ee.Image().byte().paint(map_fc_neighbours, '24').unmask(0).rename('nb24') //OCL
      var nb22 = ee.Image().byte().paint(map_fc_neighbours, '22').unmask(0).rename('nb22'); //SL ex
      var nb21 = ee.Image().byte().paint(map_fc_neighbours, '21').unmask(0).rename('nb21'); //Sl sh
      var nb16 = ee.Image().byte().paint(map_fc_neighbours, '16').unmask(0).rename('nb16'); //TRF
      var nb15 = ee.Image().byte().paint(map_fc_neighbours, '15').unmask(0).rename('nb15'); //RR
      var nb14 = ee.Image().byte().paint(map_fc_neighbours, '14').unmask(0).rename('nb14'); //ORF
      var nb13 = ee.Image().byte().paint(map_fc_neighbours, '13').unmask(0).rename('nb13'); //IRF
      //var nb3 = ee.Image().byte().paint(map_fc_neighbours, '3').unmask(0).rename('nb3') //Turbid
      
      // RR surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // RR surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // RR surrounded by IRF + ORF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.add(nb14).gt(75)),
        value: ee.Image(13)
      });
      
      // RR with decent border to TRF --> TRF (often dark, probably seagrass)
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(40)),
        value: ee.Image(16)
      });
      
      // RR surrounded by OCL --> OCL
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb24.gt(75)),
        value: ee.Image(24)
      })
      
      // small RR objects touching OCL + stuff --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(objsize.lte(max_size))
                .and(nb13.lte(75).and(nb14.lte(75))) // to ensure we're no re-writing previous rules
                .and(nb24.gt(1)),
        value: ee.Image(14)
      })
      
      // ####
      // ORF
      // ####
      
      focus_class = ee.Number(14); // ORF
      
      // ORF surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // ORF surrounded by TRF --> TRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(75)),
        value: ee.Image(16)
      });
      
      // ORF surrounded by RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb15.gt(85)),
        value: ee.Image(15)
      });
      
      // ORF touching slope and RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb21.gt(0).or(nb22.gt(0)))
                .and(nb15.gt(0)),
        value: ee.Image(15)
      });
      
      // ####
      // IRF
      // ####
      
      focus_class = ee.Number(13); // IRF
      
      // IRF surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // IRF surrounded by TRF --> TRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb16.gt(75)),
        value: ee.Image(16)
      });
      
      // IRF surrounded by RR --> RR
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb15.gt(85)),
        value: ee.Image(15)
      });
      
      // ####
      // TRF
      // ####
      
      focus_class = ee.Number(16); // TRF
      
      // TRF surrounded by ORF --> ORF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb14.gt(75)),
        value: ee.Image(14)
      });
      
      // TRF surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.gt(75)),
        value: ee.Image(13)
      });
      
      // TRF surrounded by IRF + ORF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(focus_class)
                .and(nb13.add(nb14).gt(75)),
        value: ee.Image(13)
      });
      
      // ####
      // LAGOONS
      // ####
      
      var nb11 = ee.Image().byte().paint(map_fc_neighbours, '11').unmask(0).rename('nb11'); // shallow lag
      
      // SL sourrounded by DL --> DL
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                .and(nb12.gt(75)),
        value: ee.Image(12)
      })
      
      // DL sourrounded by SL --> SL
      clean_map = clean_map.where({
        test: clean_map.eq(12)
                .and(nb11.gt(75)),
        value: ee.Image(11)
      })
      
      // DL/SL surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(11).or(clean_map.eq(12))
                .and(objsize.lte(max_size))
                .and(nb13.gt(80)),
        value: ee.Image(13)
      })
      
      // SL surrounded by IRF --> IRF
      clean_map = clean_map.where({
        test: clean_map.eq(11)
                .and(objsize.lte(max_size))
                .and(nb13.gt(80)),
        value: ee.Image(13)
      });
      
    
    } else if (vars.geomorphic && vars.fast_clean) {
      print("Executing the fast version OBIA");
      
      /* fast version of the geo clean up
        - blanket version assigns the underlying most common in neighbourhood
        - mode OBIA version iterates through objects+buffers but take the mode instead of doing the class percs, to see if that speeds things up
      */
      
      
      // ## Blanket version
      
      // make a very smooth map to capture the broader neighbourhood  - *** Change to ee.kernal*** see reef mask in clean 3
      var smooth_map = clean_map
                          .focal_mode({
                            radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                            kernelType: 'circle', units: 'pixels', iterations: 2
                          });
      
      // first make a make size threshold, so we're not vectorising huge objects when we don't have t
      // - the unmask(99) captures small no data values/ data gaps
      var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt().multiply(2)).select('labels').pow(2).log().int();
      Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false);
      
      // replace small objects with smooth underneath
      var clean_map = clean_map.unmask(0).where({
        test: segment_id.gt(0), 
        value: smooth_map
      }).selfMask();
      
      
      // ## mode OBIA version
      
      /* A possible faster plan
            - vectorise one/few class/es at a time, thus only spending resources on what is actually needed to clean up
            - BUT, just assign the mode of the neighbours, so save resouces even further??
      
      // FUNCTION that maps over feature colleciton and assigns neighbour percentages
      var set_neighbour_mode = function(f) {
        // make the 1px buffer
        var diff = f.buffer(vars.image_data_scale).difference(f, ee.ErrorMargin(0.5))
        // reduce the classes in the buffer zone
        var diff_mode = ee.Number(ee.Dictionary(
          clean_map.unmask(ee.Image(0)).reduceRegion({
            reducer: ee.Reducer.mode(),
            geometry: diff.geometry(),
            scale: vars.image_data_scale,
            maxPixels: 1e11
          })).get('classification'))
        
        return(f.set('mode',diff_mode))
      }
      
      // FUNCTION to reduce the map to vectors and map the neighbour properties function
      var reduce_neighbours_mode = function() {
        // reduce map to vectors
        var map_fc = clean_map.unmask(0)
              .updateMask(classn.gt(0)) // only vectorise class/es of interest
              .reduceToVectors({
                scale: vars.image_data_scale, 
                eightConnected: false,
                bestEffort: true, 
                maxPixels: 1e13,
                tileScale: 1,
                geometry: region_extent
              })
        // map the function, calculate neighbour properties
        return(map_fc.map(set_neighbour_mode))
      }
      
      // first make a make size threshold, so we're not vecortising huge objects when we don't have to
      var segment_id = clean_map.unmask(0).connectedComponents(ee.Kernel.plus(1),vars.small_object_geo.sqrt()).select('labels')
      Map.addLayer(clean_map.unmask(0).updateMask(segment_id.gt(0)).reproject(ee.Projection('EPSG:4326').atScale(ee.Number(vars.image_data_scale))), display_pal, 'Map objects to be iterated through (OBIA)', false)
      
      // This is where we select the single or group of classes to vectorise for cleaning up
      var classn = segment_id.where({
        test: clean_map.neq(16) //TRF
                .and(clean_map.neq(15)) //RR
                .and(clean_map.neq(14)) //ORF
                .and(clean_map.neq(13)) //IRF
                //.and(clean_map.neq(12)) // deep L
                .and(clean_map.neq(11)) // shallow L 
                .and(clean_map.unmask(0).neq(0)), // no data values (want to reclaim the small gaps 
        value: ee.Image(0) // 99 ensures it's ignored in logic
      })
      
      // calculate neighbours
      var map_fc_neighbours = reduce_neighbours_mode()
      
      //print(map_fc_neighbours.limit(10))
      
      var mode_map = ee.Image().byte().paint(map_fc_neighbours, 'mode').unmask(0).rename('mode') // paint out the mode values to an image
      //Map.addLayer(mode_map, display_pal, "mode map", false)
      
      // replace small objects with mode underneath
      var clean_map = clean_map.unmask(0).where({
        test: segment_id.gt(0), 
        value: mode_map
      }).selfMask()
      
      */
      
    } else {
      
      if (vars.cleanup_stage == 1) {
        // BENTHIC CLEAN-UP RULES
        
        // reclaim shallow no data to surrounding class
        var smooth_map = clean_map
                            .focal_mode({
                              radius: vars.smooth_radius.multiply(3), // relates to smoothness required
                              kernelType: 'circle', units: 'pixels', iterations: 2
                            });
        
        var clean_map = clean_map.unmask(0).where({
          test: geo_map.gt(2).and(clean_map.eq(0)), 
          value: smooth_map
        }).selfMask();
        
        // cut benthic off to < 10 - 15 m
        clean_map = clean_map.where({
          test: depth.gt(vars.benthic_depth_cutoff),
          value: ee.Image(0)
        });
        
        // Deep (or land or missing) in geo == masked from benthic
        clean_map = clean_map.where({
          test: geo_map.unmask(0).lte(2),
          value: ee.Image(0)
        });
        
      }
    }
  }
  
  // Final clip to the classified extent and move on
  if (vars.geomorphic) {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  } else {
    clean_map = clean_map.updateMask(clean_map.gt(1)); // this ignores 0/land; make it .gt(2) if you want to mask deep too
  }

  
  
  // 4. Export data
  
  var output_name = (vars.geomorphic) ? vars.geomorph_output_name : vars.benthic_output_name;
  
  if (vars.do_export) {
    print("For export, the image data scale must be set to:", vars.image_data_scale);
    
    Map.addLayer(region_extent, {}, "Export footprint", false);
    
    Export.image.toAsset({
      image: clean_map.set(vars),
      description: output_name,
      assetId: vars.asset_output + 'in_out/' + output_name,
      region: region_extent,
      scale: vars.image_data_scale,
      crs: 'EPSG:4326',
      maxPixels: 1e13,
      pyramidingPolicy: {'.default': 'mode'}
    });
    
  } else {
    if (vars.reproject_display) {
      Map.addLayer(clean_map.reproject(ee.Projection('EPSG:4326').atScale(vars.image_data_scale)), display_pal, output_name, true);
    } else {
      Map.addLayer(clean_map, display_pal, output_name, false);
    }
  }

}

//Generate title
var title = ui.Label({
  value: 'Classes',
  style: {fontWeight: 'bold', fontSize: '12px'}
});

// generate the legend
var geo_legend = pkg_vis.discrete_legend(map_palettes.geo_atlas_names, map_palettes.geo_atlas_cols, 'Geomorphic Zone', false);
var benthic_legend = pkg_vis.discrete_legend(map_palettes.benthic_atlas_names, map_palettes.benthic_atlas_cols, 'Benthic Habitat', false);
//var mask_legend = pkg_vis.discrete_legend(["Low confidence depth","Water conditions"], ["#f7f7f7","#bababa"], 'Confidence Mask reason', false)
var legend = (vars.geomorphic) ? geo_legend : benthic_legend;
pkg_vis.add_lgds([title, legend]);//, mask_legend])
// generate the legend
